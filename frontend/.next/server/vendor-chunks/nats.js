"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nats";
exports.ids = ["vendor-chunks/nats"];
exports.modules = {

/***/ "(rsc)/./node_modules/nats/index.js":
/*!************************************!*\
  !*** ./node_modules/nats/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n * Copyright 2013-2020 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nmodule.exports = __webpack_require__(/*! ./lib/src/mod */ \"(rsc)/./node_modules/nats/lib/src/mod.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIscUdBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9pbmRleC5qcz8wZTYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDIwIFRoZSBOQVRTIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvc3JjL21vZFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/consumer.js":
/*!*****************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/consumer.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OrderedPullConsumerImpl = exports.PullConsumerImpl = exports.OrderedConsumerMessages = exports.PullConsumerMessagesImpl = exports.ConsumerDebugEvents = exports.ConsumerEvents = void 0;\n/*\n * Copyright 2022-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst util_1 = __webpack_require__(/*! ../nats-base-client/util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst nuid_1 = __webpack_require__(/*! ../nats-base-client/nuid */ \"(rsc)/./node_modules/nats/lib/nats-base-client/nuid.js\");\nconst jsutil_1 = __webpack_require__(/*! ./jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\nconst queued_iterator_1 = __webpack_require__(/*! ../nats-base-client/queued_iterator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\");\nconst core_1 = __webpack_require__(/*! ../nats-base-client/core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nconst idleheartbeat_monitor_1 = __webpack_require__(/*! ../nats-base-client/idleheartbeat_monitor */ \"(rsc)/./node_modules/nats/lib/nats-base-client/idleheartbeat_monitor.js\");\nconst jsmsg_1 = __webpack_require__(/*! ./jsmsg */ \"(rsc)/./node_modules/nats/lib/jetstream/jsmsg.js\");\nconst jsapi_types_1 = __webpack_require__(/*! ./jsapi_types */ \"(rsc)/./node_modules/nats/lib/jetstream/jsapi_types.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/nats/lib/jetstream/types.js\");\nvar PullConsumerType;\n(function (PullConsumerType) {\n    PullConsumerType[PullConsumerType[\"Unset\"] = -1] = \"Unset\";\n    PullConsumerType[PullConsumerType[\"Consume\"] = 0] = \"Consume\";\n    PullConsumerType[PullConsumerType[\"Fetch\"] = 1] = \"Fetch\";\n})(PullConsumerType || (PullConsumerType = {}));\n/**\n * ConsumerEvents are informational notifications emitted by ConsumerMessages\n * that may be of interest to a client.\n */\nvar ConsumerEvents;\n(function (ConsumerEvents) {\n    /**\n     * Notification that heartbeats were missed. This notification is informational.\n     * The `data` portion of the status, is a number indicating the number of missed heartbeats.\n     * Note that when a client disconnects, heartbeat tracking is paused while\n     * the client is disconnected.\n     */\n    ConsumerEvents[\"HeartbeatsMissed\"] = \"heartbeats_missed\";\n    /**\n     * Notification that the consumer was not found. Consumers that were accessible at\n     * least once, will be retried for more messages regardless of the not being found\n     * or timeouts etc. This notification includes a count of consecutive attempts to\n     * find the consumer. Note that if you get this notification possibly your code should\n     * attempt to recreate the consumer. Note that this notification is only informational\n     * for ordered consumers, as the consumer will be created in those cases automatically.\n     */\n    ConsumerEvents[\"ConsumerNotFound\"] = \"consumer_not_found\";\n    /**\n     * Notification that the stream was not found. Consumers were accessible at least once,\n     * will be retried for more messages regardless of the not being found\n     * or timeouts etc. This notification includes a count of consecutive attempts to\n     * find the consumer. Note that if you get this notification possibly your code should\n     * attempt to recreate the consumer. Note that this notification is only informational\n     * for ordered consumers, as the consumer will be created in those cases automatically.\n     */\n    ConsumerEvents[\"StreamNotFound\"] = \"stream_not_found\";\n    /*\n     * Notification that the consumer was deleted. This notification\n     * means the consumer will not get messages unless it is recreated. The client\n     * will continue to attempt to pull messages. Ordered consumer will recreate it.\n     */\n    ConsumerEvents[\"ConsumerDeleted\"] = \"consumer_deleted\";\n    /**\n     * This notification is specific of ordered consumers and will be notified whenever\n     * the consumer is recreated. The argument is the name of the newly created consumer.\n     */\n    ConsumerEvents[\"OrderedConsumerRecreated\"] = \"ordered_consumer_recreated\";\n})(ConsumerEvents || (exports.ConsumerEvents = ConsumerEvents = {}));\n/**\n * These events represent informational notifications emitted by ConsumerMessages\n * that can be safely ignored by clients.\n */\nvar ConsumerDebugEvents;\n(function (ConsumerDebugEvents) {\n    /**\n     * DebugEvents are effectively statuses returned by the server that were ignored\n     * by the client. The `data` portion of the\n     * status is just a string indicating the code/message of the status.\n     */\n    ConsumerDebugEvents[\"DebugEvent\"] = \"debug\";\n    /**\n     * Requests for messages can be terminated by the server, these notifications\n     * provide information on the number of messages and/or bytes that couldn't\n     * be satisfied by the consumer request. The `data` portion of the status will\n     * have the format of `{msgsLeft: number, bytesLeft: number}`.\n     */\n    ConsumerDebugEvents[\"Discard\"] = \"discard\";\n    /**\n     * Notifies whenever there's a request for additional messages from the server.\n     * This notification telegraphs the request options, which should be treated as\n     * read-only. This notification is only useful for debugging. Data is PullOptions.\n     */\n    ConsumerDebugEvents[\"Next\"] = \"next\";\n})(ConsumerDebugEvents || (exports.ConsumerDebugEvents = ConsumerDebugEvents = {}));\nclass PullConsumerMessagesImpl extends queued_iterator_1.QueuedIteratorImpl {\n    // callback: ConsumerCallbackFn;\n    constructor(c, opts, refilling = false) {\n        super();\n        this.consumer = c;\n        this.opts = this.parseOptions(opts, refilling);\n        this.callback = opts.callback || null;\n        this.noIterator = typeof this.callback === \"function\";\n        this.monitor = null;\n        this.pong = null;\n        this.pending = { msgs: 0, bytes: 0, requests: 0 };\n        this.refilling = refilling;\n        this.stack = new Error().stack.split(\"\\n\").slice(1).join(\"\\n\");\n        this.timeout = null;\n        this.inbox = (0, core_1.createInbox)(c.api.nc.options.inboxPrefix);\n        this.listeners = [];\n        this.forOrderedConsumer = false;\n        this.start();\n    }\n    start() {\n        const { max_messages, max_bytes, idle_heartbeat, threshold_bytes, threshold_messages, } = this.opts;\n        // ordered consumer requires the ability to reset the\n        // source pull consumer, if promise is registered and\n        // close is called, the pull consumer will emit a close\n        // which will close the ordered consumer, by registering\n        // the close with a handler, we can replace it.\n        this.closed().then(() => {\n            if (this.cleanupHandler) {\n                try {\n                    this.cleanupHandler();\n                }\n                catch (_err) {\n                    // nothing\n                }\n            }\n        });\n        const { sub } = this;\n        if (sub) {\n            sub.unsubscribe();\n        }\n        this.sub = this.consumer.api.nc.subscribe(this.inbox, {\n            callback: (err, msg) => {\n                var _a, _b, _c, _d;\n                if (err) {\n                    // this is possibly only a permissions error which means\n                    // that the server rejected (eliminating the sub)\n                    // or the client never had permissions to begin with\n                    // so this is terminal\n                    this.stop();\n                    return;\n                }\n                (_a = this.monitor) === null || _a === void 0 ? void 0 : _a.work();\n                const isProtocol = msg.subject === this.inbox;\n                if (isProtocol) {\n                    if ((0, jsutil_1.isHeartbeatMsg)(msg)) {\n                        return;\n                    }\n                    const code = (_b = msg.headers) === null || _b === void 0 ? void 0 : _b.code;\n                    const description = ((_d = (_c = msg.headers) === null || _c === void 0 ? void 0 : _c.description) === null || _d === void 0 ? void 0 : _d.toLowerCase()) ||\n                        \"unknown\";\n                    const { msgsLeft, bytesLeft } = this.parseDiscard(msg.headers);\n                    if (msgsLeft > 0 || bytesLeft > 0) {\n                        this.pending.msgs -= msgsLeft;\n                        this.pending.bytes -= bytesLeft;\n                        this.pending.requests--;\n                        this.notify(ConsumerDebugEvents.Discard, { msgsLeft, bytesLeft });\n                    }\n                    else {\n                        // FIXME: 408 can be a Timeout or bad request,\n                        //  or it can be sent if a nowait request was\n                        //  sent when other waiting requests are pending\n                        //  \"Requests Pending\"\n                        // FIXME: 400 bad request Invalid Heartbeat or Unmarshalling Fails\n                        //  these are real bad values - so this is bad request\n                        //  fail on this\n                        const toErr = () => {\n                            const err = new core_1.NatsError(description, `${code}`);\n                            err.stack += `\\n\\n${this.stack}`;\n                            return err;\n                        };\n                        // we got a bad request - no progress here\n                        if (code === 400) {\n                            const error = toErr();\n                            //@ts-ignore: fn\n                            this._push(() => {\n                                this.stop(error);\n                            });\n                        }\n                        else if (code === 409 && description === \"consumer deleted\") {\n                            this.notify(ConsumerEvents.ConsumerDeleted, `${code} ${description}`);\n                        }\n                        else {\n                            this.notify(ConsumerDebugEvents.DebugEvent, `${code} ${description}`);\n                        }\n                    }\n                }\n                else {\n                    // push the user message\n                    this._push((0, jsmsg_1.toJsMsg)(msg));\n                    this.received++;\n                    if (this.pending.msgs) {\n                        this.pending.msgs--;\n                    }\n                    if (this.pending.bytes) {\n                        this.pending.bytes -= msg.size();\n                    }\n                }\n                // if we don't have pending bytes/messages we are done or starving\n                if (this.pending.msgs === 0 && this.pending.bytes === 0) {\n                    this.pending.requests = 0;\n                }\n                if (this.refilling) {\n                    // FIXME: this could result in  1/4 = 0\n                    if ((max_messages &&\n                        this.pending.msgs <= threshold_messages) ||\n                        (max_bytes && this.pending.bytes <= threshold_bytes)) {\n                        const batch = this.pullOptions();\n                        // @ts-ignore: we are pushing the pull fn\n                        this.pull(batch);\n                    }\n                }\n                else if (this.pending.requests === 0) {\n                    // @ts-ignore: we are pushing the pull fn\n                    this._push(() => {\n                        this.stop();\n                    });\n                }\n            },\n        });\n        this.sub.closed.then(() => {\n            // for ordered consumer we cannot break the iterator\n            if (this.sub.draining) {\n                // @ts-ignore: we are pushing the pull fn\n                this._push(() => {\n                    this.stop();\n                });\n            }\n        });\n        if (idle_heartbeat) {\n            this.monitor = new idleheartbeat_monitor_1.IdleHeartbeatMonitor(idle_heartbeat, (data) => {\n                // for the pull consumer - missing heartbeats may be corrected\n                // on the next pull etc - the only assumption here is we should\n                // reset and check if the consumer was deleted from under us\n                this.notify(ConsumerEvents.HeartbeatsMissed, data);\n                this.resetPending()\n                    .then(() => {\n                })\n                    .catch(() => {\n                });\n                return false;\n            }, { maxOut: 2 });\n        }\n        // now if we disconnect, the consumer could be gone\n        // or we were slow consumer'ed by the server\n        (() => __awaiter(this, void 0, void 0, function* () {\n            var _a, e_1, _b, _c;\n            var _d;\n            const status = this.consumer.api.nc.status();\n            this.statusIterator = status;\n            try {\n                for (var _e = true, status_1 = __asyncValues(status), status_1_1; status_1_1 = yield status_1.next(), _a = status_1_1.done, !_a; _e = true) {\n                    _c = status_1_1.value;\n                    _e = false;\n                    const s = _c;\n                    switch (s.type) {\n                        case core_1.Events.Disconnect:\n                            // don't spam hb errors if we are disconnected\n                            // @ts-ignore: optional chaining\n                            (_d = this.monitor) === null || _d === void 0 ? void 0 : _d.cancel();\n                            break;\n                        case core_1.Events.Reconnect:\n                            // do some sanity checks and reset\n                            // if that works resume the monitor\n                            this.resetPending()\n                                .then((ok) => {\n                                var _a;\n                                if (ok) {\n                                    // @ts-ignore: optional chaining\n                                    (_a = this.monitor) === null || _a === void 0 ? void 0 : _a.restart();\n                                }\n                            })\n                                .catch(() => {\n                                // ignored - this should have fired elsewhere\n                            });\n                            break;\n                        default:\n                        // ignored\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_e && !_a && (_b = status_1.return)) yield _b.call(status_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }))();\n        // this is the initial pull\n        this.pull(this.pullOptions());\n    }\n    _push(r) {\n        if (!this.callback) {\n            super.push(r);\n        }\n        else {\n            const fn = typeof r === \"function\" ? r : null;\n            try {\n                if (!fn) {\n                    this.callback(r);\n                }\n                else {\n                    fn();\n                }\n            }\n            catch (err) {\n                this.stop(err);\n            }\n        }\n    }\n    notify(type, data) {\n        if (this.listeners.length > 0) {\n            (() => {\n                this.listeners.forEach((l) => {\n                    if (!l.done) {\n                        l.push({ type, data });\n                    }\n                });\n            })();\n        }\n    }\n    resetPending() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let notFound = 0;\n            let streamNotFound = 0;\n            const bo = (0, util_1.backoff)();\n            let attempt = 0;\n            while (true) {\n                if (this.consumer.api.nc.isClosed()) {\n                    console.error(\"aborting resetPending - connection is closed\");\n                    return false;\n                }\n                try {\n                    // check we exist\n                    yield this.consumer.info();\n                    notFound = 0;\n                    // we exist, so effectively any pending state is gone\n                    // so reset and re-pull\n                    this.pending.msgs = 0;\n                    this.pending.bytes = 0;\n                    this.pending.requests = 0;\n                    this.pull(this.pullOptions());\n                    return true;\n                }\n                catch (err) {\n                    // game over\n                    if (err.message === \"stream not found\") {\n                        streamNotFound++;\n                        this.notify(ConsumerEvents.StreamNotFound, streamNotFound);\n                    }\n                    else if (err.message === \"consumer not found\") {\n                        notFound++;\n                        this.notify(ConsumerEvents.ConsumerNotFound, notFound);\n                        if (this.resetHandler) {\n                            try {\n                                this.resetHandler();\n                            }\n                            catch (_) {\n                                // ignored\n                            }\n                        }\n                        if (this.forOrderedConsumer) {\n                            return false;\n                        }\n                    }\n                    else {\n                        notFound = 0;\n                        streamNotFound = 0;\n                    }\n                    const to = bo.backoff(attempt);\n                    // wait for delay or till the client closes\n                    yield Promise.race([(0, util_1.delay)(to), this.consumer.api.nc.closed()]);\n                    attempt++;\n                }\n            }\n        });\n    }\n    pull(opts) {\n        var _a, _b;\n        this.pending.bytes += (_a = opts.max_bytes) !== null && _a !== void 0 ? _a : 0;\n        this.pending.msgs += (_b = opts.batch) !== null && _b !== void 0 ? _b : 0;\n        this.pending.requests++;\n        const nc = this.consumer.api.nc;\n        //@ts-ignore: iterator will pull\n        this._push(() => {\n            nc.publish(`${this.consumer.api.prefix}.CONSUMER.MSG.NEXT.${this.consumer.stream}.${this.consumer.name}`, this.consumer.api.jc.encode(opts), { reply: this.inbox });\n            this.notify(ConsumerDebugEvents.Next, opts);\n        });\n    }\n    pullOptions() {\n        const batch = this.opts.max_messages - this.pending.msgs;\n        const max_bytes = this.opts.max_bytes - this.pending.bytes;\n        const idle_heartbeat = (0, jsutil_1.nanos)(this.opts.idle_heartbeat);\n        const expires = (0, jsutil_1.nanos)(this.opts.expires);\n        return { batch, max_bytes, idle_heartbeat, expires };\n    }\n    parseDiscard(headers) {\n        const discard = {\n            msgsLeft: 0,\n            bytesLeft: 0,\n        };\n        const msgsLeft = headers === null || headers === void 0 ? void 0 : headers.get(types_1.JsHeaders.PendingMessagesHdr);\n        if (msgsLeft) {\n            discard.msgsLeft = parseInt(msgsLeft);\n        }\n        const bytesLeft = headers === null || headers === void 0 ? void 0 : headers.get(types_1.JsHeaders.PendingBytesHdr);\n        if (bytesLeft) {\n            discard.bytesLeft = parseInt(bytesLeft);\n        }\n        return discard;\n    }\n    trackTimeout(t) {\n        this.timeout = t;\n    }\n    close() {\n        this.stop();\n        return this.iterClosed;\n    }\n    closed() {\n        return this.iterClosed;\n    }\n    clearTimers() {\n        var _a, _b;\n        (_a = this.monitor) === null || _a === void 0 ? void 0 : _a.cancel();\n        this.monitor = null;\n        (_b = this.timeout) === null || _b === void 0 ? void 0 : _b.cancel();\n        this.timeout = null;\n    }\n    setCleanupHandler(fn) {\n        this.cleanupHandler = fn;\n    }\n    stop(err) {\n        var _a, _b;\n        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n        this.clearTimers();\n        (_b = this.statusIterator) === null || _b === void 0 ? void 0 : _b.stop();\n        //@ts-ignore: fn\n        this._push(() => {\n            super.stop(err);\n            this.listeners.forEach((n) => {\n                n.stop();\n            });\n        });\n    }\n    parseOptions(opts, refilling = false) {\n        const args = (opts || {});\n        args.max_messages = args.max_messages || 0;\n        args.max_bytes = args.max_bytes || 0;\n        if (args.max_messages !== 0 && args.max_bytes !== 0) {\n            throw new Error(`only specify one of max_messages or max_bytes`);\n        }\n        // we must have at least one limit - default to 100 msgs\n        // if they gave bytes but no messages, we will clamp\n        // if they gave byte limits, we still need a message limit\n        // or the server will send a single message and close the\n        // request\n        if (args.max_messages === 0) {\n            // FIXME: if the server gives end pull completion, then this is not\n            //   needed - the client will get 1 message but, we'll know that it\n            //   worked - but we'll add a lot of latency, since all requests\n            //   will end after one message\n            args.max_messages = 100;\n        }\n        args.expires = args.expires || 30000;\n        if (args.expires < 1000) {\n            throw new Error(\"expires should be at least 1000ms\");\n        }\n        // require idle_heartbeat\n        args.idle_heartbeat = args.idle_heartbeat || args.expires / 2;\n        args.idle_heartbeat = args.idle_heartbeat > 30000\n            ? 30000\n            : args.idle_heartbeat;\n        if (refilling) {\n            const minMsgs = Math.round(args.max_messages * .75) || 1;\n            args.threshold_messages = args.threshold_messages || minMsgs;\n            const minBytes = Math.round(args.max_bytes * .75) || 1;\n            args.threshold_bytes = args.threshold_bytes || minBytes;\n        }\n        return args;\n    }\n    status() {\n        const iter = new queued_iterator_1.QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return Promise.resolve(iter);\n    }\n}\nexports.PullConsumerMessagesImpl = PullConsumerMessagesImpl;\nclass OrderedConsumerMessages extends queued_iterator_1.QueuedIteratorImpl {\n    constructor() {\n        super();\n        this.listeners = [];\n    }\n    setSource(src) {\n        if (this.src) {\n            this.src.resetHandler = undefined;\n            this.src.setCleanupHandler();\n            this.src.stop();\n        }\n        this.src = src;\n        this.src.setCleanupHandler(() => {\n            this.close().catch();\n        });\n        (() => __awaiter(this, void 0, void 0, function* () {\n            var _a, e_2, _b, _c;\n            const status = yield this.src.status();\n            try {\n                for (var _d = true, status_2 = __asyncValues(status), status_2_1; status_2_1 = yield status_2.next(), _a = status_2_1.done, !_a; _d = true) {\n                    _c = status_2_1.value;\n                    _d = false;\n                    const s = _c;\n                    this.notify(s.type, s.data);\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = status_2.return)) yield _b.call(status_2);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n        }))().catch(() => { });\n    }\n    notify(type, data) {\n        if (this.listeners.length > 0) {\n            (() => {\n                this.listeners.forEach((l) => {\n                    if (!l.done) {\n                        l.push({ type, data });\n                    }\n                });\n            })();\n        }\n    }\n    stop(err) {\n        var _a;\n        (_a = this.src) === null || _a === void 0 ? void 0 : _a.stop(err);\n        super.stop(err);\n        this.listeners.forEach((n) => {\n            n.stop();\n        });\n    }\n    close() {\n        this.stop();\n        return this.iterClosed;\n    }\n    status() {\n        const iter = new queued_iterator_1.QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return Promise.resolve(iter);\n    }\n}\nexports.OrderedConsumerMessages = OrderedConsumerMessages;\nclass PullConsumerImpl {\n    constructor(api, info) {\n        this.api = api;\n        this._info = info;\n        this.stream = info.stream_name;\n        this.name = info.name;\n    }\n    consume(opts = {\n        max_messages: 100,\n        expires: 30000,\n    }) {\n        return Promise.resolve(new PullConsumerMessagesImpl(this, opts, true));\n    }\n    fetch(opts = {\n        max_messages: 100,\n        expires: 30000,\n    }) {\n        const m = new PullConsumerMessagesImpl(this, opts, false);\n        // FIXME: need some way to pad this correctly\n        const to = Math.round(m.opts.expires * 1.05);\n        const timer = (0, util_1.timeout)(to);\n        m.closed().then(() => {\n            timer.cancel();\n        });\n        timer.catch(() => {\n            m.close().catch();\n        });\n        m.trackTimeout(timer);\n        return Promise.resolve(m);\n    }\n    next(opts = { expires: 30000 }) {\n        const d = (0, util_1.deferred)();\n        const fopts = opts;\n        fopts.max_messages = 1;\n        const iter = new PullConsumerMessagesImpl(this, fopts, false);\n        // FIXME: need some way to pad this correctly\n        const to = Math.round(iter.opts.expires * 1.05);\n        // watch the messages for heartbeats missed\n        if (to >= 60000) {\n            (() => __awaiter(this, void 0, void 0, function* () {\n                var _a, e_3, _b, _c;\n                try {\n                    for (var _d = true, _e = __asyncValues(yield iter.status()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                        _c = _f.value;\n                        _d = false;\n                        const s = _c;\n                        if (s.type === ConsumerEvents.HeartbeatsMissed &&\n                            s.data >= 2) {\n                            d.reject(new Error(\"consumer missed heartbeats\"));\n                            break;\n                        }\n                    }\n                }\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                    }\n                    finally { if (e_3) throw e_3.error; }\n                }\n            }))().catch();\n        }\n        (() => __awaiter(this, void 0, void 0, function* () {\n            var _g, e_4, _h, _j;\n            try {\n                for (var _k = true, iter_1 = __asyncValues(iter), iter_1_1; iter_1_1 = yield iter_1.next(), _g = iter_1_1.done, !_g; _k = true) {\n                    _j = iter_1_1.value;\n                    _k = false;\n                    const m = _j;\n                    d.resolve(m);\n                    break;\n                }\n            }\n            catch (e_4_1) { e_4 = { error: e_4_1 }; }\n            finally {\n                try {\n                    if (!_k && !_g && (_h = iter_1.return)) yield _h.call(iter_1);\n                }\n                finally { if (e_4) throw e_4.error; }\n            }\n        }))().catch();\n        const timer = (0, util_1.timeout)(to);\n        iter.closed().then(() => {\n            d.resolve(null);\n            timer.cancel();\n        }).catch((err) => {\n            d.reject(err);\n        });\n        timer.catch((_err) => {\n            d.resolve(null);\n            iter.close().catch();\n        });\n        iter.trackTimeout(timer);\n        return d;\n    }\n    delete() {\n        const { stream_name, name } = this._info;\n        return this.api.delete(stream_name, name);\n    }\n    info(cached = false) {\n        if (cached) {\n            return Promise.resolve(this._info);\n        }\n        const { stream_name, name } = this._info;\n        return this.api.info(stream_name, name)\n            .then((ci) => {\n            this._info = ci;\n            return this._info;\n        });\n    }\n}\nexports.PullConsumerImpl = PullConsumerImpl;\nclass OrderedPullConsumerImpl {\n    constructor(api, stream, opts = {}) {\n        this.api = api;\n        this.stream = stream;\n        this.cursor = { stream_seq: 1, deliver_seq: 0 };\n        this.namePrefix = nuid_1.nuid.next();\n        this.serial = 0;\n        this.currentConsumer = null;\n        this.userCallback = null;\n        this.iter = null;\n        this.type = PullConsumerType.Unset;\n        this.consumerOpts = opts;\n        // to support a random start sequence we need to update the cursor\n        this.startSeq = this.consumerOpts.opt_start_seq || 0;\n        this.cursor.stream_seq = this.startSeq > 0 ? this.startSeq - 1 : 0;\n    }\n    getConsumerOpts(seq) {\n        // change the serial - invalidating any callback not\n        // matching the serial\n        this.serial++;\n        const name = `${this.namePrefix}_${this.serial}`;\n        seq = seq === 0 ? 1 : seq;\n        const config = {\n            name,\n            deliver_policy: jsapi_types_1.DeliverPolicy.StartSequence,\n            opt_start_seq: seq,\n            ack_policy: jsapi_types_1.AckPolicy.None,\n            inactive_threshold: (0, jsutil_1.nanos)(5 * 60 * 1000),\n            num_replicas: 1,\n        };\n        if (this.consumerOpts.headers_only === true) {\n            config.headers_only = true;\n        }\n        if (Array.isArray(this.consumerOpts.filterSubjects)) {\n            config.filter_subjects = this.consumerOpts.filterSubjects;\n        }\n        if (typeof this.consumerOpts.filterSubjects === \"string\") {\n            config.filter_subject = this.consumerOpts.filterSubjects;\n        }\n        // this is the initial request - tweak some options\n        if (seq === this.startSeq + 1) {\n            config.deliver_policy = this.consumerOpts.deliver_policy ||\n                jsapi_types_1.DeliverPolicy.StartSequence;\n            if (this.consumerOpts.deliver_policy === jsapi_types_1.DeliverPolicy.LastPerSubject ||\n                this.consumerOpts.deliver_policy === jsapi_types_1.DeliverPolicy.New ||\n                this.consumerOpts.deliver_policy === jsapi_types_1.DeliverPolicy.Last) {\n                delete config.opt_start_seq;\n                config.deliver_policy = this.consumerOpts.deliver_policy;\n            }\n            // this requires a filter subject - we only set if they didn't\n            // set anything, and to be pre-2.10 we set it as filter_subject\n            if (config.deliver_policy === jsapi_types_1.DeliverPolicy.LastPerSubject) {\n                if (typeof config.filter_subjects === \"undefined\" &&\n                    typeof config.filter_subject === \"undefined\") {\n                    config.filter_subject = \">\";\n                }\n            }\n            if (this.consumerOpts.opt_start_time) {\n                delete config.opt_start_seq;\n                config.deliver_policy = jsapi_types_1.DeliverPolicy.StartTime;\n                config.opt_start_time = this.consumerOpts.opt_start_time;\n            }\n            if (this.consumerOpts.inactive_threshold) {\n                config.inactive_threshold = (0, jsutil_1.nanos)(this.consumerOpts.inactive_threshold);\n            }\n        }\n        return config;\n    }\n    resetConsumer(seq = 0) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            // try to delete the consumer\n            (_a = this.consumer) === null || _a === void 0 ? void 0 : _a.delete().catch(() => { });\n            seq = seq === 0 ? 1 : seq;\n            // reset the consumer sequence as JetStream will renumber from 1\n            this.cursor.deliver_seq = 0;\n            const config = this.getConsumerOpts(seq);\n            config.max_deliver = 1;\n            config.mem_storage = true;\n            const bo = (0, util_1.backoff)();\n            let ci;\n            for (let i = 0;; i++) {\n                try {\n                    ci = yield this.api.add(this.stream, config);\n                    (_b = this.iter) === null || _b === void 0 ? void 0 : _b.notify(ConsumerEvents.OrderedConsumerRecreated, ci.name);\n                    break;\n                }\n                catch (err) {\n                    if (seq === 0 && i >= 30) {\n                        // consumer was never created, so we can fail this\n                        throw err;\n                    }\n                    else {\n                        yield (0, util_1.delay)(bo.backoff(i + 1));\n                    }\n                }\n            }\n            return ci;\n        });\n    }\n    internalHandler(serial) {\n        // this handler will be noop if the consumer's serial changes\n        return (m) => {\n            var _a;\n            if (this.serial !== serial) {\n                return;\n            }\n            const dseq = m.info.deliverySequence;\n            if (dseq !== this.cursor.deliver_seq + 1) {\n                this.reset(this.opts);\n                return;\n            }\n            this.cursor.deliver_seq = dseq;\n            this.cursor.stream_seq = m.info.streamSequence;\n            if (this.userCallback) {\n                this.userCallback(m);\n            }\n            else {\n                (_a = this.iter) === null || _a === void 0 ? void 0 : _a.push(m);\n            }\n        };\n    }\n    reset(opts = {\n        max_messages: 100,\n        expires: 30000,\n    }, fromFetch = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.currentConsumer = yield this.resetConsumer(this.cursor.stream_seq + 1);\n            if (this.iter === null) {\n                this.iter = new OrderedConsumerMessages();\n            }\n            this.consumer = new PullConsumerImpl(this.api, this.currentConsumer);\n            const copts = opts;\n            copts.callback = this.internalHandler(this.serial);\n            let msgs = null;\n            if (this.type === PullConsumerType.Fetch && fromFetch) {\n                // we only repull if client initiates\n                msgs = yield this.consumer.fetch(opts);\n            }\n            else if (this.type === PullConsumerType.Consume) {\n                msgs = yield this.consumer.consume(opts);\n            }\n            else {\n                return Promise.reject(\"reset called with unset consumer type\");\n            }\n            const msgsImpl = msgs;\n            msgsImpl.forOrderedConsumer = true;\n            msgsImpl.resetHandler = () => {\n                this.reset(this.opts);\n            };\n            this.iter.setSource(msgsImpl);\n            return this.iter;\n        });\n    }\n    consume(opts = {\n        max_messages: 100,\n        expires: 30000,\n    }) {\n        if (this.type === PullConsumerType.Fetch) {\n            return Promise.reject(new Error(\"ordered consumer initialized as fetch\"));\n        }\n        if (this.type === PullConsumerType.Consume) {\n            return Promise.reject(new Error(\"ordered consumer doesn't support concurrent consume\"));\n        }\n        const { callback } = opts;\n        if (callback) {\n            this.userCallback = callback;\n        }\n        this.type = PullConsumerType.Consume;\n        this.opts = opts;\n        return this.reset(opts);\n    }\n    fetch(opts = { max_messages: 100, expires: 30000 }) {\n        var _a;\n        if (this.type === PullConsumerType.Consume) {\n            return Promise.reject(new Error(\"ordered consumer already initialized as consume\"));\n        }\n        if (((_a = this.iter) === null || _a === void 0 ? void 0 : _a.done) === false) {\n            return Promise.reject(new Error(\"ordered consumer doesn't support concurrent fetch\"));\n        }\n        //@ts-ignore: allow this for tests - api doesn't use it because\n        // iterator close is the user signal that the pull is done.\n        const { callback } = opts;\n        if (callback) {\n            this.userCallback = callback;\n        }\n        this.type = PullConsumerType.Fetch;\n        this.opts = opts;\n        this.iter = new OrderedConsumerMessages();\n        return this.reset(opts, true);\n    }\n    next(opts = { expires: 30000 }) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const d = (0, util_1.deferred)();\n            const copts = opts;\n            copts.max_messages = 1;\n            copts.callback = (m) => {\n                // we can clobber the callback, because they are not supported\n                // except on consume, which will fail when we try to fetch\n                this.userCallback = null;\n                d.resolve(m);\n            };\n            const iter = yield this.fetch(copts);\n            iter.iterClosed\n                .then(() => {\n                d.resolve(null);\n            })\n                .catch((err) => {\n                d.reject(err);\n            });\n            return d;\n        });\n    }\n    delete() {\n        if (!this.currentConsumer) {\n            return Promise.resolve(false);\n        }\n        return this.api.delete(this.stream, this.currentConsumer.name)\n            .then((tf) => {\n            return Promise.resolve(tf);\n        })\n            .catch((err) => {\n            return Promise.reject(err);\n        })\n            .finally(() => {\n            this.currentConsumer = null;\n        });\n    }\n    info(cached) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.currentConsumer == null) {\n                this.currentConsumer = yield this.resetConsumer(this.serial);\n                return Promise.resolve(this.currentConsumer);\n            }\n            if (cached && this.currentConsumer) {\n                return Promise.resolve(this.currentConsumer);\n            }\n            return this.api.info(this.stream, this.currentConsumer.name);\n        });\n    }\n}\nexports.OrderedPullConsumerImpl = OrderedPullConsumerImpl;\n//# sourceMappingURL=consumer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2NvbnN1bWVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELCtCQUErQixHQUFHLHdCQUF3QixHQUFHLCtCQUErQixHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLHNCQUFzQjtBQUN0TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHdGQUEwQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsd0ZBQTBCO0FBQ2pELGlCQUFpQixtQkFBTyxDQUFDLG1FQUFVO0FBQ25DLDBCQUEwQixtQkFBTyxDQUFDLDhHQUFxQztBQUN2RSxlQUFlLG1CQUFPLENBQUMsd0ZBQTBCO0FBQ2pELGdDQUFnQyxtQkFBTyxDQUFDLDBIQUEyQztBQUNuRixnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQyxzQkFBc0IsbUJBQU8sQ0FBQyw2RUFBZTtBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUIsc0JBQXNCLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQ0FBb0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCLDJCQUEyQiwyQkFBMkI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdGQUFnRjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHFCQUFxQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxLQUFLO0FBQ2xGLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLDJFQUEyRSxNQUFNLEVBQUUsWUFBWTtBQUMvRjtBQUNBO0FBQ0EsMkVBQTJFLE1BQU0sRUFBRSxZQUFZO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYSxJQUFJLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLCtEQUErRDtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUIscUJBQXFCLHFCQUFxQixHQUFHLG1CQUFtQix3Q0FBd0MsbUJBQW1CO0FBQzlLO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLCtEQUErRDtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYseUNBQXlDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUseURBQXlEO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCLEdBQUcsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9qZXRzdHJlYW0vY29uc3VtZXIuanM/OWZjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fYXN5bmNWYWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNWYWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3JkZXJlZFB1bGxDb25zdW1lckltcGwgPSBleHBvcnRzLlB1bGxDb25zdW1lckltcGwgPSBleHBvcnRzLk9yZGVyZWRDb25zdW1lck1lc3NhZ2VzID0gZXhwb3J0cy5QdWxsQ29uc3VtZXJNZXNzYWdlc0ltcGwgPSBleHBvcnRzLkNvbnN1bWVyRGVidWdFdmVudHMgPSBleHBvcnRzLkNvbnN1bWVyRXZlbnRzID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCAyMDIyLTIwMjMgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3V0aWxcIik7XG5jb25zdCBudWlkXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9udWlkXCIpO1xuY29uc3QganN1dGlsXzEgPSByZXF1aXJlKFwiLi9qc3V0aWxcIik7XG5jb25zdCBxdWV1ZWRfaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3F1ZXVlZF9pdGVyYXRvclwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L2NvcmVcIik7XG5jb25zdCBpZGxlaGVhcnRiZWF0X21vbml0b3JfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L2lkbGVoZWFydGJlYXRfbW9uaXRvclwiKTtcbmNvbnN0IGpzbXNnXzEgPSByZXF1aXJlKFwiLi9qc21zZ1wiKTtcbmNvbnN0IGpzYXBpX3R5cGVzXzEgPSByZXF1aXJlKFwiLi9qc2FwaV90eXBlc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbnZhciBQdWxsQ29uc3VtZXJUeXBlO1xuKGZ1bmN0aW9uIChQdWxsQ29uc3VtZXJUeXBlKSB7XG4gICAgUHVsbENvbnN1bWVyVHlwZVtQdWxsQ29uc3VtZXJUeXBlW1wiVW5zZXRcIl0gPSAtMV0gPSBcIlVuc2V0XCI7XG4gICAgUHVsbENvbnN1bWVyVHlwZVtQdWxsQ29uc3VtZXJUeXBlW1wiQ29uc3VtZVwiXSA9IDBdID0gXCJDb25zdW1lXCI7XG4gICAgUHVsbENvbnN1bWVyVHlwZVtQdWxsQ29uc3VtZXJUeXBlW1wiRmV0Y2hcIl0gPSAxXSA9IFwiRmV0Y2hcIjtcbn0pKFB1bGxDb25zdW1lclR5cGUgfHwgKFB1bGxDb25zdW1lclR5cGUgPSB7fSkpO1xuLyoqXG4gKiBDb25zdW1lckV2ZW50cyBhcmUgaW5mb3JtYXRpb25hbCBub3RpZmljYXRpb25zIGVtaXR0ZWQgYnkgQ29uc3VtZXJNZXNzYWdlc1xuICogdGhhdCBtYXkgYmUgb2YgaW50ZXJlc3QgdG8gYSBjbGllbnQuXG4gKi9cbnZhciBDb25zdW1lckV2ZW50cztcbihmdW5jdGlvbiAoQ29uc3VtZXJFdmVudHMpIHtcbiAgICAvKipcbiAgICAgKiBOb3RpZmljYXRpb24gdGhhdCBoZWFydGJlYXRzIHdlcmUgbWlzc2VkLiBUaGlzIG5vdGlmaWNhdGlvbiBpcyBpbmZvcm1hdGlvbmFsLlxuICAgICAqIFRoZSBgZGF0YWAgcG9ydGlvbiBvZiB0aGUgc3RhdHVzLCBpcyBhIG51bWJlciBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2YgbWlzc2VkIGhlYXJ0YmVhdHMuXG4gICAgICogTm90ZSB0aGF0IHdoZW4gYSBjbGllbnQgZGlzY29ubmVjdHMsIGhlYXJ0YmVhdCB0cmFja2luZyBpcyBwYXVzZWQgd2hpbGVcbiAgICAgKiB0aGUgY2xpZW50IGlzIGRpc2Nvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBDb25zdW1lckV2ZW50c1tcIkhlYXJ0YmVhdHNNaXNzZWRcIl0gPSBcImhlYXJ0YmVhdHNfbWlzc2VkXCI7XG4gICAgLyoqXG4gICAgICogTm90aWZpY2F0aW9uIHRoYXQgdGhlIGNvbnN1bWVyIHdhcyBub3QgZm91bmQuIENvbnN1bWVycyB0aGF0IHdlcmUgYWNjZXNzaWJsZSBhdFxuICAgICAqIGxlYXN0IG9uY2UsIHdpbGwgYmUgcmV0cmllZCBmb3IgbW9yZSBtZXNzYWdlcyByZWdhcmRsZXNzIG9mIHRoZSBub3QgYmVpbmcgZm91bmRcbiAgICAgKiBvciB0aW1lb3V0cyBldGMuIFRoaXMgbm90aWZpY2F0aW9uIGluY2x1ZGVzIGEgY291bnQgb2YgY29uc2VjdXRpdmUgYXR0ZW1wdHMgdG9cbiAgICAgKiBmaW5kIHRoZSBjb25zdW1lci4gTm90ZSB0aGF0IGlmIHlvdSBnZXQgdGhpcyBub3RpZmljYXRpb24gcG9zc2libHkgeW91ciBjb2RlIHNob3VsZFxuICAgICAqIGF0dGVtcHQgdG8gcmVjcmVhdGUgdGhlIGNvbnN1bWVyLiBOb3RlIHRoYXQgdGhpcyBub3RpZmljYXRpb24gaXMgb25seSBpbmZvcm1hdGlvbmFsXG4gICAgICogZm9yIG9yZGVyZWQgY29uc3VtZXJzLCBhcyB0aGUgY29uc3VtZXIgd2lsbCBiZSBjcmVhdGVkIGluIHRob3NlIGNhc2VzIGF1dG9tYXRpY2FsbHkuXG4gICAgICovXG4gICAgQ29uc3VtZXJFdmVudHNbXCJDb25zdW1lck5vdEZvdW5kXCJdID0gXCJjb25zdW1lcl9ub3RfZm91bmRcIjtcbiAgICAvKipcbiAgICAgKiBOb3RpZmljYXRpb24gdGhhdCB0aGUgc3RyZWFtIHdhcyBub3QgZm91bmQuIENvbnN1bWVycyB3ZXJlIGFjY2Vzc2libGUgYXQgbGVhc3Qgb25jZSxcbiAgICAgKiB3aWxsIGJlIHJldHJpZWQgZm9yIG1vcmUgbWVzc2FnZXMgcmVnYXJkbGVzcyBvZiB0aGUgbm90IGJlaW5nIGZvdW5kXG4gICAgICogb3IgdGltZW91dHMgZXRjLiBUaGlzIG5vdGlmaWNhdGlvbiBpbmNsdWRlcyBhIGNvdW50IG9mIGNvbnNlY3V0aXZlIGF0dGVtcHRzIHRvXG4gICAgICogZmluZCB0aGUgY29uc3VtZXIuIE5vdGUgdGhhdCBpZiB5b3UgZ2V0IHRoaXMgbm90aWZpY2F0aW9uIHBvc3NpYmx5IHlvdXIgY29kZSBzaG91bGRcbiAgICAgKiBhdHRlbXB0IHRvIHJlY3JlYXRlIHRoZSBjb25zdW1lci4gTm90ZSB0aGF0IHRoaXMgbm90aWZpY2F0aW9uIGlzIG9ubHkgaW5mb3JtYXRpb25hbFxuICAgICAqIGZvciBvcmRlcmVkIGNvbnN1bWVycywgYXMgdGhlIGNvbnN1bWVyIHdpbGwgYmUgY3JlYXRlZCBpbiB0aG9zZSBjYXNlcyBhdXRvbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIENvbnN1bWVyRXZlbnRzW1wiU3RyZWFtTm90Rm91bmRcIl0gPSBcInN0cmVhbV9ub3RfZm91bmRcIjtcbiAgICAvKlxuICAgICAqIE5vdGlmaWNhdGlvbiB0aGF0IHRoZSBjb25zdW1lciB3YXMgZGVsZXRlZC4gVGhpcyBub3RpZmljYXRpb25cbiAgICAgKiBtZWFucyB0aGUgY29uc3VtZXIgd2lsbCBub3QgZ2V0IG1lc3NhZ2VzIHVubGVzcyBpdCBpcyByZWNyZWF0ZWQuIFRoZSBjbGllbnRcbiAgICAgKiB3aWxsIGNvbnRpbnVlIHRvIGF0dGVtcHQgdG8gcHVsbCBtZXNzYWdlcy4gT3JkZXJlZCBjb25zdW1lciB3aWxsIHJlY3JlYXRlIGl0LlxuICAgICAqL1xuICAgIENvbnN1bWVyRXZlbnRzW1wiQ29uc3VtZXJEZWxldGVkXCJdID0gXCJjb25zdW1lcl9kZWxldGVkXCI7XG4gICAgLyoqXG4gICAgICogVGhpcyBub3RpZmljYXRpb24gaXMgc3BlY2lmaWMgb2Ygb3JkZXJlZCBjb25zdW1lcnMgYW5kIHdpbGwgYmUgbm90aWZpZWQgd2hlbmV2ZXJcbiAgICAgKiB0aGUgY29uc3VtZXIgaXMgcmVjcmVhdGVkLiBUaGUgYXJndW1lbnQgaXMgdGhlIG5hbWUgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgY29uc3VtZXIuXG4gICAgICovXG4gICAgQ29uc3VtZXJFdmVudHNbXCJPcmRlcmVkQ29uc3VtZXJSZWNyZWF0ZWRcIl0gPSBcIm9yZGVyZWRfY29uc3VtZXJfcmVjcmVhdGVkXCI7XG59KShDb25zdW1lckV2ZW50cyB8fCAoZXhwb3J0cy5Db25zdW1lckV2ZW50cyA9IENvbnN1bWVyRXZlbnRzID0ge30pKTtcbi8qKlxuICogVGhlc2UgZXZlbnRzIHJlcHJlc2VudCBpbmZvcm1hdGlvbmFsIG5vdGlmaWNhdGlvbnMgZW1pdHRlZCBieSBDb25zdW1lck1lc3NhZ2VzXG4gKiB0aGF0IGNhbiBiZSBzYWZlbHkgaWdub3JlZCBieSBjbGllbnRzLlxuICovXG52YXIgQ29uc3VtZXJEZWJ1Z0V2ZW50cztcbihmdW5jdGlvbiAoQ29uc3VtZXJEZWJ1Z0V2ZW50cykge1xuICAgIC8qKlxuICAgICAqIERlYnVnRXZlbnRzIGFyZSBlZmZlY3RpdmVseSBzdGF0dXNlcyByZXR1cm5lZCBieSB0aGUgc2VydmVyIHRoYXQgd2VyZSBpZ25vcmVkXG4gICAgICogYnkgdGhlIGNsaWVudC4gVGhlIGBkYXRhYCBwb3J0aW9uIG9mIHRoZVxuICAgICAqIHN0YXR1cyBpcyBqdXN0IGEgc3RyaW5nIGluZGljYXRpbmcgdGhlIGNvZGUvbWVzc2FnZSBvZiB0aGUgc3RhdHVzLlxuICAgICAqL1xuICAgIENvbnN1bWVyRGVidWdFdmVudHNbXCJEZWJ1Z0V2ZW50XCJdID0gXCJkZWJ1Z1wiO1xuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGZvciBtZXNzYWdlcyBjYW4gYmUgdGVybWluYXRlZCBieSB0aGUgc2VydmVyLCB0aGVzZSBub3RpZmljYXRpb25zXG4gICAgICogcHJvdmlkZSBpbmZvcm1hdGlvbiBvbiB0aGUgbnVtYmVyIG9mIG1lc3NhZ2VzIGFuZC9vciBieXRlcyB0aGF0IGNvdWxkbid0XG4gICAgICogYmUgc2F0aXNmaWVkIGJ5IHRoZSBjb25zdW1lciByZXF1ZXN0LiBUaGUgYGRhdGFgIHBvcnRpb24gb2YgdGhlIHN0YXR1cyB3aWxsXG4gICAgICogaGF2ZSB0aGUgZm9ybWF0IG9mIGB7bXNnc0xlZnQ6IG51bWJlciwgYnl0ZXNMZWZ0OiBudW1iZXJ9YC5cbiAgICAgKi9cbiAgICBDb25zdW1lckRlYnVnRXZlbnRzW1wiRGlzY2FyZFwiXSA9IFwiZGlzY2FyZFwiO1xuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIHdoZW5ldmVyIHRoZXJlJ3MgYSByZXF1ZXN0IGZvciBhZGRpdGlvbmFsIG1lc3NhZ2VzIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBUaGlzIG5vdGlmaWNhdGlvbiB0ZWxlZ3JhcGhzIHRoZSByZXF1ZXN0IG9wdGlvbnMsIHdoaWNoIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gICAgICogcmVhZC1vbmx5LiBUaGlzIG5vdGlmaWNhdGlvbiBpcyBvbmx5IHVzZWZ1bCBmb3IgZGVidWdnaW5nLiBEYXRhIGlzIFB1bGxPcHRpb25zLlxuICAgICAqL1xuICAgIENvbnN1bWVyRGVidWdFdmVudHNbXCJOZXh0XCJdID0gXCJuZXh0XCI7XG59KShDb25zdW1lckRlYnVnRXZlbnRzIHx8IChleHBvcnRzLkNvbnN1bWVyRGVidWdFdmVudHMgPSBDb25zdW1lckRlYnVnRXZlbnRzID0ge30pKTtcbmNsYXNzIFB1bGxDb25zdW1lck1lc3NhZ2VzSW1wbCBleHRlbmRzIHF1ZXVlZF9pdGVyYXRvcl8xLlF1ZXVlZEl0ZXJhdG9ySW1wbCB7XG4gICAgLy8gY2FsbGJhY2s6IENvbnN1bWVyQ2FsbGJhY2tGbjtcbiAgICBjb25zdHJ1Y3RvcihjLCBvcHRzLCByZWZpbGxpbmcgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbnN1bWVyID0gYztcbiAgICAgICAgdGhpcy5vcHRzID0gdGhpcy5wYXJzZU9wdGlvbnMob3B0cywgcmVmaWxsaW5nKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IG9wdHMuY2FsbGJhY2sgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5ub0l0ZXJhdG9yID0gdHlwZW9mIHRoaXMuY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgdGhpcy5tb25pdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5wb25nID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nID0geyBtc2dzOiAwLCBieXRlczogMCwgcmVxdWVzdHM6IDAgfTtcbiAgICAgICAgdGhpcy5yZWZpbGxpbmcgPSByZWZpbGxpbmc7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjay5zcGxpdChcIlxcblwiKS5zbGljZSgxKS5qb2luKFwiXFxuXCIpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLmluYm94ID0gKDAsIGNvcmVfMS5jcmVhdGVJbmJveCkoYy5hcGkubmMub3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuZm9yT3JkZXJlZENvbnN1bWVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IHsgbWF4X21lc3NhZ2VzLCBtYXhfYnl0ZXMsIGlkbGVfaGVhcnRiZWF0LCB0aHJlc2hvbGRfYnl0ZXMsIHRocmVzaG9sZF9tZXNzYWdlcywgfSA9IHRoaXMub3B0cztcbiAgICAgICAgLy8gb3JkZXJlZCBjb25zdW1lciByZXF1aXJlcyB0aGUgYWJpbGl0eSB0byByZXNldCB0aGVcbiAgICAgICAgLy8gc291cmNlIHB1bGwgY29uc3VtZXIsIGlmIHByb21pc2UgaXMgcmVnaXN0ZXJlZCBhbmRcbiAgICAgICAgLy8gY2xvc2UgaXMgY2FsbGVkLCB0aGUgcHVsbCBjb25zdW1lciB3aWxsIGVtaXQgYSBjbG9zZVxuICAgICAgICAvLyB3aGljaCB3aWxsIGNsb3NlIHRoZSBvcmRlcmVkIGNvbnN1bWVyLCBieSByZWdpc3RlcmluZ1xuICAgICAgICAvLyB0aGUgY2xvc2Ugd2l0aCBhIGhhbmRsZXIsIHdlIGNhbiByZXBsYWNlIGl0LlxuICAgICAgICB0aGlzLmNsb3NlZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xlYW51cEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFudXBIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGhpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHN1YiB9ID0gdGhpcztcbiAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWIgPSB0aGlzLmNvbnN1bWVyLmFwaS5uYy5zdWJzY3JpYmUodGhpcy5pbmJveCwge1xuICAgICAgICAgICAgY2FsbGJhY2s6IChlcnIsIG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgcG9zc2libHkgb25seSBhIHBlcm1pc3Npb25zIGVycm9yIHdoaWNoIG1lYW5zXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhlIHNlcnZlciByZWplY3RlZCAoZWxpbWluYXRpbmcgdGhlIHN1YilcbiAgICAgICAgICAgICAgICAgICAgLy8gb3IgdGhlIGNsaWVudCBuZXZlciBoYWQgcGVybWlzc2lvbnMgdG8gYmVnaW4gd2l0aFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGlzIGlzIHRlcm1pbmFsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMubW9uaXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndvcmsoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Byb3RvY29sID0gbXNnLnN1YmplY3QgPT09IHRoaXMuaW5ib3g7XG4gICAgICAgICAgICAgICAgaWYgKGlzUHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBqc3V0aWxfMS5pc0hlYXJ0YmVhdE1zZykobXNnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAoX2IgPSBtc2cuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gKChfZCA9IChfYyA9IG1zZy5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b0xvd2VyQ2FzZSgpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ1bmtub3duXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbXNnc0xlZnQsIGJ5dGVzTGVmdCB9ID0gdGhpcy5wYXJzZURpc2NhcmQobXNnLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobXNnc0xlZnQgPiAwIHx8IGJ5dGVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5tc2dzIC09IG1zZ3NMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmJ5dGVzIC09IGJ5dGVzTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5yZXF1ZXN0cy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoQ29uc3VtZXJEZWJ1Z0V2ZW50cy5EaXNjYXJkLCB7IG1zZ3NMZWZ0LCBieXRlc0xlZnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogNDA4IGNhbiBiZSBhIFRpbWVvdXQgb3IgYmFkIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgb3IgaXQgY2FuIGJlIHNlbnQgaWYgYSBub3dhaXQgcmVxdWVzdCB3YXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBzZW50IHdoZW4gb3RoZXIgd2FpdGluZyByZXF1ZXN0cyBhcmUgcGVuZGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIFwiUmVxdWVzdHMgUGVuZGluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogNDAwIGJhZCByZXF1ZXN0IEludmFsaWQgSGVhcnRiZWF0IG9yIFVubWFyc2hhbGxpbmcgRmFpbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICB0aGVzZSBhcmUgcmVhbCBiYWQgdmFsdWVzIC0gc28gdGhpcyBpcyBiYWQgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGZhaWwgb24gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9FcnIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IGNvcmVfMS5OYXRzRXJyb3IoZGVzY3JpcHRpb24sIGAke2NvZGV9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5cXG4ke3RoaXMuc3RhY2t9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGdvdCBhIGJhZCByZXF1ZXN0IC0gbm8gcHJvZ3Jlc3MgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdG9FcnIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmU6IGZuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2RlID09PSA0MDkgJiYgZGVzY3JpcHRpb24gPT09IFwiY29uc3VtZXIgZGVsZXRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoQ29uc3VtZXJFdmVudHMuQ29uc3VtZXJEZWxldGVkLCBgJHtjb2RlfSAke2Rlc2NyaXB0aW9ufWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoQ29uc3VtZXJEZWJ1Z0V2ZW50cy5EZWJ1Z0V2ZW50LCBgJHtjb2RlfSAke2Rlc2NyaXB0aW9ufWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoIHRoZSB1c2VyIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaCgoMCwganNtc2dfMS50b0pzTXNnKShtc2cpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlZCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nLm1zZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZy5tc2dzLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZy5ieXRlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLmJ5dGVzIC09IG1zZy5zaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBwZW5kaW5nIGJ5dGVzL21lc3NhZ2VzIHdlIGFyZSBkb25lIG9yIHN0YXJ2aW5nXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZy5tc2dzID09PSAwICYmIHRoaXMucGVuZGluZy5ieXRlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcucmVxdWVzdHMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZpbGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IHRoaXMgY291bGQgcmVzdWx0IGluICAxLzQgPSAwXG4gICAgICAgICAgICAgICAgICAgIGlmICgobWF4X21lc3NhZ2VzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcubXNncyA8PSB0aHJlc2hvbGRfbWVzc2FnZXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAobWF4X2J5dGVzICYmIHRoaXMucGVuZGluZy5ieXRlcyA8PSB0aHJlc2hvbGRfYnl0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMucHVsbE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IHdlIGFyZSBwdXNoaW5nIHRoZSBwdWxsIGZuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1bGwoYmF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVuZGluZy5yZXF1ZXN0cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlOiB3ZSBhcmUgcHVzaGluZyB0aGUgcHVsbCBmblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWIuY2xvc2VkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gZm9yIG9yZGVyZWQgY29uc3VtZXIgd2UgY2Fubm90IGJyZWFrIHRoZSBpdGVyYXRvclxuICAgICAgICAgICAgaWYgKHRoaXMuc3ViLmRyYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogd2UgYXJlIHB1c2hpbmcgdGhlIHB1bGwgZm5cbiAgICAgICAgICAgICAgICB0aGlzLl9wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaWRsZV9oZWFydGJlYXQpIHtcbiAgICAgICAgICAgIHRoaXMubW9uaXRvciA9IG5ldyBpZGxlaGVhcnRiZWF0X21vbml0b3JfMS5JZGxlSGVhcnRiZWF0TW9uaXRvcihpZGxlX2hlYXJ0YmVhdCwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIHB1bGwgY29uc3VtZXIgLSBtaXNzaW5nIGhlYXJ0YmVhdHMgbWF5IGJlIGNvcnJlY3RlZFxuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBuZXh0IHB1bGwgZXRjIC0gdGhlIG9ubHkgYXNzdW1wdGlvbiBoZXJlIGlzIHdlIHNob3VsZFxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGFuZCBjaGVjayBpZiB0aGUgY29uc3VtZXIgd2FzIGRlbGV0ZWQgZnJvbSB1bmRlciB1c1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5KENvbnN1bWVyRXZlbnRzLkhlYXJ0YmVhdHNNaXNzZWQsIGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRQZW5kaW5nKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSwgeyBtYXhPdXQ6IDIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IGlmIHdlIGRpc2Nvbm5lY3QsIHRoZSBjb25zdW1lciBjb3VsZCBiZSBnb25lXG4gICAgICAgIC8vIG9yIHdlIHdlcmUgc2xvdyBjb25zdW1lcidlZCBieSB0aGUgc2VydmVyXG4gICAgICAgICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICAgICAgdmFyIF9kO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5jb25zdW1lci5hcGkubmMuc3RhdHVzKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0l0ZXJhdG9yID0gc3RhdHVzO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZSA9IHRydWUsIHN0YXR1c18xID0gX19hc3luY1ZhbHVlcyhzdGF0dXMpLCBzdGF0dXNfMV8xOyBzdGF0dXNfMV8xID0geWllbGQgc3RhdHVzXzEubmV4dCgpLCBfYSA9IHN0YXR1c18xXzEuZG9uZSwgIV9hOyBfZSA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBzdGF0dXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocy50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNvcmVfMS5FdmVudHMuRGlzY29ubmVjdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzcGFtIGhiIGVycm9ycyBpZiB3ZSBhcmUgZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZTogb3B0aW9uYWwgY2hhaW5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2QgPSB0aGlzLm1vbml0b3IpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY29yZV8xLkV2ZW50cy5SZWNvbm5lY3Q6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gc29tZSBzYW5pdHkgY2hlY2tzIGFuZCByZXNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoYXQgd29ya3MgcmVzdW1lIHRoZSBtb25pdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldFBlbmRpbmcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbigob2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IG9wdGlvbmFsIGNoYWluaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLm1vbml0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVkIC0gdGhpcyBzaG91bGQgaGF2ZSBmaXJlZCBlbHNld2hlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZSAmJiAhX2EgJiYgKF9iID0gc3RhdHVzXzEucmV0dXJuKSkgeWllbGQgX2IuY2FsbChzdGF0dXNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpKCk7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgcHVsbFxuICAgICAgICB0aGlzLnB1bGwodGhpcy5wdWxsT3B0aW9ucygpKTtcbiAgICB9XG4gICAgX3B1c2gocikge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHN1cGVyLnB1c2gocik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmbiA9IHR5cGVvZiByID09PSBcImZ1bmN0aW9uXCIgPyByIDogbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrKHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbm90aWZ5KHR5cGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWwuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbC5wdXNoKHsgdHlwZSwgZGF0YSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldFBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgbm90Rm91bmQgPSAwO1xuICAgICAgICAgICAgbGV0IHN0cmVhbU5vdEZvdW5kID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGJvID0gKDAsIHV0aWxfMS5iYWNrb2ZmKSgpO1xuICAgICAgICAgICAgbGV0IGF0dGVtcHQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lci5hcGkubmMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiYWJvcnRpbmcgcmVzZXRQZW5kaW5nIC0gY29ubmVjdGlvbiBpcyBjbG9zZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgd2UgZXhpc3RcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25zdW1lci5pbmZvKCk7XG4gICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZXhpc3QsIHNvIGVmZmVjdGl2ZWx5IGFueSBwZW5kaW5nIHN0YXRlIGlzIGdvbmVcbiAgICAgICAgICAgICAgICAgICAgLy8gc28gcmVzZXQgYW5kIHJlLXB1bGxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nLm1zZ3MgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcuYnl0ZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmcucmVxdWVzdHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1bGwodGhpcy5wdWxsT3B0aW9ucygpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2FtZSBvdmVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gXCJzdHJlYW0gbm90IGZvdW5kXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbU5vdEZvdW5kKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShDb25zdW1lckV2ZW50cy5TdHJlYW1Ob3RGb3VuZCwgc3RyZWFtTm90Rm91bmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyci5tZXNzYWdlID09PSBcImNvbnN1bWVyIG5vdCBmb3VuZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnkoQ29uc3VtZXJFdmVudHMuQ29uc3VtZXJOb3RGb3VuZCwgbm90Rm91bmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzZXRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNldEhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvck9yZGVyZWRDb25zdW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbU5vdEZvdW5kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0byA9IGJvLmJhY2tvZmYoYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIGRlbGF5IG9yIHRpbGwgdGhlIGNsaWVudCBjbG9zZXNcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5yYWNlKFsoMCwgdXRpbF8xLmRlbGF5KSh0byksIHRoaXMuY29uc3VtZXIuYXBpLm5jLmNsb3NlZCgpXSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwdWxsKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5wZW5kaW5nLmJ5dGVzICs9IChfYSA9IG9wdHMubWF4X2J5dGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICB0aGlzLnBlbmRpbmcubXNncyArPSAoX2IgPSBvcHRzLmJhdGNoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICB0aGlzLnBlbmRpbmcucmVxdWVzdHMrKztcbiAgICAgICAgY29uc3QgbmMgPSB0aGlzLmNvbnN1bWVyLmFwaS5uYztcbiAgICAgICAgLy9AdHMtaWdub3JlOiBpdGVyYXRvciB3aWxsIHB1bGxcbiAgICAgICAgdGhpcy5fcHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBuYy5wdWJsaXNoKGAke3RoaXMuY29uc3VtZXIuYXBpLnByZWZpeH0uQ09OU1VNRVIuTVNHLk5FWFQuJHt0aGlzLmNvbnN1bWVyLnN0cmVhbX0uJHt0aGlzLmNvbnN1bWVyLm5hbWV9YCwgdGhpcy5jb25zdW1lci5hcGkuamMuZW5jb2RlKG9wdHMpLCB7IHJlcGx5OiB0aGlzLmluYm94IH0pO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnkoQ29uc3VtZXJEZWJ1Z0V2ZW50cy5OZXh0LCBvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHB1bGxPcHRpb25zKCkge1xuICAgICAgICBjb25zdCBiYXRjaCA9IHRoaXMub3B0cy5tYXhfbWVzc2FnZXMgLSB0aGlzLnBlbmRpbmcubXNncztcbiAgICAgICAgY29uc3QgbWF4X2J5dGVzID0gdGhpcy5vcHRzLm1heF9ieXRlcyAtIHRoaXMucGVuZGluZy5ieXRlcztcbiAgICAgICAgY29uc3QgaWRsZV9oZWFydGJlYXQgPSAoMCwganN1dGlsXzEubmFub3MpKHRoaXMub3B0cy5pZGxlX2hlYXJ0YmVhdCk7XG4gICAgICAgIGNvbnN0IGV4cGlyZXMgPSAoMCwganN1dGlsXzEubmFub3MpKHRoaXMub3B0cy5leHBpcmVzKTtcbiAgICAgICAgcmV0dXJuIHsgYmF0Y2gsIG1heF9ieXRlcywgaWRsZV9oZWFydGJlYXQsIGV4cGlyZXMgfTtcbiAgICB9XG4gICAgcGFyc2VEaXNjYXJkKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgZGlzY2FyZCA9IHtcbiAgICAgICAgICAgIG1zZ3NMZWZ0OiAwLFxuICAgICAgICAgICAgYnl0ZXNMZWZ0OiAwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtc2dzTGVmdCA9IGhlYWRlcnMgPT09IG51bGwgfHwgaGVhZGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGVhZGVycy5nZXQodHlwZXNfMS5Kc0hlYWRlcnMuUGVuZGluZ01lc3NhZ2VzSGRyKTtcbiAgICAgICAgaWYgKG1zZ3NMZWZ0KSB7XG4gICAgICAgICAgICBkaXNjYXJkLm1zZ3NMZWZ0ID0gcGFyc2VJbnQobXNnc0xlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVzTGVmdCA9IGhlYWRlcnMgPT09IG51bGwgfHwgaGVhZGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGVhZGVycy5nZXQodHlwZXNfMS5Kc0hlYWRlcnMuUGVuZGluZ0J5dGVzSGRyKTtcbiAgICAgICAgaWYgKGJ5dGVzTGVmdCkge1xuICAgICAgICAgICAgZGlzY2FyZC5ieXRlc0xlZnQgPSBwYXJzZUludChieXRlc0xlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaXNjYXJkO1xuICAgIH1cbiAgICB0cmFja1RpbWVvdXQodCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0O1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJDbG9zZWQ7XG4gICAgfVxuICAgIGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlckNsb3NlZDtcbiAgICB9XG4gICAgY2xlYXJUaW1lcnMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIChfYSA9IHRoaXMubW9uaXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLm1vbml0b3IgPSBudWxsO1xuICAgICAgICAoX2IgPSB0aGlzLnRpbWVvdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0Q2xlYW51cEhhbmRsZXIoZm4pIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwSGFuZGxlciA9IGZuO1xuICAgIH1cbiAgICBzdG9wKGVycikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAoX2EgPSB0aGlzLnN1YikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcnMoKTtcbiAgICAgICAgKF9iID0gdGhpcy5zdGF0dXNJdGVyYXRvcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0b3AoKTtcbiAgICAgICAgLy9AdHMtaWdub3JlOiBmblxuICAgICAgICB0aGlzLl9wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIHN1cGVyLnN0b3AoZXJyKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgICAgICAgICBuLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFyc2VPcHRpb25zKG9wdHMsIHJlZmlsbGluZyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSAob3B0cyB8fCB7fSk7XG4gICAgICAgIGFyZ3MubWF4X21lc3NhZ2VzID0gYXJncy5tYXhfbWVzc2FnZXMgfHwgMDtcbiAgICAgICAgYXJncy5tYXhfYnl0ZXMgPSBhcmdzLm1heF9ieXRlcyB8fCAwO1xuICAgICAgICBpZiAoYXJncy5tYXhfbWVzc2FnZXMgIT09IDAgJiYgYXJncy5tYXhfYnl0ZXMgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb25seSBzcGVjaWZ5IG9uZSBvZiBtYXhfbWVzc2FnZXMgb3IgbWF4X2J5dGVzYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBsaW1pdCAtIGRlZmF1bHQgdG8gMTAwIG1zZ3NcbiAgICAgICAgLy8gaWYgdGhleSBnYXZlIGJ5dGVzIGJ1dCBubyBtZXNzYWdlcywgd2Ugd2lsbCBjbGFtcFxuICAgICAgICAvLyBpZiB0aGV5IGdhdmUgYnl0ZSBsaW1pdHMsIHdlIHN0aWxsIG5lZWQgYSBtZXNzYWdlIGxpbWl0XG4gICAgICAgIC8vIG9yIHRoZSBzZXJ2ZXIgd2lsbCBzZW5kIGEgc2luZ2xlIG1lc3NhZ2UgYW5kIGNsb3NlIHRoZVxuICAgICAgICAvLyByZXF1ZXN0XG4gICAgICAgIGlmIChhcmdzLm1heF9tZXNzYWdlcyA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRklYTUU6IGlmIHRoZSBzZXJ2ZXIgZ2l2ZXMgZW5kIHB1bGwgY29tcGxldGlvbiwgdGhlbiB0aGlzIGlzIG5vdFxuICAgICAgICAgICAgLy8gICBuZWVkZWQgLSB0aGUgY2xpZW50IHdpbGwgZ2V0IDEgbWVzc2FnZSBidXQsIHdlJ2xsIGtub3cgdGhhdCBpdFxuICAgICAgICAgICAgLy8gICB3b3JrZWQgLSBidXQgd2UnbGwgYWRkIGEgbG90IG9mIGxhdGVuY3ksIHNpbmNlIGFsbCByZXF1ZXN0c1xuICAgICAgICAgICAgLy8gICB3aWxsIGVuZCBhZnRlciBvbmUgbWVzc2FnZVxuICAgICAgICAgICAgYXJncy5tYXhfbWVzc2FnZXMgPSAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5leHBpcmVzID0gYXJncy5leHBpcmVzIHx8IDMwMDAwO1xuICAgICAgICBpZiAoYXJncy5leHBpcmVzIDwgMTAwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwaXJlcyBzaG91bGQgYmUgYXQgbGVhc3QgMTAwMG1zXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlcXVpcmUgaWRsZV9oZWFydGJlYXRcbiAgICAgICAgYXJncy5pZGxlX2hlYXJ0YmVhdCA9IGFyZ3MuaWRsZV9oZWFydGJlYXQgfHwgYXJncy5leHBpcmVzIC8gMjtcbiAgICAgICAgYXJncy5pZGxlX2hlYXJ0YmVhdCA9IGFyZ3MuaWRsZV9oZWFydGJlYXQgPiAzMDAwMFxuICAgICAgICAgICAgPyAzMDAwMFxuICAgICAgICAgICAgOiBhcmdzLmlkbGVfaGVhcnRiZWF0O1xuICAgICAgICBpZiAocmVmaWxsaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBtaW5Nc2dzID0gTWF0aC5yb3VuZChhcmdzLm1heF9tZXNzYWdlcyAqIC43NSkgfHwgMTtcbiAgICAgICAgICAgIGFyZ3MudGhyZXNob2xkX21lc3NhZ2VzID0gYXJncy50aHJlc2hvbGRfbWVzc2FnZXMgfHwgbWluTXNncztcbiAgICAgICAgICAgIGNvbnN0IG1pbkJ5dGVzID0gTWF0aC5yb3VuZChhcmdzLm1heF9ieXRlcyAqIC43NSkgfHwgMTtcbiAgICAgICAgICAgIGFyZ3MudGhyZXNob2xkX2J5dGVzID0gYXJncy50aHJlc2hvbGRfYnl0ZXMgfHwgbWluQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxuICAgIHN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBxdWV1ZWRfaXRlcmF0b3JfMS5RdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChpdGVyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShpdGVyKTtcbiAgICB9XG59XG5leHBvcnRzLlB1bGxDb25zdW1lck1lc3NhZ2VzSW1wbCA9IFB1bGxDb25zdW1lck1lc3NhZ2VzSW1wbDtcbmNsYXNzIE9yZGVyZWRDb25zdW1lck1lc3NhZ2VzIGV4dGVuZHMgcXVldWVkX2l0ZXJhdG9yXzEuUXVldWVkSXRlcmF0b3JJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgc2V0U291cmNlKHNyYykge1xuICAgICAgICBpZiAodGhpcy5zcmMpIHtcbiAgICAgICAgICAgIHRoaXMuc3JjLnJlc2V0SGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3JjLnNldENsZWFudXBIYW5kbGVyKCk7XG4gICAgICAgICAgICB0aGlzLnNyYy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuc3JjLnNldENsZWFudXBIYW5kbGVyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKS5jYXRjaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSB5aWVsZCB0aGlzLnNyYy5zdGF0dXMoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBzdGF0dXNfMiA9IF9fYXN5bmNWYWx1ZXMoc3RhdHVzKSwgc3RhdHVzXzJfMTsgc3RhdHVzXzJfMSA9IHlpZWxkIHN0YXR1c18yLm5leHQoKSwgX2EgPSBzdGF0dXNfMl8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gc3RhdHVzXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IF9jO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeShzLnR5cGUsIHMuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IHN0YXR1c18yLnJldHVybikpIHlpZWxkIF9iLmNhbGwoc3RhdHVzXzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKSgpLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgfVxuICAgIG5vdGlmeSh0eXBlLCBkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGwucHVzaCh7IHR5cGUsIGRhdGEgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcChlcnIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnNyYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoZXJyKTtcbiAgICAgICAgc3VwZXIuc3RvcChlcnIpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgICAgICBuLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlckNsb3NlZDtcbiAgICB9XG4gICAgc3RhdHVzKCkge1xuICAgICAgICBjb25zdCBpdGVyID0gbmV3IHF1ZXVlZF9pdGVyYXRvcl8xLlF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGl0ZXIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGl0ZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuT3JkZXJlZENvbnN1bWVyTWVzc2FnZXMgPSBPcmRlcmVkQ29uc3VtZXJNZXNzYWdlcztcbmNsYXNzIFB1bGxDb25zdW1lckltcGwge1xuICAgIGNvbnN0cnVjdG9yKGFwaSwgaW5mbykge1xuICAgICAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICAgICAgdGhpcy5faW5mbyA9IGluZm87XG4gICAgICAgIHRoaXMuc3RyZWFtID0gaW5mby5zdHJlYW1fbmFtZTtcbiAgICAgICAgdGhpcy5uYW1lID0gaW5mby5uYW1lO1xuICAgIH1cbiAgICBjb25zdW1lKG9wdHMgPSB7XG4gICAgICAgIG1heF9tZXNzYWdlczogMTAwLFxuICAgICAgICBleHBpcmVzOiAzMDAwMCxcbiAgICB9KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IFB1bGxDb25zdW1lck1lc3NhZ2VzSW1wbCh0aGlzLCBvcHRzLCB0cnVlKSk7XG4gICAgfVxuICAgIGZldGNoKG9wdHMgPSB7XG4gICAgICAgIG1heF9tZXNzYWdlczogMTAwLFxuICAgICAgICBleHBpcmVzOiAzMDAwMCxcbiAgICB9KSB7XG4gICAgICAgIGNvbnN0IG0gPSBuZXcgUHVsbENvbnN1bWVyTWVzc2FnZXNJbXBsKHRoaXMsIG9wdHMsIGZhbHNlKTtcbiAgICAgICAgLy8gRklYTUU6IG5lZWQgc29tZSB3YXkgdG8gcGFkIHRoaXMgY29ycmVjdGx5XG4gICAgICAgIGNvbnN0IHRvID0gTWF0aC5yb3VuZChtLm9wdHMuZXhwaXJlcyAqIDEuMDUpO1xuICAgICAgICBjb25zdCB0aW1lciA9ICgwLCB1dGlsXzEudGltZW91dCkodG8pO1xuICAgICAgICBtLmNsb3NlZCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGltZXIuY2FuY2VsKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aW1lci5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBtLmNsb3NlKCkuY2F0Y2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG0udHJhY2tUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtKTtcbiAgICB9XG4gICAgbmV4dChvcHRzID0geyBleHBpcmVzOiAzMDAwMCB9KSB7XG4gICAgICAgIGNvbnN0IGQgPSAoMCwgdXRpbF8xLmRlZmVycmVkKSgpO1xuICAgICAgICBjb25zdCBmb3B0cyA9IG9wdHM7XG4gICAgICAgIGZvcHRzLm1heF9tZXNzYWdlcyA9IDE7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgUHVsbENvbnN1bWVyTWVzc2FnZXNJbXBsKHRoaXMsIGZvcHRzLCBmYWxzZSk7XG4gICAgICAgIC8vIEZJWE1FOiBuZWVkIHNvbWUgd2F5IHRvIHBhZCB0aGlzIGNvcnJlY3RseVxuICAgICAgICBjb25zdCB0byA9IE1hdGgucm91bmQoaXRlci5vcHRzLmV4cGlyZXMgKiAxLjA1KTtcbiAgICAgICAgLy8gd2F0Y2ggdGhlIG1lc3NhZ2VzIGZvciBoZWFydGJlYXRzIG1pc3NlZFxuICAgICAgICBpZiAodG8gPj0gNjAwMDApIHtcbiAgICAgICAgICAgICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBlXzMsIF9iLCBfYztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIF9lID0gX19hc3luY1ZhbHVlcyh5aWVsZCBpdGVyLnN0YXR1cygpKSwgX2Y7IF9mID0geWllbGQgX2UubmV4dCgpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzLnR5cGUgPT09IENvbnN1bWVyRXZlbnRzLkhlYXJ0YmVhdHNNaXNzZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzLmRhdGEgPj0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQucmVqZWN0KG5ldyBFcnJvcihcImNvbnN1bWVyIG1pc3NlZCBoZWFydGJlYXRzXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSgpLmNhdGNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHZhciBfZywgZV80LCBfaCwgX2o7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9rID0gdHJ1ZSwgaXRlcl8xID0gX19hc3luY1ZhbHVlcyhpdGVyKSwgaXRlcl8xXzE7IGl0ZXJfMV8xID0geWllbGQgaXRlcl8xLm5leHQoKSwgX2cgPSBpdGVyXzFfMS5kb25lLCAhX2c7IF9rID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfaiA9IGl0ZXJfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtID0gX2o7XG4gICAgICAgICAgICAgICAgICAgIGQucmVzb2x2ZShtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2sgJiYgIV9nICYmIChfaCA9IGl0ZXJfMS5yZXR1cm4pKSB5aWVsZCBfaC5jYWxsKGl0ZXJfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpKCkuY2F0Y2goKTtcbiAgICAgICAgY29uc3QgdGltZXIgPSAoMCwgdXRpbF8xLnRpbWVvdXQpKHRvKTtcbiAgICAgICAgaXRlci5jbG9zZWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIHRpbWVyLmNhbmNlbCgpO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGltZXIuY2F0Y2goKF9lcnIpID0+IHtcbiAgICAgICAgICAgIGQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIGl0ZXIuY2xvc2UoKS5jYXRjaCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaXRlci50cmFja1RpbWVvdXQodGltZXIpO1xuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICBjb25zdCB7IHN0cmVhbV9uYW1lLCBuYW1lIH0gPSB0aGlzLl9pbmZvO1xuICAgICAgICByZXR1cm4gdGhpcy5hcGkuZGVsZXRlKHN0cmVhbV9uYW1lLCBuYW1lKTtcbiAgICB9XG4gICAgaW5mbyhjYWNoZWQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2luZm8pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtX25hbWUsIG5hbWUgfSA9IHRoaXMuX2luZm87XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5pbmZvKHN0cmVhbV9uYW1lLCBuYW1lKVxuICAgICAgICAgICAgLnRoZW4oKGNpKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9pbmZvID0gY2k7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5mbztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5QdWxsQ29uc3VtZXJJbXBsID0gUHVsbENvbnN1bWVySW1wbDtcbmNsYXNzIE9yZGVyZWRQdWxsQ29uc3VtZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihhcGksIHN0cmVhbSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuYXBpID0gYXBpO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSB7IHN0cmVhbV9zZXE6IDEsIGRlbGl2ZXJfc2VxOiAwIH07XG4gICAgICAgIHRoaXMubmFtZVByZWZpeCA9IG51aWRfMS5udWlkLm5leHQoKTtcbiAgICAgICAgdGhpcy5zZXJpYWwgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRDb25zdW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMudXNlckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5pdGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy50eXBlID0gUHVsbENvbnN1bWVyVHlwZS5VbnNldDtcbiAgICAgICAgdGhpcy5jb25zdW1lck9wdHMgPSBvcHRzO1xuICAgICAgICAvLyB0byBzdXBwb3J0IGEgcmFuZG9tIHN0YXJ0IHNlcXVlbmNlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBjdXJzb3JcbiAgICAgICAgdGhpcy5zdGFydFNlcSA9IHRoaXMuY29uc3VtZXJPcHRzLm9wdF9zdGFydF9zZXEgfHwgMDtcbiAgICAgICAgdGhpcy5jdXJzb3Iuc3RyZWFtX3NlcSA9IHRoaXMuc3RhcnRTZXEgPiAwID8gdGhpcy5zdGFydFNlcSAtIDEgOiAwO1xuICAgIH1cbiAgICBnZXRDb25zdW1lck9wdHMoc2VxKSB7XG4gICAgICAgIC8vIGNoYW5nZSB0aGUgc2VyaWFsIC0gaW52YWxpZGF0aW5nIGFueSBjYWxsYmFjayBub3RcbiAgICAgICAgLy8gbWF0Y2hpbmcgdGhlIHNlcmlhbFxuICAgICAgICB0aGlzLnNlcmlhbCsrO1xuICAgICAgICBjb25zdCBuYW1lID0gYCR7dGhpcy5uYW1lUHJlZml4fV8ke3RoaXMuc2VyaWFsfWA7XG4gICAgICAgIHNlcSA9IHNlcSA9PT0gMCA/IDEgOiBzZXE7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBkZWxpdmVyX3BvbGljeToganNhcGlfdHlwZXNfMS5EZWxpdmVyUG9saWN5LlN0YXJ0U2VxdWVuY2UsXG4gICAgICAgICAgICBvcHRfc3RhcnRfc2VxOiBzZXEsXG4gICAgICAgICAgICBhY2tfcG9saWN5OiBqc2FwaV90eXBlc18xLkFja1BvbGljeS5Ob25lLFxuICAgICAgICAgICAgaW5hY3RpdmVfdGhyZXNob2xkOiAoMCwganN1dGlsXzEubmFub3MpKDUgKiA2MCAqIDEwMDApLFxuICAgICAgICAgICAgbnVtX3JlcGxpY2FzOiAxLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jb25zdW1lck9wdHMuaGVhZGVyc19vbmx5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25maWcuaGVhZGVyc19vbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbnN1bWVyT3B0cy5maWx0ZXJTdWJqZWN0cykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5maWx0ZXJfc3ViamVjdHMgPSB0aGlzLmNvbnN1bWVyT3B0cy5maWx0ZXJTdWJqZWN0cztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29uc3VtZXJPcHRzLmZpbHRlclN1YmplY3RzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25maWcuZmlsdGVyX3N1YmplY3QgPSB0aGlzLmNvbnN1bWVyT3B0cy5maWx0ZXJTdWJqZWN0cztcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIGlzIHRoZSBpbml0aWFsIHJlcXVlc3QgLSB0d2VhayBzb21lIG9wdGlvbnNcbiAgICAgICAgaWYgKHNlcSA9PT0gdGhpcy5zdGFydFNlcSArIDEpIHtcbiAgICAgICAgICAgIGNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IHRoaXMuY29uc3VtZXJPcHRzLmRlbGl2ZXJfcG9saWN5IHx8XG4gICAgICAgICAgICAgICAganNhcGlfdHlwZXNfMS5EZWxpdmVyUG9saWN5LlN0YXJ0U2VxdWVuY2U7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lck9wdHMuZGVsaXZlcl9wb2xpY3kgPT09IGpzYXBpX3R5cGVzXzEuRGVsaXZlclBvbGljeS5MYXN0UGVyU3ViamVjdCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZXJPcHRzLmRlbGl2ZXJfcG9saWN5ID09PSBqc2FwaV90eXBlc18xLkRlbGl2ZXJQb2xpY3kuTmV3IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lck9wdHMuZGVsaXZlcl9wb2xpY3kgPT09IGpzYXBpX3R5cGVzXzEuRGVsaXZlclBvbGljeS5MYXN0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5vcHRfc3RhcnRfc2VxO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IHRoaXMuY29uc3VtZXJPcHRzLmRlbGl2ZXJfcG9saWN5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyByZXF1aXJlcyBhIGZpbHRlciBzdWJqZWN0IC0gd2Ugb25seSBzZXQgaWYgdGhleSBkaWRuJ3RcbiAgICAgICAgICAgIC8vIHNldCBhbnl0aGluZywgYW5kIHRvIGJlIHByZS0yLjEwIHdlIHNldCBpdCBhcyBmaWx0ZXJfc3ViamVjdFxuICAgICAgICAgICAgaWYgKGNvbmZpZy5kZWxpdmVyX3BvbGljeSA9PT0ganNhcGlfdHlwZXNfMS5EZWxpdmVyUG9saWN5Lkxhc3RQZXJTdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25maWcuZmlsdGVyX3N1YmplY3RzID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBjb25maWcuZmlsdGVyX3N1YmplY3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmZpbHRlcl9zdWJqZWN0ID0gXCI+XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uc3VtZXJPcHRzLm9wdF9zdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5vcHRfc3RhcnRfc2VxO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IGpzYXBpX3R5cGVzXzEuRGVsaXZlclBvbGljeS5TdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgY29uZmlnLm9wdF9zdGFydF90aW1lID0gdGhpcy5jb25zdW1lck9wdHMub3B0X3N0YXJ0X3RpbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25zdW1lck9wdHMuaW5hY3RpdmVfdGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmluYWN0aXZlX3RocmVzaG9sZCA9ICgwLCBqc3V0aWxfMS5uYW5vcykodGhpcy5jb25zdW1lck9wdHMuaW5hY3RpdmVfdGhyZXNob2xkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICByZXNldENvbnN1bWVyKHNlcSA9IDApIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIHRyeSB0byBkZWxldGUgdGhlIGNvbnN1bWVyXG4gICAgICAgICAgICAoX2EgPSB0aGlzLmNvbnN1bWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVsZXRlKCkuY2F0Y2goKCkgPT4geyB9KTtcbiAgICAgICAgICAgIHNlcSA9IHNlcSA9PT0gMCA/IDEgOiBzZXE7XG4gICAgICAgICAgICAvLyByZXNldCB0aGUgY29uc3VtZXIgc2VxdWVuY2UgYXMgSmV0U3RyZWFtIHdpbGwgcmVudW1iZXIgZnJvbSAxXG4gICAgICAgICAgICB0aGlzLmN1cnNvci5kZWxpdmVyX3NlcSA9IDA7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmdldENvbnN1bWVyT3B0cyhzZXEpO1xuICAgICAgICAgICAgY29uZmlnLm1heF9kZWxpdmVyID0gMTtcbiAgICAgICAgICAgIGNvbmZpZy5tZW1fc3RvcmFnZSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBibyA9ICgwLCB1dGlsXzEuYmFja29mZikoKTtcbiAgICAgICAgICAgIGxldCBjaTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2kgPSB5aWVsZCB0aGlzLmFwaS5hZGQodGhpcy5zdHJlYW0sIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMuaXRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5vdGlmeShDb25zdW1lckV2ZW50cy5PcmRlcmVkQ29uc3VtZXJSZWNyZWF0ZWQsIGNpLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VxID09PSAwICYmIGkgPj0gMzApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN1bWVyIHdhcyBuZXZlciBjcmVhdGVkLCBzbyB3ZSBjYW4gZmFpbCB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCAoMCwgdXRpbF8xLmRlbGF5KShiby5iYWNrb2ZmKGkgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2k7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnRlcm5hbEhhbmRsZXIoc2VyaWFsKSB7XG4gICAgICAgIC8vIHRoaXMgaGFuZGxlciB3aWxsIGJlIG5vb3AgaWYgdGhlIGNvbnN1bWVyJ3Mgc2VyaWFsIGNoYW5nZXNcbiAgICAgICAgcmV0dXJuIChtKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXJpYWwgIT09IHNlcmlhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRzZXEgPSBtLmluZm8uZGVsaXZlcnlTZXF1ZW5jZTtcbiAgICAgICAgICAgIGlmIChkc2VxICE9PSB0aGlzLmN1cnNvci5kZWxpdmVyX3NlcSArIDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KHRoaXMub3B0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJzb3IuZGVsaXZlcl9zZXEgPSBkc2VxO1xuICAgICAgICAgICAgdGhpcy5jdXJzb3Iuc3RyZWFtX3NlcSA9IG0uaW5mby5zdHJlYW1TZXF1ZW5jZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZXJDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckNhbGxiYWNrKG0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5pdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaChtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVzZXQob3B0cyA9IHtcbiAgICAgICAgbWF4X21lc3NhZ2VzOiAxMDAsXG4gICAgICAgIGV4cGlyZXM6IDMwMDAwLFxuICAgIH0sIGZyb21GZXRjaCA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDb25zdW1lciA9IHlpZWxkIHRoaXMucmVzZXRDb25zdW1lcih0aGlzLmN1cnNvci5zdHJlYW1fc2VxICsgMSk7XG4gICAgICAgICAgICBpZiAodGhpcy5pdGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVyID0gbmV3IE9yZGVyZWRDb25zdW1lck1lc3NhZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVyID0gbmV3IFB1bGxDb25zdW1lckltcGwodGhpcy5hcGksIHRoaXMuY3VycmVudENvbnN1bWVyKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHRzID0gb3B0cztcbiAgICAgICAgICAgIGNvcHRzLmNhbGxiYWNrID0gdGhpcy5pbnRlcm5hbEhhbmRsZXIodGhpcy5zZXJpYWwpO1xuICAgICAgICAgICAgbGV0IG1zZ3MgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gUHVsbENvbnN1bWVyVHlwZS5GZXRjaCAmJiBmcm9tRmV0Y2gpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBvbmx5IHJlcHVsbCBpZiBjbGllbnQgaW5pdGlhdGVzXG4gICAgICAgICAgICAgICAgbXNncyA9IHlpZWxkIHRoaXMuY29uc3VtZXIuZmV0Y2gob3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09IFB1bGxDb25zdW1lclR5cGUuQ29uc3VtZSkge1xuICAgICAgICAgICAgICAgIG1zZ3MgPSB5aWVsZCB0aGlzLmNvbnN1bWVyLmNvbnN1bWUob3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJyZXNldCBjYWxsZWQgd2l0aCB1bnNldCBjb25zdW1lciB0eXBlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXNnc0ltcGwgPSBtc2dzO1xuICAgICAgICAgICAgbXNnc0ltcGwuZm9yT3JkZXJlZENvbnN1bWVyID0gdHJ1ZTtcbiAgICAgICAgICAgIG1zZ3NJbXBsLnJlc2V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KHRoaXMub3B0cyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5pdGVyLnNldFNvdXJjZShtc2dzSW1wbCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3VtZShvcHRzID0ge1xuICAgICAgICBtYXhfbWVzc2FnZXM6IDEwMCxcbiAgICAgICAgZXhwaXJlczogMzAwMDAsXG4gICAgfSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBQdWxsQ29uc3VtZXJUeXBlLkZldGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwib3JkZXJlZCBjb25zdW1lciBpbml0aWFsaXplZCBhcyBmZXRjaFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gUHVsbENvbnN1bWVyVHlwZS5Db25zdW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwib3JkZXJlZCBjb25zdW1lciBkb2Vzbid0IHN1cHBvcnQgY29uY3VycmVudCBjb25zdW1lXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhbGxiYWNrIH0gPSBvcHRzO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMudXNlckNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlID0gUHVsbENvbnN1bWVyVHlwZS5Db25zdW1lO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNldChvcHRzKTtcbiAgICB9XG4gICAgZmV0Y2gob3B0cyA9IHsgbWF4X21lc3NhZ2VzOiAxMDAsIGV4cGlyZXM6IDMwMDAwIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBQdWxsQ29uc3VtZXJUeXBlLkNvbnN1bWUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvcmRlcmVkIGNvbnN1bWVyIGFscmVhZHkgaW5pdGlhbGl6ZWQgYXMgY29uc3VtZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLml0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kb25lKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvcmRlcmVkIGNvbnN1bWVyIGRvZXNuJ3Qgc3VwcG9ydCBjb25jdXJyZW50IGZldGNoXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvL0B0cy1pZ25vcmU6IGFsbG93IHRoaXMgZm9yIHRlc3RzIC0gYXBpIGRvZXNuJ3QgdXNlIGl0IGJlY2F1c2VcbiAgICAgICAgLy8gaXRlcmF0b3IgY2xvc2UgaXMgdGhlIHVzZXIgc2lnbmFsIHRoYXQgdGhlIHB1bGwgaXMgZG9uZS5cbiAgICAgICAgY29uc3QgeyBjYWxsYmFjayB9ID0gb3B0cztcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZSA9IFB1bGxDb25zdW1lclR5cGUuRmV0Y2g7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuaXRlciA9IG5ldyBPcmRlcmVkQ29uc3VtZXJNZXNzYWdlcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNldChvcHRzLCB0cnVlKTtcbiAgICB9XG4gICAgbmV4dChvcHRzID0geyBleHBpcmVzOiAzMDAwMCB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gKDAsIHV0aWxfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHRzID0gb3B0cztcbiAgICAgICAgICAgIGNvcHRzLm1heF9tZXNzYWdlcyA9IDE7XG4gICAgICAgICAgICBjb3B0cy5jYWxsYmFjayA9IChtKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNsb2JiZXIgdGhlIGNhbGxiYWNrLCBiZWNhdXNlIHRoZXkgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICAvLyBleGNlcHQgb24gY29uc3VtZSwgd2hpY2ggd2lsbCBmYWlsIHdoZW4gd2UgdHJ5IHRvIGZldGNoXG4gICAgICAgICAgICAgICAgdGhpcy51c2VyQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIGQucmVzb2x2ZShtKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBpdGVyID0geWllbGQgdGhpcy5mZXRjaChjb3B0cyk7XG4gICAgICAgICAgICBpdGVyLml0ZXJDbG9zZWRcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgZC5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVsZXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudENvbnN1bWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hcGkuZGVsZXRlKHRoaXMuc3RyZWFtLCB0aGlzLmN1cnJlbnRDb25zdW1lci5uYW1lKVxuICAgICAgICAgICAgLnRoZW4oKHRmKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRmKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnN1bWVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluZm8oY2FjaGVkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Q29uc3VtZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnN1bWVyID0geWllbGQgdGhpcy5yZXNldENvbnN1bWVyKHRoaXMuc2VyaWFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY3VycmVudENvbnN1bWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWNoZWQgJiYgdGhpcy5jdXJyZW50Q29uc3VtZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuY3VycmVudENvbnN1bWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaS5pbmZvKHRoaXMuc3RyZWFtLCB0aGlzLmN1cnJlbnRDb25zdW1lci5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5PcmRlcmVkUHVsbENvbnN1bWVySW1wbCA9IE9yZGVyZWRQdWxsQ29uc3VtZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3VtZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/consumer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/internal_mod.js":
/*!*********************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/internal_mod.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConsumerEvents = exports.ConsumerDebugEvents = exports.StoreCompression = exports.StorageType = exports.RetentionPolicy = exports.ReplayPolicy = exports.DiscardPolicy = exports.DeliverPolicy = exports.AckPolicy = exports.RepublishHeaders = exports.JsHeaders = exports.isConsumerOptsBuilder = exports.DirectMsgHeaders = exports.consumerOpts = exports.AdvisoryKind = exports.nanos = exports.millis = exports.isHeartbeatMsg = exports.isFlowControlMsg = exports.checkJsError = void 0;\n/*\n * Copyright 2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar jsutil_1 = __webpack_require__(/*! ./jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\nObject.defineProperty(exports, \"checkJsError\", ({ enumerable: true, get: function () { return jsutil_1.checkJsError; } }));\nObject.defineProperty(exports, \"isFlowControlMsg\", ({ enumerable: true, get: function () { return jsutil_1.isFlowControlMsg; } }));\nObject.defineProperty(exports, \"isHeartbeatMsg\", ({ enumerable: true, get: function () { return jsutil_1.isHeartbeatMsg; } }));\nObject.defineProperty(exports, \"millis\", ({ enumerable: true, get: function () { return jsutil_1.millis; } }));\nObject.defineProperty(exports, \"nanos\", ({ enumerable: true, get: function () { return jsutil_1.nanos; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/nats/lib/jetstream/types.js\");\nObject.defineProperty(exports, \"AdvisoryKind\", ({ enumerable: true, get: function () { return types_1.AdvisoryKind; } }));\nObject.defineProperty(exports, \"consumerOpts\", ({ enumerable: true, get: function () { return types_1.consumerOpts; } }));\nObject.defineProperty(exports, \"DirectMsgHeaders\", ({ enumerable: true, get: function () { return types_1.DirectMsgHeaders; } }));\nObject.defineProperty(exports, \"isConsumerOptsBuilder\", ({ enumerable: true, get: function () { return types_1.isConsumerOptsBuilder; } }));\nObject.defineProperty(exports, \"JsHeaders\", ({ enumerable: true, get: function () { return types_1.JsHeaders; } }));\nObject.defineProperty(exports, \"RepublishHeaders\", ({ enumerable: true, get: function () { return types_1.RepublishHeaders; } }));\nvar jsapi_types_1 = __webpack_require__(/*! ./jsapi_types */ \"(rsc)/./node_modules/nats/lib/jetstream/jsapi_types.js\");\nObject.defineProperty(exports, \"AckPolicy\", ({ enumerable: true, get: function () { return jsapi_types_1.AckPolicy; } }));\nObject.defineProperty(exports, \"DeliverPolicy\", ({ enumerable: true, get: function () { return jsapi_types_1.DeliverPolicy; } }));\nObject.defineProperty(exports, \"DiscardPolicy\", ({ enumerable: true, get: function () { return jsapi_types_1.DiscardPolicy; } }));\nObject.defineProperty(exports, \"ReplayPolicy\", ({ enumerable: true, get: function () { return jsapi_types_1.ReplayPolicy; } }));\nObject.defineProperty(exports, \"RetentionPolicy\", ({ enumerable: true, get: function () { return jsapi_types_1.RetentionPolicy; } }));\nObject.defineProperty(exports, \"StorageType\", ({ enumerable: true, get: function () { return jsapi_types_1.StorageType; } }));\nObject.defineProperty(exports, \"StoreCompression\", ({ enumerable: true, get: function () { return jsapi_types_1.StoreCompression; } }));\nvar consumer_1 = __webpack_require__(/*! ./consumer */ \"(rsc)/./node_modules/nats/lib/jetstream/consumer.js\");\nObject.defineProperty(exports, \"ConsumerDebugEvents\", ({ enumerable: true, get: function () { return consumer_1.ConsumerDebugEvents; } }));\nObject.defineProperty(exports, \"ConsumerEvents\", ({ enumerable: true, get: function () { return consumer_1.ConsumerEvents; } }));\n//# sourceMappingURL=internal_mod.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2ludGVybmFsX21vZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRywyQkFBMkIsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyx1QkFBdUIsR0FBRyxvQkFBb0IsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRyxpQkFBaUIsR0FBRyw2QkFBNkIsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLG9CQUFvQjtBQUM5ZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLG1FQUFVO0FBQ2pDLGdEQUErQyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN4SCxvREFBbUQsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDaEksa0RBQWlELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzVILDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1Ryx5Q0FBd0MsRUFBRSxxQ0FBcUMsMEJBQTBCLEVBQUM7QUFDMUcsY0FBYyxtQkFBTyxDQUFDLGlFQUFTO0FBQy9CLGdEQUErQyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUN2SCxnREFBK0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdkgsb0RBQW1ELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQy9ILHlEQUF3RCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUN6SSw2Q0FBNEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDakgsb0RBQW1ELEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQy9ILG9CQUFvQixtQkFBTyxDQUFDLDZFQUFlO0FBQzNDLDZDQUE0QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN2SCxpREFBZ0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDL0gsaURBQWdELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQy9ILGdEQUErQyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM3SCxtREFBa0QsRUFBRSxxQ0FBcUMseUNBQXlDLEVBQUM7QUFDbkksK0NBQThDLEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzNILG9EQUFtRCxFQUFFLHFDQUFxQywwQ0FBMEMsRUFBQztBQUNySSxpQkFBaUIsbUJBQU8sQ0FBQyx1RUFBWTtBQUNyQyx1REFBc0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDeEksa0RBQWlELEVBQUUscUNBQXFDLHFDQUFxQyxFQUFDO0FBQzlIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2ludGVybmFsX21vZC5qcz84YWQxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25zdW1lckV2ZW50cyA9IGV4cG9ydHMuQ29uc3VtZXJEZWJ1Z0V2ZW50cyA9IGV4cG9ydHMuU3RvcmVDb21wcmVzc2lvbiA9IGV4cG9ydHMuU3RvcmFnZVR5cGUgPSBleHBvcnRzLlJldGVudGlvblBvbGljeSA9IGV4cG9ydHMuUmVwbGF5UG9saWN5ID0gZXhwb3J0cy5EaXNjYXJkUG9saWN5ID0gZXhwb3J0cy5EZWxpdmVyUG9saWN5ID0gZXhwb3J0cy5BY2tQb2xpY3kgPSBleHBvcnRzLlJlcHVibGlzaEhlYWRlcnMgPSBleHBvcnRzLkpzSGVhZGVycyA9IGV4cG9ydHMuaXNDb25zdW1lck9wdHNCdWlsZGVyID0gZXhwb3J0cy5EaXJlY3RNc2dIZWFkZXJzID0gZXhwb3J0cy5jb25zdW1lck9wdHMgPSBleHBvcnRzLkFkdmlzb3J5S2luZCA9IGV4cG9ydHMubmFub3MgPSBleHBvcnRzLm1pbGxpcyA9IGV4cG9ydHMuaXNIZWFydGJlYXRNc2cgPSBleHBvcnRzLmlzRmxvd0NvbnRyb2xNc2cgPSBleHBvcnRzLmNoZWNrSnNFcnJvciA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIGpzdXRpbF8xID0gcmVxdWlyZShcIi4vanN1dGlsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY2hlY2tKc0Vycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc3V0aWxfMS5jaGVja0pzRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0Zsb3dDb250cm9sTXNnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc3V0aWxfMS5pc0Zsb3dDb250cm9sTXNnOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNIZWFydGJlYXRNc2dcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzdXRpbF8xLmlzSGVhcnRiZWF0TXNnOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWlsbGlzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc3V0aWxfMS5taWxsaXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJuYW5vc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganN1dGlsXzEubmFub3M7IH0gfSk7XG52YXIgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWR2aXNvcnlLaW5kXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18xLkFkdmlzb3J5S2luZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbnN1bWVyT3B0c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMS5jb25zdW1lck9wdHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEaXJlY3RNc2dIZWFkZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18xLkRpcmVjdE1zZ0hlYWRlcnM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0NvbnN1bWVyT3B0c0J1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuaXNDb25zdW1lck9wdHNCdWlsZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSnNIZWFkZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlc18xLkpzSGVhZGVyczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcHVibGlzaEhlYWRlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuUmVwdWJsaXNoSGVhZGVyczsgfSB9KTtcbnZhciBqc2FwaV90eXBlc18xID0gcmVxdWlyZShcIi4vanNhcGlfdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBY2tQb2xpY3lcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzYXBpX3R5cGVzXzEuQWNrUG9saWN5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGVsaXZlclBvbGljeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNhcGlfdHlwZXNfMS5EZWxpdmVyUG9saWN5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlzY2FyZFBvbGljeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNhcGlfdHlwZXNfMS5EaXNjYXJkUG9saWN5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVwbGF5UG9saWN5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBqc2FwaV90eXBlc18xLlJlcGxheVBvbGljeTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJldGVudGlvblBvbGljeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNhcGlfdHlwZXNfMS5SZXRlbnRpb25Qb2xpY3k7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdG9yYWdlVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ganNhcGlfdHlwZXNfMS5TdG9yYWdlVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0b3JlQ29tcHJlc3Npb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGpzYXBpX3R5cGVzXzEuU3RvcmVDb21wcmVzc2lvbjsgfSB9KTtcbnZhciBjb25zdW1lcl8xID0gcmVxdWlyZShcIi4vY29uc3VtZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25zdW1lckRlYnVnRXZlbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdW1lcl8xLkNvbnN1bWVyRGVidWdFdmVudHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25zdW1lckV2ZW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3VtZXJfMS5Db25zdW1lckV2ZW50czsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsX21vZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/internal_mod.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/jsapi_types.js":
/*!********************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/jsapi_types.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultConsumer = exports.ConsumerApiAction = exports.StoreCompression = exports.ReplayPolicy = exports.AckPolicy = exports.DeliverPolicy = exports.StorageType = exports.DiscardPolicy = exports.RetentionPolicy = void 0;\nconst jsutil_1 = __webpack_require__(/*! ./jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\nvar RetentionPolicy;\n(function (RetentionPolicy) {\n    /**\n     * Retain messages until the limits are reached, then trigger the discard policy.\n     */\n    RetentionPolicy[\"Limits\"] = \"limits\";\n    /**\n     * Retain messages while there is consumer interest on the particular subject.\n     */\n    RetentionPolicy[\"Interest\"] = \"interest\";\n    /**\n     * Retain messages until acknowledged\n     */\n    RetentionPolicy[\"Workqueue\"] = \"workqueue\";\n})(RetentionPolicy || (exports.RetentionPolicy = RetentionPolicy = {}));\nvar DiscardPolicy;\n(function (DiscardPolicy) {\n    /**\n     * Discard old messages to make room for the new ones\n     */\n    DiscardPolicy[\"Old\"] = \"old\";\n    /**\n     * Discard the new messages\n     */\n    DiscardPolicy[\"New\"] = \"new\";\n})(DiscardPolicy || (exports.DiscardPolicy = DiscardPolicy = {}));\nvar StorageType;\n(function (StorageType) {\n    /**\n     * Store persistently on files\n     */\n    StorageType[\"File\"] = \"file\";\n    /**\n     * Store in server memory - doesn't survive server restarts\n     */\n    StorageType[\"Memory\"] = \"memory\";\n})(StorageType || (exports.StorageType = StorageType = {}));\nvar DeliverPolicy;\n(function (DeliverPolicy) {\n    /**\n     * Deliver all messages\n     */\n    DeliverPolicy[\"All\"] = \"all\";\n    /**\n     * Deliver starting with the last message\n     */\n    DeliverPolicy[\"Last\"] = \"last\";\n    /**\n     * Deliver starting with new messages\n     */\n    DeliverPolicy[\"New\"] = \"new\";\n    /**\n     * Deliver starting with the specified sequence\n     */\n    DeliverPolicy[\"StartSequence\"] = \"by_start_sequence\";\n    /**\n     * Deliver starting with the specified time\n     */\n    DeliverPolicy[\"StartTime\"] = \"by_start_time\";\n    /**\n     * Deliver starting with the last messages for every subject\n     */\n    DeliverPolicy[\"LastPerSubject\"] = \"last_per_subject\";\n})(DeliverPolicy || (exports.DeliverPolicy = DeliverPolicy = {}));\nvar AckPolicy;\n(function (AckPolicy) {\n    /**\n     * Messages don't need to be Ack'ed.\n     */\n    AckPolicy[\"None\"] = \"none\";\n    /**\n     * Ack, acknowledges all messages with a lower sequence\n     */\n    AckPolicy[\"All\"] = \"all\";\n    /**\n     * All sequences must be explicitly acknowledged\n     */\n    AckPolicy[\"Explicit\"] = \"explicit\";\n    /**\n     * @ignore\n     */\n    AckPolicy[\"NotSet\"] = \"\";\n})(AckPolicy || (exports.AckPolicy = AckPolicy = {}));\nvar ReplayPolicy;\n(function (ReplayPolicy) {\n    /**\n     * Replays messages as fast as possible\n     */\n    ReplayPolicy[\"Instant\"] = \"instant\";\n    /**\n     * Replays messages following the original delay between messages\n     */\n    ReplayPolicy[\"Original\"] = \"original\";\n})(ReplayPolicy || (exports.ReplayPolicy = ReplayPolicy = {}));\nvar StoreCompression;\n(function (StoreCompression) {\n    /**\n     * No compression\n     */\n    StoreCompression[\"None\"] = \"none\";\n    /**\n     * S2 compression\n     */\n    StoreCompression[\"S2\"] = \"s2\";\n})(StoreCompression || (exports.StoreCompression = StoreCompression = {}));\nvar ConsumerApiAction;\n(function (ConsumerApiAction) {\n    ConsumerApiAction[\"CreateOrUpdate\"] = \"\";\n    ConsumerApiAction[\"Update\"] = \"update\";\n    ConsumerApiAction[\"Create\"] = \"create\";\n})(ConsumerApiAction || (exports.ConsumerApiAction = ConsumerApiAction = {}));\nfunction defaultConsumer(name, opts = {}) {\n    return Object.assign({\n        name: name,\n        deliver_policy: DeliverPolicy.All,\n        ack_policy: AckPolicy.Explicit,\n        ack_wait: (0, jsutil_1.nanos)(30 * 1000),\n        replay_policy: ReplayPolicy.Instant,\n    }, opts);\n}\nexports.defaultConsumer = defaultConsumer;\n//# sourceMappingURL=jsapi_types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzYXBpX3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyxtQkFBbUIsR0FBRyxxQkFBcUIsR0FBRyx1QkFBdUI7QUFDek4saUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCLHVCQUF1Qix1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQixxQkFBcUIscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0IsbUJBQW1CLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0IscUJBQXFCLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUIsb0JBQW9CLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUJBQXVCLHdCQUF3Qix3QkFBd0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCLHlCQUF5Qix5QkFBeUI7QUFDM0Usd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL2pldHN0cmVhbS9qc2FwaV90eXBlcy5qcz9kYzUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIzIFRoZSBOQVRTIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHRDb25zdW1lciA9IGV4cG9ydHMuQ29uc3VtZXJBcGlBY3Rpb24gPSBleHBvcnRzLlN0b3JlQ29tcHJlc3Npb24gPSBleHBvcnRzLlJlcGxheVBvbGljeSA9IGV4cG9ydHMuQWNrUG9saWN5ID0gZXhwb3J0cy5EZWxpdmVyUG9saWN5ID0gZXhwb3J0cy5TdG9yYWdlVHlwZSA9IGV4cG9ydHMuRGlzY2FyZFBvbGljeSA9IGV4cG9ydHMuUmV0ZW50aW9uUG9saWN5ID0gdm9pZCAwO1xuY29uc3QganN1dGlsXzEgPSByZXF1aXJlKFwiLi9qc3V0aWxcIik7XG52YXIgUmV0ZW50aW9uUG9saWN5O1xuKGZ1bmN0aW9uIChSZXRlbnRpb25Qb2xpY3kpIHtcbiAgICAvKipcbiAgICAgKiBSZXRhaW4gbWVzc2FnZXMgdW50aWwgdGhlIGxpbWl0cyBhcmUgcmVhY2hlZCwgdGhlbiB0cmlnZ2VyIHRoZSBkaXNjYXJkIHBvbGljeS5cbiAgICAgKi9cbiAgICBSZXRlbnRpb25Qb2xpY3lbXCJMaW1pdHNcIl0gPSBcImxpbWl0c1wiO1xuICAgIC8qKlxuICAgICAqIFJldGFpbiBtZXNzYWdlcyB3aGlsZSB0aGVyZSBpcyBjb25zdW1lciBpbnRlcmVzdCBvbiB0aGUgcGFydGljdWxhciBzdWJqZWN0LlxuICAgICAqL1xuICAgIFJldGVudGlvblBvbGljeVtcIkludGVyZXN0XCJdID0gXCJpbnRlcmVzdFwiO1xuICAgIC8qKlxuICAgICAqIFJldGFpbiBtZXNzYWdlcyB1bnRpbCBhY2tub3dsZWRnZWRcbiAgICAgKi9cbiAgICBSZXRlbnRpb25Qb2xpY3lbXCJXb3JrcXVldWVcIl0gPSBcIndvcmtxdWV1ZVwiO1xufSkoUmV0ZW50aW9uUG9saWN5IHx8IChleHBvcnRzLlJldGVudGlvblBvbGljeSA9IFJldGVudGlvblBvbGljeSA9IHt9KSk7XG52YXIgRGlzY2FyZFBvbGljeTtcbihmdW5jdGlvbiAoRGlzY2FyZFBvbGljeSkge1xuICAgIC8qKlxuICAgICAqIERpc2NhcmQgb2xkIG1lc3NhZ2VzIHRvIG1ha2Ugcm9vbSBmb3IgdGhlIG5ldyBvbmVzXG4gICAgICovXG4gICAgRGlzY2FyZFBvbGljeVtcIk9sZFwiXSA9IFwib2xkXCI7XG4gICAgLyoqXG4gICAgICogRGlzY2FyZCB0aGUgbmV3IG1lc3NhZ2VzXG4gICAgICovXG4gICAgRGlzY2FyZFBvbGljeVtcIk5ld1wiXSA9IFwibmV3XCI7XG59KShEaXNjYXJkUG9saWN5IHx8IChleHBvcnRzLkRpc2NhcmRQb2xpY3kgPSBEaXNjYXJkUG9saWN5ID0ge30pKTtcbnZhciBTdG9yYWdlVHlwZTtcbihmdW5jdGlvbiAoU3RvcmFnZVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBTdG9yZSBwZXJzaXN0ZW50bHkgb24gZmlsZXNcbiAgICAgKi9cbiAgICBTdG9yYWdlVHlwZVtcIkZpbGVcIl0gPSBcImZpbGVcIjtcbiAgICAvKipcbiAgICAgKiBTdG9yZSBpbiBzZXJ2ZXIgbWVtb3J5IC0gZG9lc24ndCBzdXJ2aXZlIHNlcnZlciByZXN0YXJ0c1xuICAgICAqL1xuICAgIFN0b3JhZ2VUeXBlW1wiTWVtb3J5XCJdID0gXCJtZW1vcnlcIjtcbn0pKFN0b3JhZ2VUeXBlIHx8IChleHBvcnRzLlN0b3JhZ2VUeXBlID0gU3RvcmFnZVR5cGUgPSB7fSkpO1xudmFyIERlbGl2ZXJQb2xpY3k7XG4oZnVuY3Rpb24gKERlbGl2ZXJQb2xpY3kpIHtcbiAgICAvKipcbiAgICAgKiBEZWxpdmVyIGFsbCBtZXNzYWdlc1xuICAgICAqL1xuICAgIERlbGl2ZXJQb2xpY3lbXCJBbGxcIl0gPSBcImFsbFwiO1xuICAgIC8qKlxuICAgICAqIERlbGl2ZXIgc3RhcnRpbmcgd2l0aCB0aGUgbGFzdCBtZXNzYWdlXG4gICAgICovXG4gICAgRGVsaXZlclBvbGljeVtcIkxhc3RcIl0gPSBcImxhc3RcIjtcbiAgICAvKipcbiAgICAgKiBEZWxpdmVyIHN0YXJ0aW5nIHdpdGggbmV3IG1lc3NhZ2VzXG4gICAgICovXG4gICAgRGVsaXZlclBvbGljeVtcIk5ld1wiXSA9IFwibmV3XCI7XG4gICAgLyoqXG4gICAgICogRGVsaXZlciBzdGFydGluZyB3aXRoIHRoZSBzcGVjaWZpZWQgc2VxdWVuY2VcbiAgICAgKi9cbiAgICBEZWxpdmVyUG9saWN5W1wiU3RhcnRTZXF1ZW5jZVwiXSA9IFwiYnlfc3RhcnRfc2VxdWVuY2VcIjtcbiAgICAvKipcbiAgICAgKiBEZWxpdmVyIHN0YXJ0aW5nIHdpdGggdGhlIHNwZWNpZmllZCB0aW1lXG4gICAgICovXG4gICAgRGVsaXZlclBvbGljeVtcIlN0YXJ0VGltZVwiXSA9IFwiYnlfc3RhcnRfdGltZVwiO1xuICAgIC8qKlxuICAgICAqIERlbGl2ZXIgc3RhcnRpbmcgd2l0aCB0aGUgbGFzdCBtZXNzYWdlcyBmb3IgZXZlcnkgc3ViamVjdFxuICAgICAqL1xuICAgIERlbGl2ZXJQb2xpY3lbXCJMYXN0UGVyU3ViamVjdFwiXSA9IFwibGFzdF9wZXJfc3ViamVjdFwiO1xufSkoRGVsaXZlclBvbGljeSB8fCAoZXhwb3J0cy5EZWxpdmVyUG9saWN5ID0gRGVsaXZlclBvbGljeSA9IHt9KSk7XG52YXIgQWNrUG9saWN5O1xuKGZ1bmN0aW9uIChBY2tQb2xpY3kpIHtcbiAgICAvKipcbiAgICAgKiBNZXNzYWdlcyBkb24ndCBuZWVkIHRvIGJlIEFjaydlZC5cbiAgICAgKi9cbiAgICBBY2tQb2xpY3lbXCJOb25lXCJdID0gXCJub25lXCI7XG4gICAgLyoqXG4gICAgICogQWNrLCBhY2tub3dsZWRnZXMgYWxsIG1lc3NhZ2VzIHdpdGggYSBsb3dlciBzZXF1ZW5jZVxuICAgICAqL1xuICAgIEFja1BvbGljeVtcIkFsbFwiXSA9IFwiYWxsXCI7XG4gICAgLyoqXG4gICAgICogQWxsIHNlcXVlbmNlcyBtdXN0IGJlIGV4cGxpY2l0bHkgYWNrbm93bGVkZ2VkXG4gICAgICovXG4gICAgQWNrUG9saWN5W1wiRXhwbGljaXRcIl0gPSBcImV4cGxpY2l0XCI7XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIEFja1BvbGljeVtcIk5vdFNldFwiXSA9IFwiXCI7XG59KShBY2tQb2xpY3kgfHwgKGV4cG9ydHMuQWNrUG9saWN5ID0gQWNrUG9saWN5ID0ge30pKTtcbnZhciBSZXBsYXlQb2xpY3k7XG4oZnVuY3Rpb24gKFJlcGxheVBvbGljeSkge1xuICAgIC8qKlxuICAgICAqIFJlcGxheXMgbWVzc2FnZXMgYXMgZmFzdCBhcyBwb3NzaWJsZVxuICAgICAqL1xuICAgIFJlcGxheVBvbGljeVtcIkluc3RhbnRcIl0gPSBcImluc3RhbnRcIjtcbiAgICAvKipcbiAgICAgKiBSZXBsYXlzIG1lc3NhZ2VzIGZvbGxvd2luZyB0aGUgb3JpZ2luYWwgZGVsYXkgYmV0d2VlbiBtZXNzYWdlc1xuICAgICAqL1xuICAgIFJlcGxheVBvbGljeVtcIk9yaWdpbmFsXCJdID0gXCJvcmlnaW5hbFwiO1xufSkoUmVwbGF5UG9saWN5IHx8IChleHBvcnRzLlJlcGxheVBvbGljeSA9IFJlcGxheVBvbGljeSA9IHt9KSk7XG52YXIgU3RvcmVDb21wcmVzc2lvbjtcbihmdW5jdGlvbiAoU3RvcmVDb21wcmVzc2lvbikge1xuICAgIC8qKlxuICAgICAqIE5vIGNvbXByZXNzaW9uXG4gICAgICovXG4gICAgU3RvcmVDb21wcmVzc2lvbltcIk5vbmVcIl0gPSBcIm5vbmVcIjtcbiAgICAvKipcbiAgICAgKiBTMiBjb21wcmVzc2lvblxuICAgICAqL1xuICAgIFN0b3JlQ29tcHJlc3Npb25bXCJTMlwiXSA9IFwiczJcIjtcbn0pKFN0b3JlQ29tcHJlc3Npb24gfHwgKGV4cG9ydHMuU3RvcmVDb21wcmVzc2lvbiA9IFN0b3JlQ29tcHJlc3Npb24gPSB7fSkpO1xudmFyIENvbnN1bWVyQXBpQWN0aW9uO1xuKGZ1bmN0aW9uIChDb25zdW1lckFwaUFjdGlvbikge1xuICAgIENvbnN1bWVyQXBpQWN0aW9uW1wiQ3JlYXRlT3JVcGRhdGVcIl0gPSBcIlwiO1xuICAgIENvbnN1bWVyQXBpQWN0aW9uW1wiVXBkYXRlXCJdID0gXCJ1cGRhdGVcIjtcbiAgICBDb25zdW1lckFwaUFjdGlvbltcIkNyZWF0ZVwiXSA9IFwiY3JlYXRlXCI7XG59KShDb25zdW1lckFwaUFjdGlvbiB8fCAoZXhwb3J0cy5Db25zdW1lckFwaUFjdGlvbiA9IENvbnN1bWVyQXBpQWN0aW9uID0ge30pKTtcbmZ1bmN0aW9uIGRlZmF1bHRDb25zdW1lcihuYW1lLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGRlbGl2ZXJfcG9saWN5OiBEZWxpdmVyUG9saWN5LkFsbCxcbiAgICAgICAgYWNrX3BvbGljeTogQWNrUG9saWN5LkV4cGxpY2l0LFxuICAgICAgICBhY2tfd2FpdDogKDAsIGpzdXRpbF8xLm5hbm9zKSgzMCAqIDEwMDApLFxuICAgICAgICByZXBsYXlfcG9saWN5OiBSZXBsYXlQb2xpY3kuSW5zdGFudCxcbiAgICB9LCBvcHRzKTtcbn1cbmV4cG9ydHMuZGVmYXVsdENvbnN1bWVyID0gZGVmYXVsdENvbnN1bWVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNhcGlfdHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/jsapi_types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/jsbaseclient_api.js":
/*!*************************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/jsbaseclient_api.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2021-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseApiClient = exports.defaultJsOptions = void 0;\nconst encoders_1 = __webpack_require__(/*! ../nats-base-client/encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst codec_1 = __webpack_require__(/*! ../nats-base-client/codec */ \"(rsc)/./node_modules/nats/lib/nats-base-client/codec.js\");\nconst util_1 = __webpack_require__(/*! ../nats-base-client/util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst jsutil_1 = __webpack_require__(/*! ./jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\nconst defaultPrefix = \"$JS.API\";\nconst defaultTimeout = 5000;\nfunction defaultJsOptions(opts) {\n    opts = opts || {};\n    if (opts.domain) {\n        opts.apiPrefix = `$JS.${opts.domain}.API`;\n        delete opts.domain;\n    }\n    return (0, util_1.extend)({ apiPrefix: defaultPrefix, timeout: defaultTimeout }, opts);\n}\nexports.defaultJsOptions = defaultJsOptions;\nclass BaseApiClient {\n    constructor(nc, opts) {\n        this.nc = nc;\n        this.opts = defaultJsOptions(opts);\n        this._parseOpts();\n        this.prefix = this.opts.apiPrefix;\n        this.timeout = this.opts.timeout;\n        this.jc = (0, codec_1.JSONCodec)();\n    }\n    getOptions() {\n        return Object.assign({}, this.opts);\n    }\n    _parseOpts() {\n        let prefix = this.opts.apiPrefix;\n        if (!prefix || prefix.length === 0) {\n            throw new Error(\"invalid empty prefix\");\n        }\n        const c = prefix[prefix.length - 1];\n        if (c === \".\") {\n            prefix = prefix.substr(0, prefix.length - 1);\n        }\n        this.opts.apiPrefix = prefix;\n    }\n    _request(subj, data = null, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            opts = opts || {};\n            opts.timeout = this.timeout;\n            let a = encoders_1.Empty;\n            if (data) {\n                a = this.jc.encode(data);\n            }\n            const m = yield this.nc.request(subj, a, opts);\n            return this.parseJsResponse(m);\n        });\n    }\n    findStream(subject) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const q = { subject };\n            const r = yield this._request(`${this.prefix}.STREAM.NAMES`, q);\n            const names = r;\n            if (!names.streams || names.streams.length !== 1) {\n                throw new Error(\"no stream matches subject\");\n            }\n            return names.streams[0];\n        });\n    }\n    getConnection() {\n        return this.nc;\n    }\n    parseJsResponse(m) {\n        const v = this.jc.decode(m.data);\n        const r = v;\n        if (r.error) {\n            const err = (0, jsutil_1.checkJsErrorCode)(r.error.code, r.error.description);\n            if (err !== null) {\n                err.api_error = r.error;\n                throw err;\n            }\n        }\n        return v;\n    }\n}\nexports.BaseApiClient = BaseApiClient;\n//# sourceMappingURL=jsbaseclient_api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzYmFzZWNsaWVudF9hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyx3QkFBd0I7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQThCO0FBQ3pELGdCQUFnQixtQkFBTyxDQUFDLDBGQUEyQjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsd0ZBQTBCO0FBQ2pELGlCQUFpQixtQkFBTyxDQUFDLG1FQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QztBQUNBO0FBQ0EsZ0NBQWdDLG1EQUFtRDtBQUNuRjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzYmFzZWNsaWVudF9hcGkuanM/MWRjNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBOQVRTIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZUFwaUNsaWVudCA9IGV4cG9ydHMuZGVmYXVsdEpzT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGVuY29kZXJzXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9lbmNvZGVyc1wiKTtcbmNvbnN0IGNvZGVjXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9jb2RlY1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3V0aWxcIik7XG5jb25zdCBqc3V0aWxfMSA9IHJlcXVpcmUoXCIuL2pzdXRpbFwiKTtcbmNvbnN0IGRlZmF1bHRQcmVmaXggPSBcIiRKUy5BUElcIjtcbmNvbnN0IGRlZmF1bHRUaW1lb3V0ID0gNTAwMDtcbmZ1bmN0aW9uIGRlZmF1bHRKc09wdGlvbnMob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIGlmIChvcHRzLmRvbWFpbikge1xuICAgICAgICBvcHRzLmFwaVByZWZpeCA9IGAkSlMuJHtvcHRzLmRvbWFpbn0uQVBJYDtcbiAgICAgICAgZGVsZXRlIG9wdHMuZG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIHV0aWxfMS5leHRlbmQpKHsgYXBpUHJlZml4OiBkZWZhdWx0UHJlZml4LCB0aW1lb3V0OiBkZWZhdWx0VGltZW91dCB9LCBvcHRzKTtcbn1cbmV4cG9ydHMuZGVmYXVsdEpzT3B0aW9ucyA9IGRlZmF1bHRKc09wdGlvbnM7XG5jbGFzcyBCYXNlQXBpQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihuYywgb3B0cykge1xuICAgICAgICB0aGlzLm5jID0gbmM7XG4gICAgICAgIHRoaXMub3B0cyA9IGRlZmF1bHRKc09wdGlvbnMob3B0cyk7XG4gICAgICAgIHRoaXMuX3BhcnNlT3B0cygpO1xuICAgICAgICB0aGlzLnByZWZpeCA9IHRoaXMub3B0cy5hcGlQcmVmaXg7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRoaXMub3B0cy50aW1lb3V0O1xuICAgICAgICB0aGlzLmpjID0gKDAsIGNvZGVjXzEuSlNPTkNvZGVjKSgpO1xuICAgIH1cbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzKTtcbiAgICB9XG4gICAgX3BhcnNlT3B0cygpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IHRoaXMub3B0cy5hcGlQcmVmaXg7XG4gICAgICAgIGlmICghcHJlZml4IHx8IHByZWZpeC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZW1wdHkgcHJlZml4XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXhbcHJlZml4Lmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoYyA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeC5zdWJzdHIoMCwgcHJlZml4Lmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0cy5hcGlQcmVmaXggPSBwcmVmaXg7XG4gICAgfVxuICAgIF9yZXF1ZXN0KHN1YmosIGRhdGEgPSBudWxsLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgIG9wdHMudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgICAgICAgIGxldCBhID0gZW5jb2RlcnNfMS5FbXB0eTtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgYSA9IHRoaXMuamMuZW5jb2RlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbSA9IHlpZWxkIHRoaXMubmMucmVxdWVzdChzdWJqLCBhLCBvcHRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlSnNSZXNwb25zZShtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbmRTdHJlYW0oc3ViamVjdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcSA9IHsgc3ViamVjdCB9O1xuICAgICAgICAgICAgY29uc3QgciA9IHlpZWxkIHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5OQU1FU2AsIHEpO1xuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSByO1xuICAgICAgICAgICAgaWYgKCFuYW1lcy5zdHJlYW1zIHx8IG5hbWVzLnN0cmVhbXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gc3RyZWFtIG1hdGNoZXMgc3ViamVjdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lcy5zdHJlYW1zWzBdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmM7XG4gICAgfVxuICAgIHBhcnNlSnNSZXNwb25zZShtKSB7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLmpjLmRlY29kZShtLmRhdGEpO1xuICAgICAgICBjb25zdCByID0gdjtcbiAgICAgICAgaWYgKHIuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9ICgwLCBqc3V0aWxfMS5jaGVja0pzRXJyb3JDb2RlKShyLmVycm9yLmNvZGUsIHIuZXJyb3IuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgaWYgKGVyciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVyci5hcGlfZXJyb3IgPSByLmVycm9yO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VBcGlDbGllbnQgPSBCYXNlQXBpQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNiYXNlY2xpZW50X2FwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/jsbaseclient_api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/jsclient.js":
/*!*****************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/jsclient.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2022-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JetStreamSubscriptionImpl = exports.JetStreamClientImpl = exports.PubHeaders = void 0;\nconst types_1 = __webpack_require__(/*! ../nats-base-client/types */ \"(rsc)/./node_modules/nats/lib/nats-base-client/types.js\");\nconst jsbaseclient_api_1 = __webpack_require__(/*! ./jsbaseclient_api */ \"(rsc)/./node_modules/nats/lib/jetstream/jsbaseclient_api.js\");\nconst jsutil_1 = __webpack_require__(/*! ./jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\nconst jsmconsumer_api_1 = __webpack_require__(/*! ./jsmconsumer_api */ \"(rsc)/./node_modules/nats/lib/jetstream/jsmconsumer_api.js\");\nconst jsmsg_1 = __webpack_require__(/*! ./jsmsg */ \"(rsc)/./node_modules/nats/lib/jetstream/jsmsg.js\");\nconst typedsub_1 = __webpack_require__(/*! ../nats-base-client/typedsub */ \"(rsc)/./node_modules/nats/lib/nats-base-client/typedsub.js\");\nconst queued_iterator_1 = __webpack_require__(/*! ../nats-base-client/queued_iterator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\");\nconst util_1 = __webpack_require__(/*! ../nats-base-client/util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst headers_1 = __webpack_require__(/*! ../nats-base-client/headers */ \"(rsc)/./node_modules/nats/lib/nats-base-client/headers.js\");\nconst kv_1 = __webpack_require__(/*! ./kv */ \"(rsc)/./node_modules/nats/lib/jetstream/kv.js\");\nconst semver_1 = __webpack_require__(/*! ../nats-base-client/semver */ \"(rsc)/./node_modules/nats/lib/nats-base-client/semver.js\");\nconst objectstore_1 = __webpack_require__(/*! ./objectstore */ \"(rsc)/./node_modules/nats/lib/jetstream/objectstore.js\");\nconst idleheartbeat_monitor_1 = __webpack_require__(/*! ../nats-base-client/idleheartbeat_monitor */ \"(rsc)/./node_modules/nats/lib/nats-base-client/idleheartbeat_monitor.js\");\nconst jsmstream_api_1 = __webpack_require__(/*! ./jsmstream_api */ \"(rsc)/./node_modules/nats/lib/jetstream/jsmstream_api.js\");\nconst types_2 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/nats/lib/jetstream/types.js\");\nconst core_1 = __webpack_require__(/*! ../nats-base-client/core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nconst jsapi_types_1 = __webpack_require__(/*! ./jsapi_types */ \"(rsc)/./node_modules/nats/lib/jetstream/jsapi_types.js\");\nvar PubHeaders;\n(function (PubHeaders) {\n    PubHeaders[\"MsgIdHdr\"] = \"Nats-Msg-Id\";\n    PubHeaders[\"ExpectedStreamHdr\"] = \"Nats-Expected-Stream\";\n    PubHeaders[\"ExpectedLastSeqHdr\"] = \"Nats-Expected-Last-Sequence\";\n    PubHeaders[\"ExpectedLastMsgIdHdr\"] = \"Nats-Expected-Last-Msg-Id\";\n    PubHeaders[\"ExpectedLastSubjectSequenceHdr\"] = \"Nats-Expected-Last-Subject-Sequence\";\n})(PubHeaders || (exports.PubHeaders = PubHeaders = {}));\nclass ViewsImpl {\n    constructor(js) {\n        this.js = js;\n    }\n    kv(name, opts = {}) {\n        const jsi = this.js;\n        const { ok, min } = jsi.nc.features.get(semver_1.Feature.JS_KV);\n        if (!ok) {\n            return Promise.reject(new Error(`kv is only supported on servers ${min} or better`));\n        }\n        if (opts.bindOnly) {\n            return kv_1.Bucket.bind(this.js, name);\n        }\n        return kv_1.Bucket.create(this.js, name, opts);\n    }\n    os(name, opts = {}) {\n        var _a;\n        if (typeof ((_a = crypto === null || crypto === void 0 ? void 0 : crypto.subtle) === null || _a === void 0 ? void 0 : _a.digest) !== \"function\") {\n            return Promise.reject(new Error(\"objectstore: unable to calculate hashes - crypto.subtle.digest with sha256 support is required\"));\n        }\n        const jsi = this.js;\n        const { ok, min } = jsi.nc.features.get(semver_1.Feature.JS_OBJECTSTORE);\n        if (!ok) {\n            return Promise.reject(new Error(`objectstore is only supported on servers ${min} or better`));\n        }\n        return objectstore_1.ObjectStoreImpl.create(this.js, name, opts);\n    }\n}\nclass JetStreamClientImpl extends jsbaseclient_api_1.BaseApiClient {\n    constructor(nc, opts) {\n        super(nc, opts);\n        this.consumerAPI = new jsmconsumer_api_1.ConsumerAPIImpl(nc, opts);\n        this.streamAPI = new jsmstream_api_1.StreamAPIImpl(nc, opts);\n        this.consumers = new jsmstream_api_1.ConsumersImpl(this.consumerAPI);\n        this.streams = new jsmstream_api_1.StreamsImpl(this.streamAPI);\n    }\n    jetstreamManager(checkAPI) {\n        const opts = Object.assign({ checkAPI }, this.opts);\n        return this.nc.jetstreamManager(opts);\n    }\n    get apiPrefix() {\n        return this.prefix;\n    }\n    get views() {\n        return new ViewsImpl(this);\n    }\n    publish(subj, data = types_1.Empty, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            opts = opts || {};\n            opts.expect = opts.expect || {};\n            const mh = (opts === null || opts === void 0 ? void 0 : opts.headers) || (0, headers_1.headers)();\n            if (opts) {\n                if (opts.msgID) {\n                    mh.set(PubHeaders.MsgIdHdr, opts.msgID);\n                }\n                if (opts.expect.lastMsgID) {\n                    mh.set(PubHeaders.ExpectedLastMsgIdHdr, opts.expect.lastMsgID);\n                }\n                if (opts.expect.streamName) {\n                    mh.set(PubHeaders.ExpectedStreamHdr, opts.expect.streamName);\n                }\n                if (typeof opts.expect.lastSequence === \"number\") {\n                    mh.set(PubHeaders.ExpectedLastSeqHdr, `${opts.expect.lastSequence}`);\n                }\n                if (typeof opts.expect.lastSubjectSequence === \"number\") {\n                    mh.set(PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.expect.lastSubjectSequence}`);\n                }\n            }\n            const to = opts.timeout || this.timeout;\n            const ro = {};\n            if (to) {\n                ro.timeout = to;\n            }\n            if (opts) {\n                ro.headers = mh;\n            }\n            let { retries, retry_delay } = opts;\n            retries = retries || 1;\n            retry_delay = retry_delay || 250;\n            let r;\n            for (let i = 0; i < retries; i++) {\n                try {\n                    r = yield this.nc.request(subj, data, ro);\n                    // if here we succeeded\n                    break;\n                }\n                catch (err) {\n                    const ne = err;\n                    if (ne.code === \"503\" && i + 1 < retries) {\n                        yield (0, util_1.delay)(retry_delay);\n                    }\n                    else {\n                        throw err;\n                    }\n                }\n            }\n            const pa = this.parseJsResponse(r);\n            if (pa.stream === \"\") {\n                throw types_1.NatsError.errorForCode(core_1.ErrorCode.JetStreamInvalidAck);\n            }\n            pa.duplicate = pa.duplicate ? pa.duplicate : false;\n            return pa;\n        });\n    }\n    pull(stream, durable, expires = 0) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, jsutil_1.validateStreamName)(stream);\n            (0, jsutil_1.validateDurableName)(durable);\n            let timeout = this.timeout;\n            if (expires > timeout) {\n                timeout = expires;\n            }\n            expires = expires < 0 ? 0 : (0, jsutil_1.nanos)(expires);\n            const pullOpts = {\n                batch: 1,\n                no_wait: expires === 0,\n                expires,\n            };\n            const msg = yield this.nc.request(`${this.prefix}.CONSUMER.MSG.NEXT.${stream}.${durable}`, this.jc.encode(pullOpts), { noMux: true, timeout });\n            const err = (0, jsutil_1.checkJsError)(msg);\n            if (err) {\n                throw err;\n            }\n            return (0, jsmsg_1.toJsMsg)(msg);\n        });\n    }\n    /*\n     * Returns available messages upto specified batch count.\n     * If expires is set the iterator will wait for the specified\n     * amount of millis before closing the subscription.\n     * If no_wait is specified, the iterator will return no messages.\n     * @param stream\n     * @param durable\n     * @param opts\n     */\n    fetch(stream, durable, opts = {}) {\n        var _a;\n        (0, jsutil_1.validateStreamName)(stream);\n        (0, jsutil_1.validateDurableName)(durable);\n        let timer = null;\n        const trackBytes = ((_a = opts.max_bytes) !== null && _a !== void 0 ? _a : 0) > 0;\n        let receivedBytes = 0;\n        const max_bytes = trackBytes ? opts.max_bytes : 0;\n        let monitor = null;\n        const args = {};\n        args.batch = opts.batch || 1;\n        if (max_bytes) {\n            const fv = this.nc.features.get(semver_1.Feature.JS_PULL_MAX_BYTES);\n            if (!fv.ok) {\n                throw new Error(`max_bytes is only supported on servers ${fv.min} or better`);\n            }\n            args.max_bytes = max_bytes;\n        }\n        args.no_wait = opts.no_wait || false;\n        if (args.no_wait && args.expires) {\n            args.expires = 0;\n        }\n        const expires = opts.expires || 0;\n        if (expires) {\n            args.expires = (0, jsutil_1.nanos)(expires);\n        }\n        if (expires === 0 && args.no_wait === false) {\n            throw new Error(\"expires or no_wait is required\");\n        }\n        const hb = opts.idle_heartbeat || 0;\n        if (hb) {\n            args.idle_heartbeat = (0, jsutil_1.nanos)(hb);\n            //@ts-ignore: for testing\n            if (opts.delay_heartbeat === true) {\n                //@ts-ignore: test option\n                args.idle_heartbeat = (0, jsutil_1.nanos)(hb * 4);\n            }\n        }\n        const qi = new queued_iterator_1.QueuedIteratorImpl();\n        const wants = args.batch;\n        let received = 0;\n        qi.protocolFilterFn = (jm, _ingest = false) => {\n            const jsmi = jm;\n            if ((0, jsutil_1.isHeartbeatMsg)(jsmi.msg)) {\n                monitor === null || monitor === void 0 ? void 0 : monitor.work();\n                return false;\n            }\n            return true;\n        };\n        // FIXME: this looks weird, we want to stop the iterator\n        //   but doing it from a dispatchedFn...\n        qi.dispatchedFn = (m) => {\n            if (m) {\n                if (trackBytes) {\n                    receivedBytes += m.data.length;\n                }\n                received++;\n                if (timer && m.info.pending === 0) {\n                    // the expiration will close it\n                    return;\n                }\n                // if we have one pending and we got the expected\n                // or there are no more stop the iterator\n                if (qi.getPending() === 1 && m.info.pending === 0 || wants === received ||\n                    (max_bytes > 0 && receivedBytes >= max_bytes)) {\n                    qi.stop();\n                }\n            }\n        };\n        const inbox = (0, core_1.createInbox)(this.nc.options.inboxPrefix);\n        const sub = this.nc.subscribe(inbox, {\n            max: opts.batch,\n            callback: (err, msg) => {\n                if (err === null) {\n                    err = (0, jsutil_1.checkJsError)(msg);\n                }\n                if (err !== null) {\n                    if (timer) {\n                        timer.cancel();\n                        timer = null;\n                    }\n                    if ((0, core_1.isNatsError)(err)) {\n                        qi.stop(hideNonTerminalJsErrors(err) === null ? undefined : err);\n                    }\n                    else {\n                        qi.stop(err);\n                    }\n                }\n                else {\n                    // if we are doing heartbeats, message resets\n                    monitor === null || monitor === void 0 ? void 0 : monitor.work();\n                    qi.received++;\n                    qi.push((0, jsmsg_1.toJsMsg)(msg));\n                }\n            },\n        });\n        // timer on the client  the issue is that the request\n        // is started on the client, which means that it will expire\n        // on the client first\n        if (expires) {\n            timer = (0, util_1.timeout)(expires);\n            timer.catch(() => {\n                if (!sub.isClosed()) {\n                    sub.drain()\n                        .catch(() => { });\n                    timer = null;\n                }\n                if (monitor) {\n                    monitor.cancel();\n                }\n            });\n        }\n        (() => __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (hb) {\n                    monitor = new idleheartbeat_monitor_1.IdleHeartbeatMonitor(hb, (v) => {\n                        //@ts-ignore: pushing a fn\n                        qi.push(() => {\n                            // this will terminate the iterator\n                            qi.err = new types_1.NatsError(`${jsutil_1.Js409Errors.IdleHeartbeatMissed}: ${v}`, core_1.ErrorCode.JetStreamIdleHeartBeat);\n                        });\n                        return true;\n                    });\n                }\n            }\n            catch (_err) {\n                // ignore it\n            }\n            // close the iterator if the connection or subscription closes unexpectedly\n            yield sub.closed;\n            if (timer !== null) {\n                timer.cancel();\n                timer = null;\n            }\n            if (monitor) {\n                monitor.cancel();\n            }\n            qi.stop();\n        }))().catch();\n        this.nc.publish(`${this.prefix}.CONSUMER.MSG.NEXT.${stream}.${durable}`, this.jc.encode(args), { reply: inbox });\n        return qi;\n    }\n    pullSubscribe(subject, opts = (0, types_2.consumerOpts)()) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cso = yield this._processOptions(subject, opts);\n            if (cso.ordered) {\n                throw new Error(\"pull subscribers cannot be be ordered\");\n            }\n            if (cso.config.deliver_subject) {\n                throw new Error(\"consumer info specifies deliver_subject - pull consumers cannot have deliver_subject set\");\n            }\n            const ackPolicy = cso.config.ack_policy;\n            if (ackPolicy === jsapi_types_1.AckPolicy.None || ackPolicy === jsapi_types_1.AckPolicy.All) {\n                throw new Error(\"ack policy for pull consumers must be explicit\");\n            }\n            const so = this._buildTypedSubscriptionOpts(cso);\n            const sub = new JetStreamPullSubscriptionImpl(this, cso.deliver, so);\n            sub.info = cso;\n            try {\n                yield this._maybeCreateConsumer(cso);\n            }\n            catch (err) {\n                sub.unsubscribe();\n                throw err;\n            }\n            return sub;\n        });\n    }\n    subscribe(subject, opts = (0, types_2.consumerOpts)()) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const cso = yield this._processOptions(subject, opts);\n            // this effectively requires deliver subject to be specified\n            // as an option otherwise we have a pull consumer\n            if (!cso.isBind && !cso.config.deliver_subject) {\n                throw new Error(\"push consumer requires deliver_subject\");\n            }\n            const so = this._buildTypedSubscriptionOpts(cso);\n            const sub = new JetStreamSubscriptionImpl(this, cso.deliver, so);\n            sub.info = cso;\n            try {\n                yield this._maybeCreateConsumer(cso);\n            }\n            catch (err) {\n                sub.unsubscribe();\n                throw err;\n            }\n            sub._maybeSetupHbMonitoring();\n            return sub;\n        });\n    }\n    _processOptions(subject, opts = (0, types_2.consumerOpts)()) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const jsi = ((0, types_2.isConsumerOptsBuilder)(opts)\n                ? opts.getOpts()\n                : opts);\n            jsi.isBind = (0, types_2.isConsumerOptsBuilder)(opts) ? opts.isBind : false;\n            jsi.flow_control = {\n                heartbeat_count: 0,\n                fc_count: 0,\n                consumer_restarts: 0,\n            };\n            if (jsi.ordered) {\n                jsi.ordered_consumer_sequence = { stream_seq: 0, delivery_seq: 0 };\n                if (jsi.config.ack_policy !== jsapi_types_1.AckPolicy.NotSet &&\n                    jsi.config.ack_policy !== jsapi_types_1.AckPolicy.None) {\n                    throw new types_1.NatsError(\"ordered consumer: ack_policy can only be set to 'none'\", core_1.ErrorCode.ApiError);\n                }\n                if (jsi.config.durable_name && jsi.config.durable_name.length > 0) {\n                    throw new types_1.NatsError(\"ordered consumer: durable_name cannot be set\", core_1.ErrorCode.ApiError);\n                }\n                if (jsi.config.deliver_subject && jsi.config.deliver_subject.length > 0) {\n                    throw new types_1.NatsError(\"ordered consumer: deliver_subject cannot be set\", core_1.ErrorCode.ApiError);\n                }\n                if (jsi.config.max_deliver !== undefined && jsi.config.max_deliver > 1) {\n                    throw new types_1.NatsError(\"ordered consumer: max_deliver cannot be set\", core_1.ErrorCode.ApiError);\n                }\n                if (jsi.config.deliver_group && jsi.config.deliver_group.length > 0) {\n                    throw new types_1.NatsError(\"ordered consumer: deliver_group cannot be set\", core_1.ErrorCode.ApiError);\n                }\n                jsi.config.deliver_subject = (0, core_1.createInbox)(this.nc.options.inboxPrefix);\n                jsi.config.ack_policy = jsapi_types_1.AckPolicy.None;\n                jsi.config.max_deliver = 1;\n                jsi.config.flow_control = true;\n                jsi.config.idle_heartbeat = jsi.config.idle_heartbeat || (0, jsutil_1.nanos)(5000);\n                jsi.config.ack_wait = (0, jsutil_1.nanos)(22 * 60 * 60 * 1000);\n                jsi.config.mem_storage = true;\n                jsi.config.num_replicas = 1;\n            }\n            if (jsi.config.ack_policy === jsapi_types_1.AckPolicy.NotSet) {\n                jsi.config.ack_policy = jsapi_types_1.AckPolicy.All;\n            }\n            jsi.api = this;\n            jsi.config = jsi.config || {};\n            jsi.stream = jsi.stream ? jsi.stream : yield this.findStream(subject);\n            jsi.attached = false;\n            if (jsi.config.durable_name) {\n                try {\n                    const info = yield this.consumerAPI.info(jsi.stream, jsi.config.durable_name);\n                    if (info) {\n                        if (info.config.filter_subject && info.config.filter_subject !== subject) {\n                            throw new Error(\"subject does not match consumer\");\n                        }\n                        // check if server returned push_bound, but there's no qn\n                        const qn = (_a = jsi.config.deliver_group) !== null && _a !== void 0 ? _a : \"\";\n                        if (qn === \"\" && info.push_bound === true) {\n                            throw new Error(`duplicate subscription`);\n                        }\n                        const rqn = (_b = info.config.deliver_group) !== null && _b !== void 0 ? _b : \"\";\n                        if (qn !== rqn) {\n                            if (rqn === \"\") {\n                                throw new Error(`durable requires no queue group`);\n                            }\n                            else {\n                                throw new Error(`durable requires queue group '${rqn}'`);\n                            }\n                        }\n                        jsi.last = info;\n                        jsi.config = info.config;\n                        jsi.attached = true;\n                        // if not a durable capture the name of the ephemeral so\n                        // that consumerInfo from the sub will work\n                        if (!jsi.config.durable_name) {\n                            jsi.name = info.name;\n                        }\n                    }\n                }\n                catch (err) {\n                    //consumer doesn't exist\n                    if (err.code !== \"404\") {\n                        throw err;\n                    }\n                }\n            }\n            if (!jsi.attached && jsi.config.filter_subject === undefined &&\n                jsi.config.filter_subjects === undefined) {\n                // if no filter specified, we set the subject as the filter\n                jsi.config.filter_subject = subject;\n            }\n            jsi.deliver = jsi.config.deliver_subject ||\n                (0, core_1.createInbox)(this.nc.options.inboxPrefix);\n            return jsi;\n        });\n    }\n    _buildTypedSubscriptionOpts(jsi) {\n        const so = {};\n        so.adapter = msgAdapter(jsi.callbackFn === undefined);\n        so.ingestionFilterFn = JetStreamClientImpl.ingestionFn(jsi.ordered);\n        so.protocolFilterFn = (jm, ingest = false) => {\n            const jsmi = jm;\n            if ((0, jsutil_1.isFlowControlMsg)(jsmi.msg)) {\n                if (!ingest) {\n                    jsmi.msg.respond();\n                }\n                return false;\n            }\n            return true;\n        };\n        if (!jsi.mack && jsi.config.ack_policy !== jsapi_types_1.AckPolicy.None) {\n            so.dispatchedFn = autoAckJsMsg;\n        }\n        if (jsi.callbackFn) {\n            so.callback = jsi.callbackFn;\n        }\n        so.max = jsi.max || 0;\n        so.queue = jsi.queue;\n        return so;\n    }\n    _maybeCreateConsumer(jsi) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (jsi.attached) {\n                return;\n            }\n            if (jsi.isBind) {\n                throw new Error(`unable to bind - durable consumer ${jsi.config.durable_name} doesn't exist in ${jsi.stream}`);\n            }\n            jsi.config = Object.assign({\n                deliver_policy: jsapi_types_1.DeliverPolicy.All,\n                ack_policy: jsapi_types_1.AckPolicy.Explicit,\n                ack_wait: (0, jsutil_1.nanos)(30 * 1000),\n                replay_policy: jsapi_types_1.ReplayPolicy.Instant,\n            }, jsi.config);\n            const ci = yield this.consumerAPI.add(jsi.stream, jsi.config);\n            if (Array.isArray(jsi.config.filter_subjects && !Array.isArray(ci.config.filter_subjects))) {\n                // server didn't honor `filter_subjects`\n                throw new Error(`jetstream server doesn't support consumers with multiple filter subjects`);\n            }\n            jsi.name = ci.name;\n            jsi.config = ci.config;\n            jsi.last = ci;\n        });\n    }\n    static ingestionFn(ordered) {\n        return (jm, ctx) => {\n            var _a;\n            // ctx is expected to be the iterator (the JetstreamSubscriptionImpl)\n            const jsub = ctx;\n            // this shouldn't happen\n            if (!jm)\n                return { ingest: false, protocol: false };\n            const jmi = jm;\n            if (!(0, jsutil_1.checkJsError)(jmi.msg)) {\n                (_a = jsub.monitor) === null || _a === void 0 ? void 0 : _a.work();\n            }\n            if ((0, jsutil_1.isHeartbeatMsg)(jmi.msg)) {\n                const ingest = ordered ? jsub._checkHbOrderConsumer(jmi.msg) : true;\n                if (!ordered) {\n                    jsub.info.flow_control.heartbeat_count++;\n                }\n                return { ingest, protocol: true };\n            }\n            else if ((0, jsutil_1.isFlowControlMsg)(jmi.msg)) {\n                jsub.info.flow_control.fc_count++;\n                return { ingest: true, protocol: true };\n            }\n            const ingest = ordered ? jsub._checkOrderedConsumer(jm) : true;\n            return { ingest, protocol: false };\n        };\n    }\n}\nexports.JetStreamClientImpl = JetStreamClientImpl;\nclass JetStreamSubscriptionImpl extends typedsub_1.TypedSubscription {\n    constructor(js, subject, opts) {\n        super(js.nc, subject, opts);\n        this.js = js;\n        this.monitor = null;\n        this.sub.closed.then(() => {\n            if (this.monitor) {\n                this.monitor.cancel();\n            }\n        });\n    }\n    set info(info) {\n        this.sub.info = info;\n    }\n    get info() {\n        return this.sub.info;\n    }\n    _resetOrderedConsumer(sseq) {\n        if (this.info === null || this.sub.isClosed()) {\n            return;\n        }\n        const newDeliver = (0, core_1.createInbox)(this.js.nc.options.inboxPrefix);\n        const nci = this.js.nc;\n        nci._resub(this.sub, newDeliver);\n        const info = this.info;\n        info.ordered_consumer_sequence.delivery_seq = 0;\n        info.flow_control.heartbeat_count = 0;\n        info.flow_control.fc_count = 0;\n        info.flow_control.consumer_restarts++;\n        info.deliver = newDeliver;\n        info.config.deliver_subject = newDeliver;\n        info.config.deliver_policy = jsapi_types_1.DeliverPolicy.StartSequence;\n        info.config.opt_start_seq = sseq;\n        // put the stream name\n        const req = {};\n        req.stream_name = this.info.stream;\n        req.config = info.config;\n        const subj = `${info.api.prefix}.CONSUMER.CREATE.${info.stream}`;\n        this.js._request(subj, req)\n            .then((v) => {\n            const ci = v;\n            this.info.config = ci.config;\n            this.info.name = ci.name;\n        })\n            .catch((err) => {\n            // to inform the subscription we inject an error this will\n            // be at after the last message if using an iterator.\n            const nerr = new types_1.NatsError(`unable to recreate ordered consumer ${info.stream} at seq ${sseq}`, core_1.ErrorCode.RequestError, err);\n            this.sub.callback(nerr, {});\n        });\n    }\n    // this is called by push subscriptions, to initialize the monitoring\n    // if configured on the consumer\n    _maybeSetupHbMonitoring() {\n        var _a, _b;\n        const ns = ((_b = (_a = this.info) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.idle_heartbeat) || 0;\n        if (ns) {\n            this._setupHbMonitoring((0, jsutil_1.millis)(ns));\n        }\n    }\n    _setupHbMonitoring(millis, cancelAfter = 0) {\n        const opts = { cancelAfter: 0, maxOut: 2 };\n        if (cancelAfter) {\n            opts.cancelAfter = cancelAfter;\n        }\n        const sub = this.sub;\n        const handler = (v) => {\n            var _a, _b, _c;\n            const msg = (0, jsutil_1.newJsErrorMsg)(409, `${jsutil_1.Js409Errors.IdleHeartbeatMissed}: ${v}`, this.sub.subject);\n            const ordered = (_a = this.info) === null || _a === void 0 ? void 0 : _a.ordered;\n            // non-ordered consumers are always notified of the condition\n            // as they need to try and recover\n            if (!ordered) {\n                this.sub.callback(null, msg);\n            }\n            else {\n                if (!this.js.nc.protocol.connected) {\n                    // we are not connected don't do anything\n                    return false;\n                }\n                // reset the consumer\n                const seq = ((_c = (_b = this.info) === null || _b === void 0 ? void 0 : _b.ordered_consumer_sequence) === null || _c === void 0 ? void 0 : _c.stream_seq) || 0;\n                this._resetOrderedConsumer(seq + 1);\n                // if we are ordered, we will reset the consumer and keep\n                // feeding the iterator or callback - we are not stopping\n                return false;\n            }\n            // let the hb monitor know if we are stopping for callbacks\n            // we don't as we deliver the errors via the cb.\n            return !sub.noIterator;\n        };\n        // this only applies for push subscriptions\n        this.monitor = new idleheartbeat_monitor_1.IdleHeartbeatMonitor(millis, handler, opts);\n    }\n    _checkHbOrderConsumer(msg) {\n        const rm = msg.headers.get(types_2.JsHeaders.ConsumerStalledHdr);\n        if (rm !== \"\") {\n            const nci = this.js.nc;\n            nci.publish(rm);\n        }\n        const lastDelivered = parseInt(msg.headers.get(types_2.JsHeaders.LastConsumerSeqHdr), 10);\n        const ordered = this.info.ordered_consumer_sequence;\n        this.info.flow_control.heartbeat_count++;\n        if (lastDelivered !== ordered.delivery_seq) {\n            this._resetOrderedConsumer(ordered.stream_seq + 1);\n        }\n        return false;\n    }\n    _checkOrderedConsumer(jm) {\n        const ordered = this.info.ordered_consumer_sequence;\n        const sseq = jm.info.streamSequence;\n        const dseq = jm.info.deliverySequence;\n        if (dseq != ordered.delivery_seq + 1) {\n            this._resetOrderedConsumer(ordered.stream_seq + 1);\n            return false;\n        }\n        ordered.delivery_seq = dseq;\n        ordered.stream_seq = sseq;\n        return true;\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isClosed()) {\n                yield this.drain();\n            }\n            const jinfo = this.sub.info;\n            const name = jinfo.config.durable_name || jinfo.name;\n            const subj = `${jinfo.api.prefix}.CONSUMER.DELETE.${jinfo.stream}.${name}`;\n            yield jinfo.api._request(subj);\n        });\n    }\n    consumerInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const jinfo = this.sub.info;\n            const name = jinfo.config.durable_name || jinfo.name;\n            const subj = `${jinfo.api.prefix}.CONSUMER.INFO.${jinfo.stream}.${name}`;\n            const ci = yield jinfo.api._request(subj);\n            jinfo.last = ci;\n            return ci;\n        });\n    }\n}\nexports.JetStreamSubscriptionImpl = JetStreamSubscriptionImpl;\nclass JetStreamPullSubscriptionImpl extends JetStreamSubscriptionImpl {\n    constructor(js, subject, opts) {\n        super(js, subject, opts);\n    }\n    pull(opts = { batch: 1 }) {\n        var _a, _b;\n        const { stream, config, name } = this.sub.info;\n        const consumer = (_a = config.durable_name) !== null && _a !== void 0 ? _a : name;\n        const args = {};\n        args.batch = opts.batch || 1;\n        args.no_wait = opts.no_wait || false;\n        if (((_b = opts.max_bytes) !== null && _b !== void 0 ? _b : 0) > 0) {\n            const fv = this.js.nc.features.get(semver_1.Feature.JS_PULL_MAX_BYTES);\n            if (!fv.ok) {\n                throw new Error(`max_bytes is only supported on servers ${fv.min} or better`);\n            }\n            args.max_bytes = opts.max_bytes;\n        }\n        let expires = 0;\n        if (opts.expires && opts.expires > 0) {\n            expires = opts.expires;\n            args.expires = (0, jsutil_1.nanos)(expires);\n        }\n        let hb = 0;\n        if (opts.idle_heartbeat && opts.idle_heartbeat > 0) {\n            hb = opts.idle_heartbeat;\n            args.idle_heartbeat = (0, jsutil_1.nanos)(hb);\n        }\n        if (hb && expires === 0) {\n            throw new Error(\"idle_heartbeat requires expires\");\n        }\n        if (hb > expires) {\n            throw new Error(\"expires must be greater than idle_heartbeat\");\n        }\n        if (this.info) {\n            if (this.monitor) {\n                this.monitor.cancel();\n            }\n            if (expires && hb) {\n                if (!this.monitor) {\n                    this._setupHbMonitoring(hb, expires);\n                }\n                else {\n                    this.monitor._change(hb, expires);\n                }\n            }\n            const api = this.info.api;\n            const subj = `${api.prefix}.CONSUMER.MSG.NEXT.${stream}.${consumer}`;\n            const reply = this.sub.subject;\n            api.nc.publish(subj, api.jc.encode(args), { reply: reply });\n        }\n    }\n}\nfunction msgAdapter(iterator) {\n    if (iterator) {\n        return iterMsgAdapter;\n    }\n    else {\n        return cbMsgAdapter;\n    }\n}\nfunction cbMsgAdapter(err, msg) {\n    if (err) {\n        return [err, null];\n    }\n    err = (0, jsutil_1.checkJsError)(msg);\n    if (err) {\n        return [err, null];\n    }\n    // assuming that the protocolFilterFn is set!\n    return [null, (0, jsmsg_1.toJsMsg)(msg)];\n}\nfunction iterMsgAdapter(err, msg) {\n    if (err) {\n        return [err, null];\n    }\n    // iterator will close if we have an error\n    // check for errors that shouldn't close it\n    const ne = (0, jsutil_1.checkJsError)(msg);\n    if (ne !== null) {\n        return [hideNonTerminalJsErrors(ne), null];\n    }\n    // assuming that the protocolFilterFn is set\n    return [null, (0, jsmsg_1.toJsMsg)(msg)];\n}\nfunction hideNonTerminalJsErrors(ne) {\n    if (ne !== null) {\n        switch (ne.code) {\n            case core_1.ErrorCode.JetStream404NoMessages:\n            case core_1.ErrorCode.JetStream408RequestTimeout:\n                return null;\n            case core_1.ErrorCode.JetStream409:\n                if ((0, jsutil_1.isTerminal409)(ne)) {\n                    return ne;\n                }\n                return null;\n            default:\n                return ne;\n        }\n    }\n    return null;\n}\nfunction autoAckJsMsg(data) {\n    if (data) {\n        data.ack();\n    }\n}\n//# sourceMappingURL=jsclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcsMkJBQTJCLEdBQUcsa0JBQWtCO0FBQ3BGLGdCQUFnQixtQkFBTyxDQUFDLDBGQUEyQjtBQUNuRCwyQkFBMkIsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDdkQsaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkMsMEJBQTBCLG1CQUFPLENBQUMscUZBQW1CO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLGlFQUFTO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLGdHQUE4QjtBQUN6RCwwQkFBMEIsbUJBQU8sQ0FBQyw4R0FBcUM7QUFDdkUsZUFBZSxtQkFBTyxDQUFDLHdGQUEwQjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBNkI7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLDJEQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLDRGQUE0QjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyw2RUFBZTtBQUM3QyxnQ0FBZ0MsbUJBQU8sQ0FBQywwSEFBMkM7QUFDbkYsd0JBQXdCLG1CQUFPLENBQUMsaUZBQWlCO0FBQ2pELGdCQUFnQixtQkFBTyxDQUFDLGlFQUFTO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyx3RkFBMEI7QUFDakQsc0JBQXNCLG1CQUFPLENBQUMsNkVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL2pldHN0cmVhbS9qc2NsaWVudC5qcz83ZDc2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyLTIwMjMgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5KZXRTdHJlYW1TdWJzY3JpcHRpb25JbXBsID0gZXhwb3J0cy5KZXRTdHJlYW1DbGllbnRJbXBsID0gZXhwb3J0cy5QdWJIZWFkZXJzID0gdm9pZCAwO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3R5cGVzXCIpO1xuY29uc3QganNiYXNlY2xpZW50X2FwaV8xID0gcmVxdWlyZShcIi4vanNiYXNlY2xpZW50X2FwaVwiKTtcbmNvbnN0IGpzdXRpbF8xID0gcmVxdWlyZShcIi4vanN1dGlsXCIpO1xuY29uc3QganNtY29uc3VtZXJfYXBpXzEgPSByZXF1aXJlKFwiLi9qc21jb25zdW1lcl9hcGlcIik7XG5jb25zdCBqc21zZ18xID0gcmVxdWlyZShcIi4vanNtc2dcIik7XG5jb25zdCB0eXBlZHN1Yl8xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvdHlwZWRzdWJcIik7XG5jb25zdCBxdWV1ZWRfaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3F1ZXVlZF9pdGVyYXRvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3V0aWxcIik7XG5jb25zdCBoZWFkZXJzXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9oZWFkZXJzXCIpO1xuY29uc3Qga3ZfMSA9IHJlcXVpcmUoXCIuL2t2XCIpO1xuY29uc3Qgc2VtdmVyXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9zZW12ZXJcIik7XG5jb25zdCBvYmplY3RzdG9yZV8xID0gcmVxdWlyZShcIi4vb2JqZWN0c3RvcmVcIik7XG5jb25zdCBpZGxlaGVhcnRiZWF0X21vbml0b3JfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L2lkbGVoZWFydGJlYXRfbW9uaXRvclwiKTtcbmNvbnN0IGpzbXN0cmVhbV9hcGlfMSA9IHJlcXVpcmUoXCIuL2pzbXN0cmVhbV9hcGlcIik7XG5jb25zdCB0eXBlc18yID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9jb3JlXCIpO1xuY29uc3QganNhcGlfdHlwZXNfMSA9IHJlcXVpcmUoXCIuL2pzYXBpX3R5cGVzXCIpO1xudmFyIFB1YkhlYWRlcnM7XG4oZnVuY3Rpb24gKFB1YkhlYWRlcnMpIHtcbiAgICBQdWJIZWFkZXJzW1wiTXNnSWRIZHJcIl0gPSBcIk5hdHMtTXNnLUlkXCI7XG4gICAgUHViSGVhZGVyc1tcIkV4cGVjdGVkU3RyZWFtSGRyXCJdID0gXCJOYXRzLUV4cGVjdGVkLVN0cmVhbVwiO1xuICAgIFB1YkhlYWRlcnNbXCJFeHBlY3RlZExhc3RTZXFIZHJcIl0gPSBcIk5hdHMtRXhwZWN0ZWQtTGFzdC1TZXF1ZW5jZVwiO1xuICAgIFB1YkhlYWRlcnNbXCJFeHBlY3RlZExhc3RNc2dJZEhkclwiXSA9IFwiTmF0cy1FeHBlY3RlZC1MYXN0LU1zZy1JZFwiO1xuICAgIFB1YkhlYWRlcnNbXCJFeHBlY3RlZExhc3RTdWJqZWN0U2VxdWVuY2VIZHJcIl0gPSBcIk5hdHMtRXhwZWN0ZWQtTGFzdC1TdWJqZWN0LVNlcXVlbmNlXCI7XG59KShQdWJIZWFkZXJzIHx8IChleHBvcnRzLlB1YkhlYWRlcnMgPSBQdWJIZWFkZXJzID0ge30pKTtcbmNsYXNzIFZpZXdzSW1wbCB7XG4gICAgY29uc3RydWN0b3IoanMpIHtcbiAgICAgICAgdGhpcy5qcyA9IGpzO1xuICAgIH1cbiAgICBrdihuYW1lLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QganNpID0gdGhpcy5qcztcbiAgICAgICAgY29uc3QgeyBvaywgbWluIH0gPSBqc2kubmMuZmVhdHVyZXMuZ2V0KHNlbXZlcl8xLkZlYXR1cmUuSlNfS1YpO1xuICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBrdiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBzZXJ2ZXJzICR7bWlufSBvciBiZXR0ZXJgKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuYmluZE9ubHkpIHtcbiAgICAgICAgICAgIHJldHVybiBrdl8xLkJ1Y2tldC5iaW5kKHRoaXMuanMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrdl8xLkJ1Y2tldC5jcmVhdGUodGhpcy5qcywgbmFtZSwgb3B0cyk7XG4gICAgfVxuICAgIG9zKG5hbWUsIG9wdHMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2YgKChfYSA9IGNyeXB0byA9PT0gbnVsbCB8fCBjcnlwdG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNyeXB0by5zdWJ0bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaWdlc3QpICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvYmplY3RzdG9yZTogdW5hYmxlIHRvIGNhbGN1bGF0ZSBoYXNoZXMgLSBjcnlwdG8uc3VidGxlLmRpZ2VzdCB3aXRoIHNoYTI1NiBzdXBwb3J0IGlzIHJlcXVpcmVkXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBqc2kgPSB0aGlzLmpzO1xuICAgICAgICBjb25zdCB7IG9rLCBtaW4gfSA9IGpzaS5uYy5mZWF0dXJlcy5nZXQoc2VtdmVyXzEuRmVhdHVyZS5KU19PQkpFQ1RTVE9SRSk7XG4gICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYG9iamVjdHN0b3JlIGlzIG9ubHkgc3VwcG9ydGVkIG9uIHNlcnZlcnMgJHttaW59IG9yIGJldHRlcmApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0c3RvcmVfMS5PYmplY3RTdG9yZUltcGwuY3JlYXRlKHRoaXMuanMsIG5hbWUsIG9wdHMpO1xuICAgIH1cbn1cbmNsYXNzIEpldFN0cmVhbUNsaWVudEltcGwgZXh0ZW5kcyBqc2Jhc2VjbGllbnRfYXBpXzEuQmFzZUFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IobmMsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIobmMsIG9wdHMpO1xuICAgICAgICB0aGlzLmNvbnN1bWVyQVBJID0gbmV3IGpzbWNvbnN1bWVyX2FwaV8xLkNvbnN1bWVyQVBJSW1wbChuYywgb3B0cyk7XG4gICAgICAgIHRoaXMuc3RyZWFtQVBJID0gbmV3IGpzbXN0cmVhbV9hcGlfMS5TdHJlYW1BUElJbXBsKG5jLCBvcHRzKTtcbiAgICAgICAgdGhpcy5jb25zdW1lcnMgPSBuZXcganNtc3RyZWFtX2FwaV8xLkNvbnN1bWVyc0ltcGwodGhpcy5jb25zdW1lckFQSSk7XG4gICAgICAgIHRoaXMuc3RyZWFtcyA9IG5ldyBqc21zdHJlYW1fYXBpXzEuU3RyZWFtc0ltcGwodGhpcy5zdHJlYW1BUEkpO1xuICAgIH1cbiAgICBqZXRzdHJlYW1NYW5hZ2VyKGNoZWNrQVBJKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHsgY2hlY2tBUEkgfSwgdGhpcy5vcHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmMuamV0c3RyZWFtTWFuYWdlcihvcHRzKTtcbiAgICB9XG4gICAgZ2V0IGFwaVByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4O1xuICAgIH1cbiAgICBnZXQgdmlld3MoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVmlld3NJbXBsKHRoaXMpO1xuICAgIH1cbiAgICBwdWJsaXNoKHN1YmosIGRhdGEgPSB0eXBlc18xLkVtcHR5LCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgICAgIG9wdHMuZXhwZWN0ID0gb3B0cy5leHBlY3QgfHwge307XG4gICAgICAgICAgICBjb25zdCBtaCA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuaGVhZGVycykgfHwgKDAsIGhlYWRlcnNfMS5oZWFkZXJzKSgpO1xuICAgICAgICAgICAgaWYgKG9wdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5tc2dJRCkge1xuICAgICAgICAgICAgICAgICAgICBtaC5zZXQoUHViSGVhZGVycy5Nc2dJZEhkciwgb3B0cy5tc2dJRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRzLmV4cGVjdC5sYXN0TXNnSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWguc2V0KFB1YkhlYWRlcnMuRXhwZWN0ZWRMYXN0TXNnSWRIZHIsIG9wdHMuZXhwZWN0Lmxhc3RNc2dJRCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRzLmV4cGVjdC5zdHJlYW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG1oLnNldChQdWJIZWFkZXJzLkV4cGVjdGVkU3RyZWFtSGRyLCBvcHRzLmV4cGVjdC5zdHJlYW1OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRzLmV4cGVjdC5sYXN0U2VxdWVuY2UgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbWguc2V0KFB1YkhlYWRlcnMuRXhwZWN0ZWRMYXN0U2VxSGRyLCBgJHtvcHRzLmV4cGVjdC5sYXN0U2VxdWVuY2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5leHBlY3QubGFzdFN1YmplY3RTZXF1ZW5jZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBtaC5zZXQoUHViSGVhZGVycy5FeHBlY3RlZExhc3RTdWJqZWN0U2VxdWVuY2VIZHIsIGAke29wdHMuZXhwZWN0Lmxhc3RTdWJqZWN0U2VxdWVuY2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG8gPSBvcHRzLnRpbWVvdXQgfHwgdGhpcy50aW1lb3V0O1xuICAgICAgICAgICAgY29uc3Qgcm8gPSB7fTtcbiAgICAgICAgICAgIGlmICh0bykge1xuICAgICAgICAgICAgICAgIHJvLnRpbWVvdXQgPSB0bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICAgICAgcm8uaGVhZGVycyA9IG1oO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHsgcmV0cmllcywgcmV0cnlfZGVsYXkgfSA9IG9wdHM7XG4gICAgICAgICAgICByZXRyaWVzID0gcmV0cmllcyB8fCAxO1xuICAgICAgICAgICAgcmV0cnlfZGVsYXkgPSByZXRyeV9kZWxheSB8fCAyNTA7XG4gICAgICAgICAgICBsZXQgcjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0cmllczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgciA9IHlpZWxkIHRoaXMubmMucmVxdWVzdChzdWJqLCBkYXRhLCBybyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGhlcmUgd2Ugc3VjY2VlZGVkXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmUuY29kZSA9PT0gXCI1MDNcIiAmJiBpICsgMSA8IHJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkICgwLCB1dGlsXzEuZGVsYXkpKHJldHJ5X2RlbGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhID0gdGhpcy5wYXJzZUpzUmVzcG9uc2Uocik7XG4gICAgICAgICAgICBpZiAocGEuc3RyZWFtID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdHlwZXNfMS5OYXRzRXJyb3IuZXJyb3JGb3JDb2RlKGNvcmVfMS5FcnJvckNvZGUuSmV0U3RyZWFtSW52YWxpZEFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYS5kdXBsaWNhdGUgPSBwYS5kdXBsaWNhdGUgPyBwYS5kdXBsaWNhdGUgOiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBwYTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHB1bGwoc3RyZWFtLCBkdXJhYmxlLCBleHBpcmVzID0gMCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgKDAsIGpzdXRpbF8xLnZhbGlkYXRlU3RyZWFtTmFtZSkoc3RyZWFtKTtcbiAgICAgICAgICAgICgwLCBqc3V0aWxfMS52YWxpZGF0ZUR1cmFibGVOYW1lKShkdXJhYmxlKTtcbiAgICAgICAgICAgIGxldCB0aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICAgICAgaWYgKGV4cGlyZXMgPiB0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IGV4cGlyZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBpcmVzID0gZXhwaXJlcyA8IDAgPyAwIDogKDAsIGpzdXRpbF8xLm5hbm9zKShleHBpcmVzKTtcbiAgICAgICAgICAgIGNvbnN0IHB1bGxPcHRzID0ge1xuICAgICAgICAgICAgICAgIGJhdGNoOiAxLFxuICAgICAgICAgICAgICAgIG5vX3dhaXQ6IGV4cGlyZXMgPT09IDAsXG4gICAgICAgICAgICAgICAgZXhwaXJlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBtc2cgPSB5aWVsZCB0aGlzLm5jLnJlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLk1TRy5ORVhULiR7c3RyZWFtfS4ke2R1cmFibGV9YCwgdGhpcy5qYy5lbmNvZGUocHVsbE9wdHMpLCB7IG5vTXV4OiB0cnVlLCB0aW1lb3V0IH0pO1xuICAgICAgICAgICAgY29uc3QgZXJyID0gKDAsIGpzdXRpbF8xLmNoZWNrSnNFcnJvcikobXNnKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKDAsIGpzbXNnXzEudG9Kc01zZykobXNnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qXG4gICAgICogUmV0dXJucyBhdmFpbGFibGUgbWVzc2FnZXMgdXB0byBzcGVjaWZpZWQgYmF0Y2ggY291bnQuXG4gICAgICogSWYgZXhwaXJlcyBpcyBzZXQgdGhlIGl0ZXJhdG9yIHdpbGwgd2FpdCBmb3IgdGhlIHNwZWNpZmllZFxuICAgICAqIGFtb3VudCBvZiBtaWxsaXMgYmVmb3JlIGNsb3NpbmcgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKiBJZiBub193YWl0IGlzIHNwZWNpZmllZCwgdGhlIGl0ZXJhdG9yIHdpbGwgcmV0dXJuIG5vIG1lc3NhZ2VzLlxuICAgICAqIEBwYXJhbSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gZHVyYWJsZVxuICAgICAqIEBwYXJhbSBvcHRzXG4gICAgICovXG4gICAgZmV0Y2goc3RyZWFtLCBkdXJhYmxlLCBvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoMCwganN1dGlsXzEudmFsaWRhdGVTdHJlYW1OYW1lKShzdHJlYW0pO1xuICAgICAgICAoMCwganN1dGlsXzEudmFsaWRhdGVEdXJhYmxlTmFtZSkoZHVyYWJsZSk7XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGNvbnN0IHRyYWNrQnl0ZXMgPSAoKF9hID0gb3B0cy5tYXhfYnl0ZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApID4gMDtcbiAgICAgICAgbGV0IHJlY2VpdmVkQnl0ZXMgPSAwO1xuICAgICAgICBjb25zdCBtYXhfYnl0ZXMgPSB0cmFja0J5dGVzID8gb3B0cy5tYXhfYnl0ZXMgOiAwO1xuICAgICAgICBsZXQgbW9uaXRvciA9IG51bGw7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7fTtcbiAgICAgICAgYXJncy5iYXRjaCA9IG9wdHMuYmF0Y2ggfHwgMTtcbiAgICAgICAgaWYgKG1heF9ieXRlcykge1xuICAgICAgICAgICAgY29uc3QgZnYgPSB0aGlzLm5jLmZlYXR1cmVzLmdldChzZW12ZXJfMS5GZWF0dXJlLkpTX1BVTExfTUFYX0JZVEVTKTtcbiAgICAgICAgICAgIGlmICghZnYub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1heF9ieXRlcyBpcyBvbmx5IHN1cHBvcnRlZCBvbiBzZXJ2ZXJzICR7ZnYubWlufSBvciBiZXR0ZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3MubWF4X2J5dGVzID0gbWF4X2J5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3Mubm9fd2FpdCA9IG9wdHMubm9fd2FpdCB8fCBmYWxzZTtcbiAgICAgICAgaWYgKGFyZ3Mubm9fd2FpdCAmJiBhcmdzLmV4cGlyZXMpIHtcbiAgICAgICAgICAgIGFyZ3MuZXhwaXJlcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwaXJlcyA9IG9wdHMuZXhwaXJlcyB8fCAwO1xuICAgICAgICBpZiAoZXhwaXJlcykge1xuICAgICAgICAgICAgYXJncy5leHBpcmVzID0gKDAsIGpzdXRpbF8xLm5hbm9zKShleHBpcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwaXJlcyA9PT0gMCAmJiBhcmdzLm5vX3dhaXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBpcmVzIG9yIG5vX3dhaXQgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGIgPSBvcHRzLmlkbGVfaGVhcnRiZWF0IHx8IDA7XG4gICAgICAgIGlmIChoYikge1xuICAgICAgICAgICAgYXJncy5pZGxlX2hlYXJ0YmVhdCA9ICgwLCBqc3V0aWxfMS5uYW5vcykoaGIpO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlOiBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgaWYgKG9wdHMuZGVsYXlfaGVhcnRiZWF0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlOiB0ZXN0IG9wdGlvblxuICAgICAgICAgICAgICAgIGFyZ3MuaWRsZV9oZWFydGJlYXQgPSAoMCwganN1dGlsXzEubmFub3MpKGhiICogNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcWkgPSBuZXcgcXVldWVkX2l0ZXJhdG9yXzEuUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGNvbnN0IHdhbnRzID0gYXJncy5iYXRjaDtcbiAgICAgICAgbGV0IHJlY2VpdmVkID0gMDtcbiAgICAgICAgcWkucHJvdG9jb2xGaWx0ZXJGbiA9IChqbSwgX2luZ2VzdCA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBqc21pID0gam07XG4gICAgICAgICAgICBpZiAoKDAsIGpzdXRpbF8xLmlzSGVhcnRiZWF0TXNnKShqc21pLm1zZykpIHtcbiAgICAgICAgICAgICAgICBtb25pdG9yID09PSBudWxsIHx8IG1vbml0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vbml0b3Iud29yaygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvLyBGSVhNRTogdGhpcyBsb29rcyB3ZWlyZCwgd2Ugd2FudCB0byBzdG9wIHRoZSBpdGVyYXRvclxuICAgICAgICAvLyAgIGJ1dCBkb2luZyBpdCBmcm9tIGEgZGlzcGF0Y2hlZEZuLi4uXG4gICAgICAgIHFpLmRpc3BhdGNoZWRGbiA9IChtKSA9PiB7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFja0J5dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkQnl0ZXMgKz0gbS5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQrKztcbiAgICAgICAgICAgICAgICBpZiAodGltZXIgJiYgbS5pbmZvLnBlbmRpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGV4cGlyYXRpb24gd2lsbCBjbG9zZSBpdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgb25lIHBlbmRpbmcgYW5kIHdlIGdvdCB0aGUgZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyBvciB0aGVyZSBhcmUgbm8gbW9yZSBzdG9wIHRoZSBpdGVyYXRvclxuICAgICAgICAgICAgICAgIGlmIChxaS5nZXRQZW5kaW5nKCkgPT09IDEgJiYgbS5pbmZvLnBlbmRpbmcgPT09IDAgfHwgd2FudHMgPT09IHJlY2VpdmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIChtYXhfYnl0ZXMgPiAwICYmIHJlY2VpdmVkQnl0ZXMgPj0gbWF4X2J5dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBxaS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbmJveCA9ICgwLCBjb3JlXzEuY3JlYXRlSW5ib3gpKHRoaXMubmMub3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgIGNvbnN0IHN1YiA9IHRoaXMubmMuc3Vic2NyaWJlKGluYm94LCB7XG4gICAgICAgICAgICBtYXg6IG9wdHMuYmF0Y2gsXG4gICAgICAgICAgICBjYWxsYmFjazogKGVyciwgbXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBlcnIgPSAoMCwganN1dGlsXzEuY2hlY2tKc0Vycm9yKShtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBjb3JlXzEuaXNOYXRzRXJyb3IpKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFpLnN0b3AoaGlkZU5vblRlcm1pbmFsSnNFcnJvcnMoZXJyKSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBkb2luZyBoZWFydGJlYXRzLCBtZXNzYWdlIHJlc2V0c1xuICAgICAgICAgICAgICAgICAgICBtb25pdG9yID09PSBudWxsIHx8IG1vbml0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vbml0b3Iud29yaygpO1xuICAgICAgICAgICAgICAgICAgICBxaS5yZWNlaXZlZCsrO1xuICAgICAgICAgICAgICAgICAgICBxaS5wdXNoKCgwLCBqc21zZ18xLnRvSnNNc2cpKG1zZykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0aW1lciBvbiB0aGUgY2xpZW50ICB0aGUgaXNzdWUgaXMgdGhhdCB0aGUgcmVxdWVzdFxuICAgICAgICAvLyBpcyBzdGFydGVkIG9uIHRoZSBjbGllbnQsIHdoaWNoIG1lYW5zIHRoYXQgaXQgd2lsbCBleHBpcmVcbiAgICAgICAgLy8gb24gdGhlIGNsaWVudCBmaXJzdFxuICAgICAgICBpZiAoZXhwaXJlcykge1xuICAgICAgICAgICAgdGltZXIgPSAoMCwgdXRpbF8xLnRpbWVvdXQpKGV4cGlyZXMpO1xuICAgICAgICAgICAgdGltZXIuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc3ViLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ViLmRyYWluKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7IH0pO1xuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtb25pdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGhiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vbml0b3IgPSBuZXcgaWRsZWhlYXJ0YmVhdF9tb25pdG9yXzEuSWRsZUhlYXJ0YmVhdE1vbml0b3IoaGIsICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmU6IHB1c2hpbmcgYSBmblxuICAgICAgICAgICAgICAgICAgICAgICAgcWkucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHRlcm1pbmF0ZSB0aGUgaXRlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxaS5lcnIgPSBuZXcgdHlwZXNfMS5OYXRzRXJyb3IoYCR7anN1dGlsXzEuSnM0MDlFcnJvcnMuSWRsZUhlYXJ0YmVhdE1pc3NlZH06ICR7dn1gLCBjb3JlXzEuRXJyb3JDb2RlLkpldFN0cmVhbUlkbGVIZWFydEJlYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmUgaXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNsb3NlIHRoZSBpdGVyYXRvciBpZiB0aGUgY29ubmVjdGlvbiBvciBzdWJzY3JpcHRpb24gY2xvc2VzIHVuZXhwZWN0ZWRseVxuICAgICAgICAgICAgeWllbGQgc3ViLmNsb3NlZDtcbiAgICAgICAgICAgIGlmICh0aW1lciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb25pdG9yKSB7XG4gICAgICAgICAgICAgICAgbW9uaXRvci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFpLnN0b3AoKTtcbiAgICAgICAgfSkpKCkuY2F0Y2goKTtcbiAgICAgICAgdGhpcy5uYy5wdWJsaXNoKGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5NU0cuTkVYVC4ke3N0cmVhbX0uJHtkdXJhYmxlfWAsIHRoaXMuamMuZW5jb2RlKGFyZ3MpLCB7IHJlcGx5OiBpbmJveCB9KTtcbiAgICAgICAgcmV0dXJuIHFpO1xuICAgIH1cbiAgICBwdWxsU3Vic2NyaWJlKHN1YmplY3QsIG9wdHMgPSAoMCwgdHlwZXNfMi5jb25zdW1lck9wdHMpKCkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNzbyA9IHlpZWxkIHRoaXMuX3Byb2Nlc3NPcHRpb25zKHN1YmplY3QsIG9wdHMpO1xuICAgICAgICAgICAgaWYgKGNzby5vcmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHVsbCBzdWJzY3JpYmVycyBjYW5ub3QgYmUgYmUgb3JkZXJlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjc28uY29uZmlnLmRlbGl2ZXJfc3ViamVjdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbnN1bWVyIGluZm8gc3BlY2lmaWVzIGRlbGl2ZXJfc3ViamVjdCAtIHB1bGwgY29uc3VtZXJzIGNhbm5vdCBoYXZlIGRlbGl2ZXJfc3ViamVjdCBzZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY2tQb2xpY3kgPSBjc28uY29uZmlnLmFja19wb2xpY3k7XG4gICAgICAgICAgICBpZiAoYWNrUG9saWN5ID09PSBqc2FwaV90eXBlc18xLkFja1BvbGljeS5Ob25lIHx8IGFja1BvbGljeSA9PT0ganNhcGlfdHlwZXNfMS5BY2tQb2xpY3kuQWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWNrIHBvbGljeSBmb3IgcHVsbCBjb25zdW1lcnMgbXVzdCBiZSBleHBsaWNpdFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5fYnVpbGRUeXBlZFN1YnNjcmlwdGlvbk9wdHMoY3NvKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IG5ldyBKZXRTdHJlYW1QdWxsU3Vic2NyaXB0aW9uSW1wbCh0aGlzLCBjc28uZGVsaXZlciwgc28pO1xuICAgICAgICAgICAgc3ViLmluZm8gPSBjc287XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX21heWJlQ3JlYXRlQ29uc3VtZXIoY3NvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3ViO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKHN1YmplY3QsIG9wdHMgPSAoMCwgdHlwZXNfMi5jb25zdW1lck9wdHMpKCkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNzbyA9IHlpZWxkIHRoaXMuX3Byb2Nlc3NPcHRpb25zKHN1YmplY3QsIG9wdHMpO1xuICAgICAgICAgICAgLy8gdGhpcyBlZmZlY3RpdmVseSByZXF1aXJlcyBkZWxpdmVyIHN1YmplY3QgdG8gYmUgc3BlY2lmaWVkXG4gICAgICAgICAgICAvLyBhcyBhbiBvcHRpb24gb3RoZXJ3aXNlIHdlIGhhdmUgYSBwdWxsIGNvbnN1bWVyXG4gICAgICAgICAgICBpZiAoIWNzby5pc0JpbmQgJiYgIWNzby5jb25maWcuZGVsaXZlcl9zdWJqZWN0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHVzaCBjb25zdW1lciByZXF1aXJlcyBkZWxpdmVyX3N1YmplY3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzbyA9IHRoaXMuX2J1aWxkVHlwZWRTdWJzY3JpcHRpb25PcHRzKGNzbyk7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBuZXcgSmV0U3RyZWFtU3Vic2NyaXB0aW9uSW1wbCh0aGlzLCBjc28uZGVsaXZlciwgc28pO1xuICAgICAgICAgICAgc3ViLmluZm8gPSBjc287XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX21heWJlQ3JlYXRlQ29uc3VtZXIoY3NvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdWIuX21heWJlU2V0dXBIYk1vbml0b3JpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiBzdWI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJvY2Vzc09wdGlvbnMoc3ViamVjdCwgb3B0cyA9ICgwLCB0eXBlc18yLmNvbnN1bWVyT3B0cykoKSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QganNpID0gKCgwLCB0eXBlc18yLmlzQ29uc3VtZXJPcHRzQnVpbGRlcikob3B0cylcbiAgICAgICAgICAgICAgICA/IG9wdHMuZ2V0T3B0cygpXG4gICAgICAgICAgICAgICAgOiBvcHRzKTtcbiAgICAgICAgICAgIGpzaS5pc0JpbmQgPSAoMCwgdHlwZXNfMi5pc0NvbnN1bWVyT3B0c0J1aWxkZXIpKG9wdHMpID8gb3B0cy5pc0JpbmQgOiBmYWxzZTtcbiAgICAgICAgICAgIGpzaS5mbG93X2NvbnRyb2wgPSB7XG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0X2NvdW50OiAwLFxuICAgICAgICAgICAgICAgIGZjX2NvdW50OiAwLFxuICAgICAgICAgICAgICAgIGNvbnN1bWVyX3Jlc3RhcnRzOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChqc2kub3JkZXJlZCkge1xuICAgICAgICAgICAgICAgIGpzaS5vcmRlcmVkX2NvbnN1bWVyX3NlcXVlbmNlID0geyBzdHJlYW1fc2VxOiAwLCBkZWxpdmVyeV9zZXE6IDAgfTtcbiAgICAgICAgICAgICAgICBpZiAoanNpLmNvbmZpZy5hY2tfcG9saWN5ICE9PSBqc2FwaV90eXBlc18xLkFja1BvbGljeS5Ob3RTZXQgJiZcbiAgICAgICAgICAgICAgICAgICAganNpLmNvbmZpZy5hY2tfcG9saWN5ICE9PSBqc2FwaV90eXBlc18xLkFja1BvbGljeS5Ob25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLk5hdHNFcnJvcihcIm9yZGVyZWQgY29uc3VtZXI6IGFja19wb2xpY3kgY2FuIG9ubHkgYmUgc2V0IHRvICdub25lJ1wiLCBjb3JlXzEuRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGpzaS5jb25maWcuZHVyYWJsZV9uYW1lICYmIGpzaS5jb25maWcuZHVyYWJsZV9uYW1lLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuTmF0c0Vycm9yKFwib3JkZXJlZCBjb25zdW1lcjogZHVyYWJsZV9uYW1lIGNhbm5vdCBiZSBzZXRcIiwgY29yZV8xLkVycm9yQ29kZS5BcGlFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqc2kuY29uZmlnLmRlbGl2ZXJfc3ViamVjdCAmJiBqc2kuY29uZmlnLmRlbGl2ZXJfc3ViamVjdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLk5hdHNFcnJvcihcIm9yZGVyZWQgY29uc3VtZXI6IGRlbGl2ZXJfc3ViamVjdCBjYW5ub3QgYmUgc2V0XCIsIGNvcmVfMS5FcnJvckNvZGUuQXBpRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoanNpLmNvbmZpZy5tYXhfZGVsaXZlciAhPT0gdW5kZWZpbmVkICYmIGpzaS5jb25maWcubWF4X2RlbGl2ZXIgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyB0eXBlc18xLk5hdHNFcnJvcihcIm9yZGVyZWQgY29uc3VtZXI6IG1heF9kZWxpdmVyIGNhbm5vdCBiZSBzZXRcIiwgY29yZV8xLkVycm9yQ29kZS5BcGlFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqc2kuY29uZmlnLmRlbGl2ZXJfZ3JvdXAgJiYganNpLmNvbmZpZy5kZWxpdmVyX2dyb3VwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHR5cGVzXzEuTmF0c0Vycm9yKFwib3JkZXJlZCBjb25zdW1lcjogZGVsaXZlcl9ncm91cCBjYW5ub3QgYmUgc2V0XCIsIGNvcmVfMS5FcnJvckNvZGUuQXBpRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqc2kuY29uZmlnLmRlbGl2ZXJfc3ViamVjdCA9ICgwLCBjb3JlXzEuY3JlYXRlSW5ib3gpKHRoaXMubmMub3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgICAgICAgICAganNpLmNvbmZpZy5hY2tfcG9saWN5ID0ganNhcGlfdHlwZXNfMS5BY2tQb2xpY3kuTm9uZTtcbiAgICAgICAgICAgICAgICBqc2kuY29uZmlnLm1heF9kZWxpdmVyID0gMTtcbiAgICAgICAgICAgICAgICBqc2kuY29uZmlnLmZsb3dfY29udHJvbCA9IHRydWU7XG4gICAgICAgICAgICAgICAganNpLmNvbmZpZy5pZGxlX2hlYXJ0YmVhdCA9IGpzaS5jb25maWcuaWRsZV9oZWFydGJlYXQgfHwgKDAsIGpzdXRpbF8xLm5hbm9zKSg1MDAwKTtcbiAgICAgICAgICAgICAgICBqc2kuY29uZmlnLmFja193YWl0ID0gKDAsIGpzdXRpbF8xLm5hbm9zKSgyMiAqIDYwICogNjAgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICBqc2kuY29uZmlnLm1lbV9zdG9yYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBqc2kuY29uZmlnLm51bV9yZXBsaWNhcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoanNpLmNvbmZpZy5hY2tfcG9saWN5ID09PSBqc2FwaV90eXBlc18xLkFja1BvbGljeS5Ob3RTZXQpIHtcbiAgICAgICAgICAgICAgICBqc2kuY29uZmlnLmFja19wb2xpY3kgPSBqc2FwaV90eXBlc18xLkFja1BvbGljeS5BbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqc2kuYXBpID0gdGhpcztcbiAgICAgICAgICAgIGpzaS5jb25maWcgPSBqc2kuY29uZmlnIHx8IHt9O1xuICAgICAgICAgICAganNpLnN0cmVhbSA9IGpzaS5zdHJlYW0gPyBqc2kuc3RyZWFtIDogeWllbGQgdGhpcy5maW5kU3RyZWFtKHN1YmplY3QpO1xuICAgICAgICAgICAganNpLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoanNpLmNvbmZpZy5kdXJhYmxlX25hbWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0geWllbGQgdGhpcy5jb25zdW1lckFQSS5pbmZvKGpzaS5zdHJlYW0sIGpzaS5jb25maWcuZHVyYWJsZV9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmNvbmZpZy5maWx0ZXJfc3ViamVjdCAmJiBpbmZvLmNvbmZpZy5maWx0ZXJfc3ViamVjdCAhPT0gc3ViamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInN1YmplY3QgZG9lcyBub3QgbWF0Y2ggY29uc3VtZXJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBzZXJ2ZXIgcmV0dXJuZWQgcHVzaF9ib3VuZCwgYnV0IHRoZXJlJ3Mgbm8gcW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHFuID0gKF9hID0ganNpLmNvbmZpZy5kZWxpdmVyX2dyb3VwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHFuID09PSBcIlwiICYmIGluZm8ucHVzaF9ib3VuZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVwbGljYXRlIHN1YnNjcmlwdGlvbmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnFuID0gKF9iID0gaW5mby5jb25maWcuZGVsaXZlcl9ncm91cCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxbiAhPT0gcnFuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGR1cmFibGUgcmVxdWlyZXMgbm8gcXVldWUgZ3JvdXBgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZHVyYWJsZSByZXF1aXJlcyBxdWV1ZSBncm91cCAnJHtycW59J2ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGpzaS5sYXN0ID0gaW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzaS5jb25maWcgPSBpbmZvLmNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzaS5hdHRhY2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3QgYSBkdXJhYmxlIGNhcHR1cmUgdGhlIG5hbWUgb2YgdGhlIGVwaGVtZXJhbCBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBjb25zdW1lckluZm8gZnJvbSB0aGUgc3ViIHdpbGwgd29ya1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFqc2kuY29uZmlnLmR1cmFibGVfbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzaS5uYW1lID0gaW5mby5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdW1lciBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSAhPT0gXCI0MDRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFqc2kuYXR0YWNoZWQgJiYganNpLmNvbmZpZy5maWx0ZXJfc3ViamVjdCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAganNpLmNvbmZpZy5maWx0ZXJfc3ViamVjdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIGZpbHRlciBzcGVjaWZpZWQsIHdlIHNldCB0aGUgc3ViamVjdCBhcyB0aGUgZmlsdGVyXG4gICAgICAgICAgICAgICAganNpLmNvbmZpZy5maWx0ZXJfc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqc2kuZGVsaXZlciA9IGpzaS5jb25maWcuZGVsaXZlcl9zdWJqZWN0IHx8XG4gICAgICAgICAgICAgICAgKDAsIGNvcmVfMS5jcmVhdGVJbmJveCkodGhpcy5uYy5vcHRpb25zLmluYm94UHJlZml4KTtcbiAgICAgICAgICAgIHJldHVybiBqc2k7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYnVpbGRUeXBlZFN1YnNjcmlwdGlvbk9wdHMoanNpKSB7XG4gICAgICAgIGNvbnN0IHNvID0ge307XG4gICAgICAgIHNvLmFkYXB0ZXIgPSBtc2dBZGFwdGVyKGpzaS5jYWxsYmFja0ZuID09PSB1bmRlZmluZWQpO1xuICAgICAgICBzby5pbmdlc3Rpb25GaWx0ZXJGbiA9IEpldFN0cmVhbUNsaWVudEltcGwuaW5nZXN0aW9uRm4oanNpLm9yZGVyZWQpO1xuICAgICAgICBzby5wcm90b2NvbEZpbHRlckZuID0gKGptLCBpbmdlc3QgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QganNtaSA9IGptO1xuICAgICAgICAgICAgaWYgKCgwLCBqc3V0aWxfMS5pc0Zsb3dDb250cm9sTXNnKShqc21pLm1zZykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBqc21pLm1zZy5yZXNwb25kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIWpzaS5tYWNrICYmIGpzaS5jb25maWcuYWNrX3BvbGljeSAhPT0ganNhcGlfdHlwZXNfMS5BY2tQb2xpY3kuTm9uZSkge1xuICAgICAgICAgICAgc28uZGlzcGF0Y2hlZEZuID0gYXV0b0Fja0pzTXNnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc2kuY2FsbGJhY2tGbikge1xuICAgICAgICAgICAgc28uY2FsbGJhY2sgPSBqc2kuY2FsbGJhY2tGbjtcbiAgICAgICAgfVxuICAgICAgICBzby5tYXggPSBqc2kubWF4IHx8IDA7XG4gICAgICAgIHNvLnF1ZXVlID0ganNpLnF1ZXVlO1xuICAgICAgICByZXR1cm4gc287XG4gICAgfVxuICAgIF9tYXliZUNyZWF0ZUNvbnN1bWVyKGpzaSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGpzaS5hdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqc2kuaXNCaW5kKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmFibGUgdG8gYmluZCAtIGR1cmFibGUgY29uc3VtZXIgJHtqc2kuY29uZmlnLmR1cmFibGVfbmFtZX0gZG9lc24ndCBleGlzdCBpbiAke2pzaS5zdHJlYW19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqc2kuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgZGVsaXZlcl9wb2xpY3k6IGpzYXBpX3R5cGVzXzEuRGVsaXZlclBvbGljeS5BbGwsXG4gICAgICAgICAgICAgICAgYWNrX3BvbGljeToganNhcGlfdHlwZXNfMS5BY2tQb2xpY3kuRXhwbGljaXQsXG4gICAgICAgICAgICAgICAgYWNrX3dhaXQ6ICgwLCBqc3V0aWxfMS5uYW5vcykoMzAgKiAxMDAwKSxcbiAgICAgICAgICAgICAgICByZXBsYXlfcG9saWN5OiBqc2FwaV90eXBlc18xLlJlcGxheVBvbGljeS5JbnN0YW50LFxuICAgICAgICAgICAgfSwganNpLmNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBjaSA9IHlpZWxkIHRoaXMuY29uc3VtZXJBUEkuYWRkKGpzaS5zdHJlYW0sIGpzaS5jb25maWcpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoanNpLmNvbmZpZy5maWx0ZXJfc3ViamVjdHMgJiYgIUFycmF5LmlzQXJyYXkoY2kuY29uZmlnLmZpbHRlcl9zdWJqZWN0cykpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VydmVyIGRpZG4ndCBob25vciBgZmlsdGVyX3N1YmplY3RzYFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgamV0c3RyZWFtIHNlcnZlciBkb2Vzbid0IHN1cHBvcnQgY29uc3VtZXJzIHdpdGggbXVsdGlwbGUgZmlsdGVyIHN1YmplY3RzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqc2kubmFtZSA9IGNpLm5hbWU7XG4gICAgICAgICAgICBqc2kuY29uZmlnID0gY2kuY29uZmlnO1xuICAgICAgICAgICAganNpLmxhc3QgPSBjaTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBpbmdlc3Rpb25GbihvcmRlcmVkKSB7XG4gICAgICAgIHJldHVybiAoam0sIGN0eCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gY3R4IGlzIGV4cGVjdGVkIHRvIGJlIHRoZSBpdGVyYXRvciAodGhlIEpldHN0cmVhbVN1YnNjcmlwdGlvbkltcGwpXG4gICAgICAgICAgICBjb25zdCBqc3ViID0gY3R4O1xuICAgICAgICAgICAgLy8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuXG4gICAgICAgICAgICBpZiAoIWptKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGluZ2VzdDogZmFsc2UsIHByb3RvY29sOiBmYWxzZSB9O1xuICAgICAgICAgICAgY29uc3Qgam1pID0gam07XG4gICAgICAgICAgICBpZiAoISgwLCBqc3V0aWxfMS5jaGVja0pzRXJyb3IpKGptaS5tc2cpKSB7XG4gICAgICAgICAgICAgICAgKF9hID0ganN1Yi5tb25pdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud29yaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCgwLCBqc3V0aWxfMS5pc0hlYXJ0YmVhdE1zZykoam1pLm1zZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmdlc3QgPSBvcmRlcmVkID8ganN1Yi5fY2hlY2tIYk9yZGVyQ29uc3VtZXIoam1pLm1zZykgOiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghb3JkZXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBqc3ViLmluZm8uZmxvd19jb250cm9sLmhlYXJ0YmVhdF9jb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBpbmdlc3QsIHByb3RvY29sOiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwganN1dGlsXzEuaXNGbG93Q29udHJvbE1zZykoam1pLm1zZykpIHtcbiAgICAgICAgICAgICAgICBqc3ViLmluZm8uZmxvd19jb250cm9sLmZjX2NvdW50Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaW5nZXN0OiB0cnVlLCBwcm90b2NvbDogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5nZXN0ID0gb3JkZXJlZCA/IGpzdWIuX2NoZWNrT3JkZXJlZENvbnN1bWVyKGptKSA6IHRydWU7XG4gICAgICAgICAgICByZXR1cm4geyBpbmdlc3QsIHByb3RvY29sOiBmYWxzZSB9O1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSmV0U3RyZWFtQ2xpZW50SW1wbCA9IEpldFN0cmVhbUNsaWVudEltcGw7XG5jbGFzcyBKZXRTdHJlYW1TdWJzY3JpcHRpb25JbXBsIGV4dGVuZHMgdHlwZWRzdWJfMS5UeXBlZFN1YnNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoanMsIHN1YmplY3QsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoanMubmMsIHN1YmplY3QsIG9wdHMpO1xuICAgICAgICB0aGlzLmpzID0ganM7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3ViLmNsb3NlZC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vbml0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vbml0b3IuY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQgaW5mbyhpbmZvKSB7XG4gICAgICAgIHRoaXMuc3ViLmluZm8gPSBpbmZvO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViLmluZm87XG4gICAgfVxuICAgIF9yZXNldE9yZGVyZWRDb25zdW1lcihzc2VxKSB7XG4gICAgICAgIGlmICh0aGlzLmluZm8gPT09IG51bGwgfHwgdGhpcy5zdWIuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0RlbGl2ZXIgPSAoMCwgY29yZV8xLmNyZWF0ZUluYm94KSh0aGlzLmpzLm5jLm9wdGlvbnMuaW5ib3hQcmVmaXgpO1xuICAgICAgICBjb25zdCBuY2kgPSB0aGlzLmpzLm5jO1xuICAgICAgICBuY2kuX3Jlc3ViKHRoaXMuc3ViLCBuZXdEZWxpdmVyKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuaW5mbztcbiAgICAgICAgaW5mby5vcmRlcmVkX2NvbnN1bWVyX3NlcXVlbmNlLmRlbGl2ZXJ5X3NlcSA9IDA7XG4gICAgICAgIGluZm8uZmxvd19jb250cm9sLmhlYXJ0YmVhdF9jb3VudCA9IDA7XG4gICAgICAgIGluZm8uZmxvd19jb250cm9sLmZjX2NvdW50ID0gMDtcbiAgICAgICAgaW5mby5mbG93X2NvbnRyb2wuY29uc3VtZXJfcmVzdGFydHMrKztcbiAgICAgICAgaW5mby5kZWxpdmVyID0gbmV3RGVsaXZlcjtcbiAgICAgICAgaW5mby5jb25maWcuZGVsaXZlcl9zdWJqZWN0ID0gbmV3RGVsaXZlcjtcbiAgICAgICAgaW5mby5jb25maWcuZGVsaXZlcl9wb2xpY3kgPSBqc2FwaV90eXBlc18xLkRlbGl2ZXJQb2xpY3kuU3RhcnRTZXF1ZW5jZTtcbiAgICAgICAgaW5mby5jb25maWcub3B0X3N0YXJ0X3NlcSA9IHNzZXE7XG4gICAgICAgIC8vIHB1dCB0aGUgc3RyZWFtIG5hbWVcbiAgICAgICAgY29uc3QgcmVxID0ge307XG4gICAgICAgIHJlcS5zdHJlYW1fbmFtZSA9IHRoaXMuaW5mby5zdHJlYW07XG4gICAgICAgIHJlcS5jb25maWcgPSBpbmZvLmNvbmZpZztcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke2luZm8uYXBpLnByZWZpeH0uQ09OU1VNRVIuQ1JFQVRFLiR7aW5mby5zdHJlYW19YDtcbiAgICAgICAgdGhpcy5qcy5fcmVxdWVzdChzdWJqLCByZXEpXG4gICAgICAgICAgICAudGhlbigodikgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2kgPSB2O1xuICAgICAgICAgICAgdGhpcy5pbmZvLmNvbmZpZyA9IGNpLmNvbmZpZztcbiAgICAgICAgICAgIHRoaXMuaW5mby5uYW1lID0gY2kubmFtZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAvLyB0byBpbmZvcm0gdGhlIHN1YnNjcmlwdGlvbiB3ZSBpbmplY3QgYW4gZXJyb3IgdGhpcyB3aWxsXG4gICAgICAgICAgICAvLyBiZSBhdCBhZnRlciB0aGUgbGFzdCBtZXNzYWdlIGlmIHVzaW5nIGFuIGl0ZXJhdG9yLlxuICAgICAgICAgICAgY29uc3QgbmVyciA9IG5ldyB0eXBlc18xLk5hdHNFcnJvcihgdW5hYmxlIHRvIHJlY3JlYXRlIG9yZGVyZWQgY29uc3VtZXIgJHtpbmZvLnN0cmVhbX0gYXQgc2VxICR7c3NlcX1gLCBjb3JlXzEuRXJyb3JDb2RlLlJlcXVlc3RFcnJvciwgZXJyKTtcbiAgICAgICAgICAgIHRoaXMuc3ViLmNhbGxiYWNrKG5lcnIsIHt9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHRoaXMgaXMgY2FsbGVkIGJ5IHB1c2ggc3Vic2NyaXB0aW9ucywgdG8gaW5pdGlhbGl6ZSB0aGUgbW9uaXRvcmluZ1xuICAgIC8vIGlmIGNvbmZpZ3VyZWQgb24gdGhlIGNvbnN1bWVyXG4gICAgX21heWJlU2V0dXBIYk1vbml0b3JpbmcoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IG5zID0gKChfYiA9IChfYSA9IHRoaXMuaW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmlkbGVfaGVhcnRiZWF0KSB8fCAwO1xuICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwSGJNb25pdG9yaW5nKCgwLCBqc3V0aWxfMS5taWxsaXMpKG5zKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NldHVwSGJNb25pdG9yaW5nKG1pbGxpcywgY2FuY2VsQWZ0ZXIgPSAwKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7IGNhbmNlbEFmdGVyOiAwLCBtYXhPdXQ6IDIgfTtcbiAgICAgICAgaWYgKGNhbmNlbEFmdGVyKSB7XG4gICAgICAgICAgICBvcHRzLmNhbmNlbEFmdGVyID0gY2FuY2VsQWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5zdWI7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSAodikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAoMCwganN1dGlsXzEubmV3SnNFcnJvck1zZykoNDA5LCBgJHtqc3V0aWxfMS5KczQwOUVycm9ycy5JZGxlSGVhcnRiZWF0TWlzc2VkfTogJHt2fWAsIHRoaXMuc3ViLnN1YmplY3QpO1xuICAgICAgICAgICAgY29uc3Qgb3JkZXJlZCA9IChfYSA9IHRoaXMuaW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9yZGVyZWQ7XG4gICAgICAgICAgICAvLyBub24tb3JkZXJlZCBjb25zdW1lcnMgYXJlIGFsd2F5cyBub3RpZmllZCBvZiB0aGUgY29uZGl0aW9uXG4gICAgICAgICAgICAvLyBhcyB0aGV5IG5lZWQgdG8gdHJ5IGFuZCByZWNvdmVyXG4gICAgICAgICAgICBpZiAoIW9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Yi5jYWxsYmFjayhudWxsLCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmpzLm5jLnByb3RvY29sLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgbm90IGNvbm5lY3RlZCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRoZSBjb25zdW1lclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcSA9ICgoX2MgPSAoX2IgPSB0aGlzLmluZm8pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vcmRlcmVkX2NvbnN1bWVyX3NlcXVlbmNlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3RyZWFtX3NlcSkgfHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNldE9yZGVyZWRDb25zdW1lcihzZXEgKyAxKTtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgb3JkZXJlZCwgd2Ugd2lsbCByZXNldCB0aGUgY29uc3VtZXIgYW5kIGtlZXBcbiAgICAgICAgICAgICAgICAvLyBmZWVkaW5nIHRoZSBpdGVyYXRvciBvciBjYWxsYmFjayAtIHdlIGFyZSBub3Qgc3RvcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsZXQgdGhlIGhiIG1vbml0b3Iga25vdyBpZiB3ZSBhcmUgc3RvcHBpbmcgZm9yIGNhbGxiYWNrc1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgYXMgd2UgZGVsaXZlciB0aGUgZXJyb3JzIHZpYSB0aGUgY2IuXG4gICAgICAgICAgICByZXR1cm4gIXN1Yi5ub0l0ZXJhdG9yO1xuICAgICAgICB9O1xuICAgICAgICAvLyB0aGlzIG9ubHkgYXBwbGllcyBmb3IgcHVzaCBzdWJzY3JpcHRpb25zXG4gICAgICAgIHRoaXMubW9uaXRvciA9IG5ldyBpZGxlaGVhcnRiZWF0X21vbml0b3JfMS5JZGxlSGVhcnRiZWF0TW9uaXRvcihtaWxsaXMsIGhhbmRsZXIsIG9wdHMpO1xuICAgIH1cbiAgICBfY2hlY2tIYk9yZGVyQ29uc3VtZXIobXNnKSB7XG4gICAgICAgIGNvbnN0IHJtID0gbXNnLmhlYWRlcnMuZ2V0KHR5cGVzXzIuSnNIZWFkZXJzLkNvbnN1bWVyU3RhbGxlZEhkcik7XG4gICAgICAgIGlmIChybSAhPT0gXCJcIikge1xuICAgICAgICAgICAgY29uc3QgbmNpID0gdGhpcy5qcy5uYztcbiAgICAgICAgICAgIG5jaS5wdWJsaXNoKHJtKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXN0RGVsaXZlcmVkID0gcGFyc2VJbnQobXNnLmhlYWRlcnMuZ2V0KHR5cGVzXzIuSnNIZWFkZXJzLkxhc3RDb25zdW1lclNlcUhkciksIDEwKTtcbiAgICAgICAgY29uc3Qgb3JkZXJlZCA9IHRoaXMuaW5mby5vcmRlcmVkX2NvbnN1bWVyX3NlcXVlbmNlO1xuICAgICAgICB0aGlzLmluZm8uZmxvd19jb250cm9sLmhlYXJ0YmVhdF9jb3VudCsrO1xuICAgICAgICBpZiAobGFzdERlbGl2ZXJlZCAhPT0gb3JkZXJlZC5kZWxpdmVyeV9zZXEpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2V0T3JkZXJlZENvbnN1bWVyKG9yZGVyZWQuc3RyZWFtX3NlcSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2NoZWNrT3JkZXJlZENvbnN1bWVyKGptKSB7XG4gICAgICAgIGNvbnN0IG9yZGVyZWQgPSB0aGlzLmluZm8ub3JkZXJlZF9jb25zdW1lcl9zZXF1ZW5jZTtcbiAgICAgICAgY29uc3Qgc3NlcSA9IGptLmluZm8uc3RyZWFtU2VxdWVuY2U7XG4gICAgICAgIGNvbnN0IGRzZXEgPSBqbS5pbmZvLmRlbGl2ZXJ5U2VxdWVuY2U7XG4gICAgICAgIGlmIChkc2VxICE9IG9yZGVyZWQuZGVsaXZlcnlfc2VxICsgMSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzZXRPcmRlcmVkQ29uc3VtZXIob3JkZXJlZC5zdHJlYW1fc2VxICsgMSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb3JkZXJlZC5kZWxpdmVyeV9zZXEgPSBkc2VxO1xuICAgICAgICBvcmRlcmVkLnN0cmVhbV9zZXEgPSBzc2VxO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kcmFpbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgamluZm8gPSB0aGlzLnN1Yi5pbmZvO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGppbmZvLmNvbmZpZy5kdXJhYmxlX25hbWUgfHwgamluZm8ubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHN1YmogPSBgJHtqaW5mby5hcGkucHJlZml4fS5DT05TVU1FUi5ERUxFVEUuJHtqaW5mby5zdHJlYW19LiR7bmFtZX1gO1xuICAgICAgICAgICAgeWllbGQgamluZm8uYXBpLl9yZXF1ZXN0KHN1YmopO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3VtZXJJbmZvKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgamluZm8gPSB0aGlzLnN1Yi5pbmZvO1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IGppbmZvLmNvbmZpZy5kdXJhYmxlX25hbWUgfHwgamluZm8ubmFtZTtcbiAgICAgICAgICAgIGNvbnN0IHN1YmogPSBgJHtqaW5mby5hcGkucHJlZml4fS5DT05TVU1FUi5JTkZPLiR7amluZm8uc3RyZWFtfS4ke25hbWV9YDtcbiAgICAgICAgICAgIGNvbnN0IGNpID0geWllbGQgamluZm8uYXBpLl9yZXF1ZXN0KHN1YmopO1xuICAgICAgICAgICAgamluZm8ubGFzdCA9IGNpO1xuICAgICAgICAgICAgcmV0dXJuIGNpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkpldFN0cmVhbVN1YnNjcmlwdGlvbkltcGwgPSBKZXRTdHJlYW1TdWJzY3JpcHRpb25JbXBsO1xuY2xhc3MgSmV0U3RyZWFtUHVsbFN1YnNjcmlwdGlvbkltcGwgZXh0ZW5kcyBKZXRTdHJlYW1TdWJzY3JpcHRpb25JbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihqcywgc3ViamVjdCwgb3B0cykge1xuICAgICAgICBzdXBlcihqcywgc3ViamVjdCwgb3B0cyk7XG4gICAgfVxuICAgIHB1bGwob3B0cyA9IHsgYmF0Y2g6IDEgfSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IHN0cmVhbSwgY29uZmlnLCBuYW1lIH0gPSB0aGlzLnN1Yi5pbmZvO1xuICAgICAgICBjb25zdCBjb25zdW1lciA9IChfYSA9IGNvbmZpZy5kdXJhYmxlX25hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5hbWU7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7fTtcbiAgICAgICAgYXJncy5iYXRjaCA9IG9wdHMuYmF0Y2ggfHwgMTtcbiAgICAgICAgYXJncy5ub193YWl0ID0gb3B0cy5ub193YWl0IHx8IGZhbHNlO1xuICAgICAgICBpZiAoKChfYiA9IG9wdHMubWF4X2J5dGVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZ2ID0gdGhpcy5qcy5uYy5mZWF0dXJlcy5nZXQoc2VtdmVyXzEuRmVhdHVyZS5KU19QVUxMX01BWF9CWVRFUyk7XG4gICAgICAgICAgICBpZiAoIWZ2Lm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYXhfYnl0ZXMgaXMgb25seSBzdXBwb3J0ZWQgb24gc2VydmVycyAke2Z2Lm1pbn0gb3IgYmV0dGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhcmdzLm1heF9ieXRlcyA9IG9wdHMubWF4X2J5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBleHBpcmVzID0gMDtcbiAgICAgICAgaWYgKG9wdHMuZXhwaXJlcyAmJiBvcHRzLmV4cGlyZXMgPiAwKSB7XG4gICAgICAgICAgICBleHBpcmVzID0gb3B0cy5leHBpcmVzO1xuICAgICAgICAgICAgYXJncy5leHBpcmVzID0gKDAsIGpzdXRpbF8xLm5hbm9zKShleHBpcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGIgPSAwO1xuICAgICAgICBpZiAob3B0cy5pZGxlX2hlYXJ0YmVhdCAmJiBvcHRzLmlkbGVfaGVhcnRiZWF0ID4gMCkge1xuICAgICAgICAgICAgaGIgPSBvcHRzLmlkbGVfaGVhcnRiZWF0O1xuICAgICAgICAgICAgYXJncy5pZGxlX2hlYXJ0YmVhdCA9ICgwLCBqc3V0aWxfMS5uYW5vcykoaGIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYiAmJiBleHBpcmVzID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpZGxlX2hlYXJ0YmVhdCByZXF1aXJlcyBleHBpcmVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYiA+IGV4cGlyZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4cGlyZXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gaWRsZV9oZWFydGJlYXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5mbykge1xuICAgICAgICAgICAgaWYgKHRoaXMubW9uaXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMubW9uaXRvci5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHBpcmVzICYmIGhiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1vbml0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0dXBIYk1vbml0b3JpbmcoaGIsIGV4cGlyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb25pdG9yLl9jaGFuZ2UoaGIsIGV4cGlyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaSA9IHRoaXMuaW5mby5hcGk7XG4gICAgICAgICAgICBjb25zdCBzdWJqID0gYCR7YXBpLnByZWZpeH0uQ09OU1VNRVIuTVNHLk5FWFQuJHtzdHJlYW19LiR7Y29uc3VtZXJ9YDtcbiAgICAgICAgICAgIGNvbnN0IHJlcGx5ID0gdGhpcy5zdWIuc3ViamVjdDtcbiAgICAgICAgICAgIGFwaS5uYy5wdWJsaXNoKHN1YmosIGFwaS5qYy5lbmNvZGUoYXJncyksIHsgcmVwbHk6IHJlcGx5IH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbXNnQWRhcHRlcihpdGVyYXRvcikge1xuICAgIGlmIChpdGVyYXRvcikge1xuICAgICAgICByZXR1cm4gaXRlck1zZ0FkYXB0ZXI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gY2JNc2dBZGFwdGVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNiTXNnQWRhcHRlcihlcnIsIG1zZykge1xuICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFtlcnIsIG51bGxdO1xuICAgIH1cbiAgICBlcnIgPSAoMCwganN1dGlsXzEuY2hlY2tKc0Vycm9yKShtc2cpO1xuICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIFtlcnIsIG51bGxdO1xuICAgIH1cbiAgICAvLyBhc3N1bWluZyB0aGF0IHRoZSBwcm90b2NvbEZpbHRlckZuIGlzIHNldCFcbiAgICByZXR1cm4gW251bGwsICgwLCBqc21zZ18xLnRvSnNNc2cpKG1zZyldO1xufVxuZnVuY3Rpb24gaXRlck1zZ0FkYXB0ZXIoZXJyLCBtc2cpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBbZXJyLCBudWxsXTtcbiAgICB9XG4gICAgLy8gaXRlcmF0b3Igd2lsbCBjbG9zZSBpZiB3ZSBoYXZlIGFuIGVycm9yXG4gICAgLy8gY2hlY2sgZm9yIGVycm9ycyB0aGF0IHNob3VsZG4ndCBjbG9zZSBpdFxuICAgIGNvbnN0IG5lID0gKDAsIGpzdXRpbF8xLmNoZWNrSnNFcnJvcikobXNnKTtcbiAgICBpZiAobmUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtoaWRlTm9uVGVybWluYWxKc0Vycm9ycyhuZSksIG51bGxdO1xuICAgIH1cbiAgICAvLyBhc3N1bWluZyB0aGF0IHRoZSBwcm90b2NvbEZpbHRlckZuIGlzIHNldFxuICAgIHJldHVybiBbbnVsbCwgKDAsIGpzbXNnXzEudG9Kc01zZykobXNnKV07XG59XG5mdW5jdGlvbiBoaWRlTm9uVGVybWluYWxKc0Vycm9ycyhuZSkge1xuICAgIGlmIChuZSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKG5lLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLkVycm9yQ29kZS5KZXRTdHJlYW00MDROb01lc3NhZ2VzOlxuICAgICAgICAgICAgY2FzZSBjb3JlXzEuRXJyb3JDb2RlLkpldFN0cmVhbTQwOFJlcXVlc3RUaW1lb3V0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSBjb3JlXzEuRXJyb3JDb2RlLkpldFN0cmVhbTQwOTpcbiAgICAgICAgICAgICAgICBpZiAoKDAsIGpzdXRpbF8xLmlzVGVybWluYWw0MDkpKG5lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhdXRvQWNrSnNNc2coZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGRhdGEuYWNrKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNjbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/jsclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/jslister.js":
/*!*****************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/jslister.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ListerImpl = void 0;\nclass ListerImpl {\n    constructor(subject, filter, jsm, payload) {\n        if (!subject) {\n            throw new Error(\"subject is required\");\n        }\n        this.subject = subject;\n        this.jsm = jsm;\n        this.offset = 0;\n        this.pageInfo = {};\n        this.filter = filter;\n        this.payload = payload || {};\n    }\n    next() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.err) {\n                return [];\n            }\n            if (this.pageInfo && this.offset >= this.pageInfo.total) {\n                return [];\n            }\n            const offset = { offset: this.offset };\n            if (this.payload) {\n                Object.assign(offset, this.payload);\n            }\n            try {\n                const r = yield this.jsm._request(this.subject, offset, { timeout: this.jsm.timeout });\n                this.pageInfo = r;\n                // offsets are reported in total, so need to count\n                // all the entries returned\n                const count = this.countResponse(r);\n                if (count === 0) {\n                    // we are done if we get a null set of infos\n                    return [];\n                }\n                this.offset += count;\n                const a = this.filter(r);\n                return a;\n            }\n            catch (err) {\n                this.err = err;\n                throw err;\n            }\n        });\n    }\n    countResponse(r) {\n        var _a, _b, _c;\n        switch (r === null || r === void 0 ? void 0 : r.type) {\n            case \"io.nats.jetstream.api.v1.stream_names_response\":\n            case \"io.nats.jetstream.api.v1.stream_list_response\":\n                return ((_a = r.streams) === null || _a === void 0 ? void 0 : _a.length) || 0;\n            case \"io.nats.jetstream.api.v1.consumer_list_response\":\n                return ((_b = r.consumers) === null || _b === void 0 ? void 0 : _b.length) || 0;\n            default:\n                console.error(`jslister.ts: unknown API response for paged output: ${r === null || r === void 0 ? void 0 : r.type}`);\n                // has to be a stream...\n                return ((_c = r.streams) === null || _c === void 0 ? void 0 : _c.length) || 0;\n        }\n        return 0;\n    }\n    [Symbol.asyncIterator]() {\n        return __asyncGenerator(this, arguments, function* _a() {\n            let page = yield __await(this.next());\n            while (page.length > 0) {\n                for (const item of page) {\n                    yield yield __await(item);\n                }\n                page = yield __await(this.next());\n            }\n        });\n    }\n}\nexports.ListerImpl = ListerImpl;\n//# sourceMappingURL=jslister.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzbGlzdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0dBQW9HLGNBQWM7QUFDbkksOEJBQThCLHNCQUFzQjtBQUNwRCwwQkFBMEIsWUFBWSxzQkFBc0IscUNBQXFDLDJDQUEyQyxNQUFNO0FBQ2xKLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSwyQkFBMkI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsNkNBQTZDO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL2pldHN0cmVhbS9qc2xpc3Rlci5qcz82OTFmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19hd2FpdCA9ICh0aGlzICYmIHRoaXMuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5MaXN0ZXJJbXBsID0gdm9pZCAwO1xuY2xhc3MgTGlzdGVySW1wbCB7XG4gICAgY29uc3RydWN0b3Ioc3ViamVjdCwgZmlsdGVyLCBqc20sIHBheWxvYWQpIHtcbiAgICAgICAgaWYgKCFzdWJqZWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdWJqZWN0IGlzIHJlcXVpcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuanNtID0ganNtO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMucGFnZUluZm8gPSB7fTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHBheWxvYWQgfHwge307XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYWdlSW5mbyAmJiB0aGlzLm9mZnNldCA+PSB0aGlzLnBhZ2VJbmZvLnRvdGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0geyBvZmZzZXQ6IHRoaXMub2Zmc2V0IH07XG4gICAgICAgICAgICBpZiAodGhpcy5wYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvZmZzZXQsIHRoaXMucGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSB5aWVsZCB0aGlzLmpzbS5fcmVxdWVzdCh0aGlzLnN1YmplY3QsIG9mZnNldCwgeyB0aW1lb3V0OiB0aGlzLmpzbS50aW1lb3V0IH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUluZm8gPSByO1xuICAgICAgICAgICAgICAgIC8vIG9mZnNldHMgYXJlIHJlcG9ydGVkIGluIHRvdGFsLCBzbyBuZWVkIHRvIGNvdW50XG4gICAgICAgICAgICAgICAgLy8gYWxsIHRoZSBlbnRyaWVzIHJldHVybmVkXG4gICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmNvdW50UmVzcG9uc2Uocik7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBkb25lIGlmIHdlIGdldCBhIG51bGwgc2V0IG9mIGluZm9zXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gY291bnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuZmlsdGVyKHIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyID0gZXJyO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvdW50UmVzcG9uc2Uocikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgc3dpdGNoIChyID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImlvLm5hdHMuamV0c3RyZWFtLmFwaS52MS5zdHJlYW1fbmFtZXNfcmVzcG9uc2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpby5uYXRzLmpldHN0cmVhbS5hcGkudjEuc3RyZWFtX2xpc3RfcmVzcG9uc2VcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gKChfYSA9IHIuc3RyZWFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgICAgIGNhc2UgXCJpby5uYXRzLmpldHN0cmVhbS5hcGkudjEuY29uc3VtZXJfbGlzdF9yZXNwb25zZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAoKF9iID0gci5jb25zdW1lcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpIHx8IDA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGpzbGlzdGVyLnRzOiB1bmtub3duIEFQSSByZXNwb25zZSBmb3IgcGFnZWQgb3V0cHV0OiAke3IgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwID8gdm9pZCAwIDogci50eXBlfWApO1xuICAgICAgICAgICAgICAgIC8vIGhhcyB0byBiZSBhIHN0cmVhbS4uLlxuICAgICAgICAgICAgICAgIHJldHVybiAoKF9jID0gci5zdHJlYW1zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVuZ3RoKSB8fCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBfYSgpIHtcbiAgICAgICAgICAgIGxldCBwYWdlID0geWllbGQgX19hd2FpdCh0aGlzLm5leHQoKSk7XG4gICAgICAgICAgICB3aGlsZSAocGFnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFnZSA9IHlpZWxkIF9fYXdhaXQodGhpcy5uZXh0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RlckltcGwgPSBMaXN0ZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNsaXN0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/jslister.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/jsm.js":
/*!************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/jsm.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2021-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JetStreamManagerImpl = exports.DirectMsgImpl = exports.DirectStreamAPIImpl = void 0;\nconst jsbaseclient_api_1 = __webpack_require__(/*! ./jsbaseclient_api */ \"(rsc)/./node_modules/nats/lib/jetstream/jsbaseclient_api.js\");\nconst jsmstream_api_1 = __webpack_require__(/*! ./jsmstream_api */ \"(rsc)/./node_modules/nats/lib/jetstream/jsmstream_api.js\");\nconst jsmconsumer_api_1 = __webpack_require__(/*! ./jsmconsumer_api */ \"(rsc)/./node_modules/nats/lib/jetstream/jsmconsumer_api.js\");\nconst queued_iterator_1 = __webpack_require__(/*! ../nats-base-client/queued_iterator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/nats/lib/jetstream/types.js\");\nconst jsutil_1 = __webpack_require__(/*! ./jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\nconst encoders_1 = __webpack_require__(/*! ../nats-base-client/encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst codec_1 = __webpack_require__(/*! ../nats-base-client/codec */ \"(rsc)/./node_modules/nats/lib/nats-base-client/codec.js\");\nclass DirectStreamAPIImpl extends jsbaseclient_api_1.BaseApiClient {\n    constructor(nc, opts) {\n        super(nc, opts);\n    }\n    getMessage(stream, query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, jsutil_1.validateStreamName)(stream);\n            // if doing a last_by_subj request, we append the subject\n            // this allows last_by_subj to be subject to permissions (KV)\n            let qq = query;\n            const { last_by_subj } = qq;\n            if (last_by_subj) {\n                qq = null;\n            }\n            const payload = qq ? this.jc.encode(qq) : encoders_1.Empty;\n            const pre = this.opts.apiPrefix || \"$JS.API\";\n            const subj = last_by_subj\n                ? `${pre}.DIRECT.GET.${stream}.${last_by_subj}`\n                : `${pre}.DIRECT.GET.${stream}`;\n            const r = yield this.nc.request(subj, payload);\n            // response is not a JS.API response\n            const err = (0, jsutil_1.checkJsError)(r);\n            if (err) {\n                return Promise.reject(err);\n            }\n            const dm = new DirectMsgImpl(r);\n            return Promise.resolve(dm);\n        });\n    }\n}\nexports.DirectStreamAPIImpl = DirectStreamAPIImpl;\nclass DirectMsgImpl {\n    constructor(m) {\n        if (!m.headers) {\n            throw new Error(\"headers expected\");\n        }\n        this.data = m.data;\n        this.header = m.headers;\n    }\n    get subject() {\n        return this.header.last(types_1.DirectMsgHeaders.Subject);\n    }\n    get seq() {\n        const v = this.header.last(types_1.DirectMsgHeaders.Sequence);\n        return typeof v === \"string\" ? parseInt(v) : 0;\n    }\n    get time() {\n        return new Date(Date.parse(this.timestamp));\n    }\n    get timestamp() {\n        return this.header.last(types_1.DirectMsgHeaders.TimeStamp);\n    }\n    get stream() {\n        return this.header.last(types_1.DirectMsgHeaders.Stream);\n    }\n    json(reviver) {\n        return (0, codec_1.JSONCodec)(reviver).decode(this.data);\n    }\n    string() {\n        return encoders_1.TD.decode(this.data);\n    }\n}\nexports.DirectMsgImpl = DirectMsgImpl;\nclass JetStreamManagerImpl extends jsbaseclient_api_1.BaseApiClient {\n    constructor(nc, opts) {\n        super(nc, opts);\n        this.streams = new jsmstream_api_1.StreamAPIImpl(nc, opts);\n        this.consumers = new jsmconsumer_api_1.ConsumerAPIImpl(nc, opts);\n        this.direct = new DirectStreamAPIImpl(nc, opts);\n    }\n    getAccountInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const r = yield this._request(`${this.prefix}.INFO`);\n            return r;\n        });\n    }\n    jetstream() {\n        return this.nc.jetstream(this.getOptions());\n    }\n    advisories() {\n        const iter = new queued_iterator_1.QueuedIteratorImpl();\n        this.nc.subscribe(`$JS.EVENT.ADVISORY.>`, {\n            callback: (err, msg) => {\n                if (err) {\n                    throw err;\n                }\n                try {\n                    const d = this.parseJsResponse(msg);\n                    const chunks = d.type.split(\".\");\n                    const kind = chunks[chunks.length - 1];\n                    iter.push({ kind: kind, data: d });\n                }\n                catch (err) {\n                    iter.stop(err);\n                }\n            },\n        });\n        return iter;\n    }\n}\nexports.JetStreamManagerImpl = JetStreamManagerImpl;\n//# sourceMappingURL=jsm.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLHFCQUFxQixHQUFHLDJCQUEyQjtBQUNsRiwyQkFBMkIsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDdkQsd0JBQXdCLG1CQUFPLENBQUMsaUZBQWlCO0FBQ2pELDBCQUEwQixtQkFBTyxDQUFDLHFGQUFtQjtBQUNyRCwwQkFBMEIsbUJBQU8sQ0FBQyw4R0FBcUM7QUFDdkUsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVM7QUFDakMsaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQThCO0FBQ3pELGdCQUFnQixtQkFBTyxDQUFDLDBGQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJLGNBQWMsT0FBTyxHQUFHLGFBQWE7QUFDOUQscUJBQXFCLElBQUksY0FBYyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9qZXRzdHJlYW0vanNtLmpzP2JhMWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpldFN0cmVhbU1hbmFnZXJJbXBsID0gZXhwb3J0cy5EaXJlY3RNc2dJbXBsID0gZXhwb3J0cy5EaXJlY3RTdHJlYW1BUElJbXBsID0gdm9pZCAwO1xuY29uc3QganNiYXNlY2xpZW50X2FwaV8xID0gcmVxdWlyZShcIi4vanNiYXNlY2xpZW50X2FwaVwiKTtcbmNvbnN0IGpzbXN0cmVhbV9hcGlfMSA9IHJlcXVpcmUoXCIuL2pzbXN0cmVhbV9hcGlcIik7XG5jb25zdCBqc21jb25zdW1lcl9hcGlfMSA9IHJlcXVpcmUoXCIuL2pzbWNvbnN1bWVyX2FwaVwiKTtcbmNvbnN0IHF1ZXVlZF9pdGVyYXRvcl8xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvcXVldWVkX2l0ZXJhdG9yXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QganN1dGlsXzEgPSByZXF1aXJlKFwiLi9qc3V0aWxcIik7XG5jb25zdCBlbmNvZGVyc18xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvZW5jb2RlcnNcIik7XG5jb25zdCBjb2RlY18xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvY29kZWNcIik7XG5jbGFzcyBEaXJlY3RTdHJlYW1BUElJbXBsIGV4dGVuZHMganNiYXNlY2xpZW50X2FwaV8xLkJhc2VBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG5jLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKG5jLCBvcHRzKTtcbiAgICB9XG4gICAgZ2V0TWVzc2FnZShzdHJlYW0sIHF1ZXJ5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAoMCwganN1dGlsXzEudmFsaWRhdGVTdHJlYW1OYW1lKShzdHJlYW0pO1xuICAgICAgICAgICAgLy8gaWYgZG9pbmcgYSBsYXN0X2J5X3N1YmogcmVxdWVzdCwgd2UgYXBwZW5kIHRoZSBzdWJqZWN0XG4gICAgICAgICAgICAvLyB0aGlzIGFsbG93cyBsYXN0X2J5X3N1YmogdG8gYmUgc3ViamVjdCB0byBwZXJtaXNzaW9ucyAoS1YpXG4gICAgICAgICAgICBsZXQgcXEgPSBxdWVyeTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGFzdF9ieV9zdWJqIH0gPSBxcTtcbiAgICAgICAgICAgIGlmIChsYXN0X2J5X3N1YmopIHtcbiAgICAgICAgICAgICAgICBxcSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gcXEgPyB0aGlzLmpjLmVuY29kZShxcSkgOiBlbmNvZGVyc18xLkVtcHR5O1xuICAgICAgICAgICAgY29uc3QgcHJlID0gdGhpcy5vcHRzLmFwaVByZWZpeCB8fCBcIiRKUy5BUElcIjtcbiAgICAgICAgICAgIGNvbnN0IHN1YmogPSBsYXN0X2J5X3N1YmpcbiAgICAgICAgICAgICAgICA/IGAke3ByZX0uRElSRUNULkdFVC4ke3N0cmVhbX0uJHtsYXN0X2J5X3N1Ymp9YFxuICAgICAgICAgICAgICAgIDogYCR7cHJlfS5ESVJFQ1QuR0VULiR7c3RyZWFtfWA7XG4gICAgICAgICAgICBjb25zdCByID0geWllbGQgdGhpcy5uYy5yZXF1ZXN0KHN1YmosIHBheWxvYWQpO1xuICAgICAgICAgICAgLy8gcmVzcG9uc2UgaXMgbm90IGEgSlMuQVBJIHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCBlcnIgPSAoMCwganN1dGlsXzEuY2hlY2tKc0Vycm9yKShyKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRtID0gbmV3IERpcmVjdE1zZ0ltcGwocik7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGRtKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5EaXJlY3RTdHJlYW1BUElJbXBsID0gRGlyZWN0U3RyZWFtQVBJSW1wbDtcbmNsYXNzIERpcmVjdE1zZ0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKG0pIHtcbiAgICAgICAgaWYgKCFtLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImhlYWRlcnMgZXhwZWN0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhID0gbS5kYXRhO1xuICAgICAgICB0aGlzLmhlYWRlciA9IG0uaGVhZGVycztcbiAgICB9XG4gICAgZ2V0IHN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlci5sYXN0KHR5cGVzXzEuRGlyZWN0TXNnSGVhZGVycy5TdWJqZWN0KTtcbiAgICB9XG4gICAgZ2V0IHNlcSgpIHtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuaGVhZGVyLmxhc3QodHlwZXNfMS5EaXJlY3RNc2dIZWFkZXJzLlNlcXVlbmNlKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gcGFyc2VJbnQodikgOiAwO1xuICAgIH1cbiAgICBnZXQgdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUucGFyc2UodGhpcy50aW1lc3RhbXApKTtcbiAgICB9XG4gICAgZ2V0IHRpbWVzdGFtcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyLmxhc3QodHlwZXNfMS5EaXJlY3RNc2dIZWFkZXJzLlRpbWVTdGFtcCk7XG4gICAgfVxuICAgIGdldCBzdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYWRlci5sYXN0KHR5cGVzXzEuRGlyZWN0TXNnSGVhZGVycy5TdHJlYW0pO1xuICAgIH1cbiAgICBqc29uKHJldml2ZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlY18xLkpTT05Db2RlYykocmV2aXZlcikuZGVjb2RlKHRoaXMuZGF0YSk7XG4gICAgfVxuICAgIHN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZXJzXzEuVEQuZGVjb2RlKHRoaXMuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5EaXJlY3RNc2dJbXBsID0gRGlyZWN0TXNnSW1wbDtcbmNsYXNzIEpldFN0cmVhbU1hbmFnZXJJbXBsIGV4dGVuZHMganNiYXNlY2xpZW50X2FwaV8xLkJhc2VBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG5jLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKG5jLCBvcHRzKTtcbiAgICAgICAgdGhpcy5zdHJlYW1zID0gbmV3IGpzbXN0cmVhbV9hcGlfMS5TdHJlYW1BUElJbXBsKG5jLCBvcHRzKTtcbiAgICAgICAgdGhpcy5jb25zdW1lcnMgPSBuZXcganNtY29uc3VtZXJfYXBpXzEuQ29uc3VtZXJBUElJbXBsKG5jLCBvcHRzKTtcbiAgICAgICAgdGhpcy5kaXJlY3QgPSBuZXcgRGlyZWN0U3RyZWFtQVBJSW1wbChuYywgb3B0cyk7XG4gICAgfVxuICAgIGdldEFjY291bnRJbmZvKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgciA9IHlpZWxkIHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LklORk9gKTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgamV0c3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYy5qZXRzdHJlYW0odGhpcy5nZXRPcHRpb25zKCkpO1xuICAgIH1cbiAgICBhZHZpc29yaWVzKCkge1xuICAgICAgICBjb25zdCBpdGVyID0gbmV3IHF1ZXVlZF9pdGVyYXRvcl8xLlF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICB0aGlzLm5jLnN1YnNjcmliZShgJEpTLkVWRU5ULkFEVklTT1JZLj5gLCB7XG4gICAgICAgICAgICBjYWxsYmFjazogKGVyciwgbXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLnBhcnNlSnNSZXNwb25zZShtc2cpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua3MgPSBkLnR5cGUuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBraW5kID0gY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaXRlci5wdXNoKHsga2luZDoga2luZCwgZGF0YTogZCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpdGVyLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgfVxufVxuZXhwb3J0cy5KZXRTdHJlYW1NYW5hZ2VySW1wbCA9IEpldFN0cmVhbU1hbmFnZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNtLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/jsm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/jsmconsumer_api.js":
/*!************************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/jsmconsumer_api.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConsumerAPIImpl = void 0;\n/*\n * Copyright 2021-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst jsbaseclient_api_1 = __webpack_require__(/*! ./jsbaseclient_api */ \"(rsc)/./node_modules/nats/lib/jetstream/jsbaseclient_api.js\");\nconst jslister_1 = __webpack_require__(/*! ./jslister */ \"(rsc)/./node_modules/nats/lib/jetstream/jslister.js\");\nconst jsutil_1 = __webpack_require__(/*! ./jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\nconst semver_1 = __webpack_require__(/*! ../nats-base-client/semver */ \"(rsc)/./node_modules/nats/lib/nats-base-client/semver.js\");\nconst jsapi_types_1 = __webpack_require__(/*! ./jsapi_types */ \"(rsc)/./node_modules/nats/lib/jetstream/jsapi_types.js\");\nclass ConsumerAPIImpl extends jsbaseclient_api_1.BaseApiClient {\n    constructor(nc, opts) {\n        super(nc, opts);\n    }\n    add(stream, cfg, action = jsapi_types_1.ConsumerApiAction.Create) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, jsutil_1.validateStreamName)(stream);\n            if (cfg.deliver_group && cfg.flow_control) {\n                throw new Error(\"jetstream flow control is not supported with queue groups\");\n            }\n            if (cfg.deliver_group && cfg.idle_heartbeat) {\n                throw new Error(\"jetstream idle heartbeat is not supported with queue groups\");\n            }\n            const cr = {};\n            cr.config = cfg;\n            cr.stream_name = stream;\n            cr.action = action;\n            if (cr.config.durable_name) {\n                (0, jsutil_1.validateDurableName)(cr.config.durable_name);\n            }\n            const nci = this.nc;\n            let { min, ok: newAPI } = nci.features.get(semver_1.Feature.JS_NEW_CONSUMER_CREATE_API);\n            const name = cfg.name === \"\" ? undefined : cfg.name;\n            if (name && !newAPI) {\n                throw new Error(`consumer 'name' requires server ${min}`);\n            }\n            if (name) {\n                try {\n                    (0, jsutil_1.minValidation)(\"name\", name);\n                }\n                catch (err) {\n                    // if we have a cannot contain the message, massage a bit\n                    const m = err.message;\n                    const idx = m.indexOf(\"cannot contain\");\n                    if (idx !== -1) {\n                        throw new Error(`consumer 'name' ${m.substring(idx)}`);\n                    }\n                    throw err;\n                }\n            }\n            let subj;\n            let consumerName = \"\";\n            // new api doesn't support multiple filter subjects\n            // this delayed until here because the consumer in an update could have\n            // been created with the new API, and have a `name`\n            if (Array.isArray(cfg.filter_subjects)) {\n                const { min, ok } = nci.features.get(semver_1.Feature.JS_MULTIPLE_CONSUMER_FILTER);\n                if (!ok) {\n                    throw new Error(`consumer 'filter_subjects' requires server ${min}`);\n                }\n                newAPI = false;\n            }\n            if (cfg.metadata) {\n                const { min, ok } = nci.features.get(semver_1.Feature.JS_STREAM_CONSUMER_METADATA);\n                if (!ok) {\n                    throw new Error(`consumer 'metadata' requires server ${min}`);\n                }\n            }\n            if (newAPI) {\n                consumerName = (_b = (_a = cfg.name) !== null && _a !== void 0 ? _a : cfg.durable_name) !== null && _b !== void 0 ? _b : \"\";\n            }\n            if (consumerName !== \"\") {\n                let fs = (_c = cfg.filter_subject) !== null && _c !== void 0 ? _c : undefined;\n                if (fs === \">\") {\n                    fs = undefined;\n                }\n                subj = fs !== undefined\n                    ? `${this.prefix}.CONSUMER.CREATE.${stream}.${consumerName}.${fs}`\n                    : `${this.prefix}.CONSUMER.CREATE.${stream}.${consumerName}`;\n            }\n            else {\n                subj = cfg.durable_name\n                    ? `${this.prefix}.CONSUMER.DURABLE.CREATE.${stream}.${cfg.durable_name}`\n                    : `${this.prefix}.CONSUMER.CREATE.${stream}`;\n            }\n            const r = yield this._request(subj, cr);\n            return r;\n        });\n    }\n    update(stream, durable, cfg) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ci = yield this.info(stream, durable);\n            const changable = cfg;\n            return this.add(stream, Object.assign(ci.config, changable), jsapi_types_1.ConsumerApiAction.Update);\n        });\n    }\n    info(stream, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, jsutil_1.validateStreamName)(stream);\n            (0, jsutil_1.validateDurableName)(name);\n            const r = yield this._request(`${this.prefix}.CONSUMER.INFO.${stream}.${name}`);\n            return r;\n        });\n    }\n    delete(stream, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, jsutil_1.validateStreamName)(stream);\n            (0, jsutil_1.validateDurableName)(name);\n            const r = yield this._request(`${this.prefix}.CONSUMER.DELETE.${stream}.${name}`);\n            const cr = r;\n            return cr.success;\n        });\n    }\n    list(stream) {\n        (0, jsutil_1.validateStreamName)(stream);\n        const filter = (v) => {\n            const clr = v;\n            return clr.consumers;\n        };\n        const subj = `${this.prefix}.CONSUMER.LIST.${stream}`;\n        return new jslister_1.ListerImpl(subj, filter, this);\n    }\n}\nexports.ConsumerAPIImpl = ConsumerAPIImpl;\n//# sourceMappingURL=jsmconsumer_api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzbWNvbnN1bWVyX2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUJBQU8sQ0FBQyx1RkFBb0I7QUFDdkQsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkMsaUJBQWlCLG1CQUFPLENBQUMsNEZBQTRCO0FBQ3JELHNCQUFzQixtQkFBTyxDQUFDLDZFQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0EsbUVBQW1FLElBQUk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsaUJBQWlCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQSxrRkFBa0YsSUFBSTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0EsMkVBQTJFLElBQUk7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZLG1CQUFtQixPQUFPLEdBQUcsYUFBYSxHQUFHLEdBQUc7QUFDckYseUJBQXlCLFlBQVksbUJBQW1CLE9BQU8sR0FBRyxhQUFhO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixZQUFZLDJCQUEyQixPQUFPLEdBQUcsaUJBQWlCO0FBQzNGLHlCQUF5QixZQUFZLG1CQUFtQixPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZLGlCQUFpQixPQUFPLEdBQUcsS0FBSztBQUN6RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVksbUJBQW1CLE9BQU8sR0FBRyxLQUFLO0FBQzNGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWSxpQkFBaUIsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9qZXRzdHJlYW0vanNtY29uc3VtZXJfYXBpLmpzPzc4ZDEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29uc3VtZXJBUElJbXBsID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGpzYmFzZWNsaWVudF9hcGlfMSA9IHJlcXVpcmUoXCIuL2pzYmFzZWNsaWVudF9hcGlcIik7XG5jb25zdCBqc2xpc3Rlcl8xID0gcmVxdWlyZShcIi4vanNsaXN0ZXJcIik7XG5jb25zdCBqc3V0aWxfMSA9IHJlcXVpcmUoXCIuL2pzdXRpbFwiKTtcbmNvbnN0IHNlbXZlcl8xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvc2VtdmVyXCIpO1xuY29uc3QganNhcGlfdHlwZXNfMSA9IHJlcXVpcmUoXCIuL2pzYXBpX3R5cGVzXCIpO1xuY2xhc3MgQ29uc3VtZXJBUElJbXBsIGV4dGVuZHMganNiYXNlY2xpZW50X2FwaV8xLkJhc2VBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG5jLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKG5jLCBvcHRzKTtcbiAgICB9XG4gICAgYWRkKHN0cmVhbSwgY2ZnLCBhY3Rpb24gPSBqc2FwaV90eXBlc18xLkNvbnN1bWVyQXBpQWN0aW9uLkNyZWF0ZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICgwLCBqc3V0aWxfMS52YWxpZGF0ZVN0cmVhbU5hbWUpKHN0cmVhbSk7XG4gICAgICAgICAgICBpZiAoY2ZnLmRlbGl2ZXJfZ3JvdXAgJiYgY2ZnLmZsb3dfY29udHJvbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImpldHN0cmVhbSBmbG93IGNvbnRyb2wgaXMgbm90IHN1cHBvcnRlZCB3aXRoIHF1ZXVlIGdyb3Vwc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjZmcuZGVsaXZlcl9ncm91cCAmJiBjZmcuaWRsZV9oZWFydGJlYXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJqZXRzdHJlYW0gaWRsZSBoZWFydGJlYXQgaXMgbm90IHN1cHBvcnRlZCB3aXRoIHF1ZXVlIGdyb3Vwc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNyID0ge307XG4gICAgICAgICAgICBjci5jb25maWcgPSBjZmc7XG4gICAgICAgICAgICBjci5zdHJlYW1fbmFtZSA9IHN0cmVhbTtcbiAgICAgICAgICAgIGNyLmFjdGlvbiA9IGFjdGlvbjtcbiAgICAgICAgICAgIGlmIChjci5jb25maWcuZHVyYWJsZV9uYW1lKSB7XG4gICAgICAgICAgICAgICAgKDAsIGpzdXRpbF8xLnZhbGlkYXRlRHVyYWJsZU5hbWUpKGNyLmNvbmZpZy5kdXJhYmxlX25hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmNpID0gdGhpcy5uYztcbiAgICAgICAgICAgIGxldCB7IG1pbiwgb2s6IG5ld0FQSSB9ID0gbmNpLmZlYXR1cmVzLmdldChzZW12ZXJfMS5GZWF0dXJlLkpTX05FV19DT05TVU1FUl9DUkVBVEVfQVBJKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjZmcubmFtZSA9PT0gXCJcIiA/IHVuZGVmaW5lZCA6IGNmZy5uYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUgJiYgIW5ld0FQSSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uc3VtZXIgJ25hbWUnIHJlcXVpcmVzIHNlcnZlciAke21pbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIGpzdXRpbF8xLm1pblZhbGlkYXRpb24pKFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgY2Fubm90IGNvbnRhaW4gdGhlIG1lc3NhZ2UsIG1hc3NhZ2UgYSBiaXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbSA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZHggPSBtLmluZGV4T2YoXCJjYW5ub3QgY29udGFpblwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgY29uc3VtZXIgJ25hbWUnICR7bS5zdWJzdHJpbmcoaWR4KX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN1Ymo7XG4gICAgICAgICAgICBsZXQgY29uc3VtZXJOYW1lID0gXCJcIjtcbiAgICAgICAgICAgIC8vIG5ldyBhcGkgZG9lc24ndCBzdXBwb3J0IG11bHRpcGxlIGZpbHRlciBzdWJqZWN0c1xuICAgICAgICAgICAgLy8gdGhpcyBkZWxheWVkIHVudGlsIGhlcmUgYmVjYXVzZSB0aGUgY29uc3VtZXIgaW4gYW4gdXBkYXRlIGNvdWxkIGhhdmVcbiAgICAgICAgICAgIC8vIGJlZW4gY3JlYXRlZCB3aXRoIHRoZSBuZXcgQVBJLCBhbmQgaGF2ZSBhIGBuYW1lYFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2ZnLmZpbHRlcl9zdWJqZWN0cykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoc2VtdmVyXzEuRmVhdHVyZS5KU19NVUxUSVBMRV9DT05TVU1FUl9GSUxURVIpO1xuICAgICAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjb25zdW1lciAnZmlsdGVyX3N1YmplY3RzJyByZXF1aXJlcyBzZXJ2ZXIgJHttaW59YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld0FQSSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNmZy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbWluLCBvayB9ID0gbmNpLmZlYXR1cmVzLmdldChzZW12ZXJfMS5GZWF0dXJlLkpTX1NUUkVBTV9DT05TVU1FUl9NRVRBREFUQSk7XG4gICAgICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNvbnN1bWVyICdtZXRhZGF0YScgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdBUEkpIHtcbiAgICAgICAgICAgICAgICBjb25zdW1lck5hbWUgPSAoX2IgPSAoX2EgPSBjZmcubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2ZnLmR1cmFibGVfbmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25zdW1lck5hbWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZnMgPSAoX2MgPSBjZmcuZmlsdGVyX3N1YmplY3QpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoZnMgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJqID0gZnMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA/IGAke3RoaXMucHJlZml4fS5DT05TVU1FUi5DUkVBVEUuJHtzdHJlYW19LiR7Y29uc3VtZXJOYW1lfS4ke2ZzfWBcbiAgICAgICAgICAgICAgICAgICAgOiBgJHt0aGlzLnByZWZpeH0uQ09OU1VNRVIuQ1JFQVRFLiR7c3RyZWFtfS4ke2NvbnN1bWVyTmFtZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ViaiA9IGNmZy5kdXJhYmxlX25hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBgJHt0aGlzLnByZWZpeH0uQ09OU1VNRVIuRFVSQUJMRS5DUkVBVEUuJHtzdHJlYW19LiR7Y2ZnLmR1cmFibGVfbmFtZX1gXG4gICAgICAgICAgICAgICAgICAgIDogYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLkNSRUFURS4ke3N0cmVhbX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgciA9IHlpZWxkIHRoaXMuX3JlcXVlc3Qoc3ViaiwgY3IpO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUoc3RyZWFtLCBkdXJhYmxlLCBjZmcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNpID0geWllbGQgdGhpcy5pbmZvKHN0cmVhbSwgZHVyYWJsZSk7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2FibGUgPSBjZmc7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoc3RyZWFtLCBPYmplY3QuYXNzaWduKGNpLmNvbmZpZywgY2hhbmdhYmxlKSwganNhcGlfdHlwZXNfMS5Db25zdW1lckFwaUFjdGlvbi5VcGRhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5mbyhzdHJlYW0sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICgwLCBqc3V0aWxfMS52YWxpZGF0ZVN0cmVhbU5hbWUpKHN0cmVhbSk7XG4gICAgICAgICAgICAoMCwganN1dGlsXzEudmFsaWRhdGVEdXJhYmxlTmFtZSkobmFtZSk7XG4gICAgICAgICAgICBjb25zdCByID0geWllbGQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uQ09OU1VNRVIuSU5GTy4ke3N0cmVhbX0uJHtuYW1lfWApO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUoc3RyZWFtLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAoMCwganN1dGlsXzEudmFsaWRhdGVTdHJlYW1OYW1lKShzdHJlYW0pO1xuICAgICAgICAgICAgKDAsIGpzdXRpbF8xLnZhbGlkYXRlRHVyYWJsZU5hbWUpKG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgciA9IHlpZWxkIHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLkRFTEVURS4ke3N0cmVhbX0uJHtuYW1lfWApO1xuICAgICAgICAgICAgY29uc3QgY3IgPSByO1xuICAgICAgICAgICAgcmV0dXJuIGNyLnN1Y2Nlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsaXN0KHN0cmVhbSkge1xuICAgICAgICAoMCwganN1dGlsXzEudmFsaWRhdGVTdHJlYW1OYW1lKShzdHJlYW0pO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSAodikgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xyID0gdjtcbiAgICAgICAgICAgIHJldHVybiBjbHIuY29uc3VtZXJzO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWJqID0gYCR7dGhpcy5wcmVmaXh9LkNPTlNVTUVSLkxJU1QuJHtzdHJlYW19YDtcbiAgICAgICAgcmV0dXJuIG5ldyBqc2xpc3Rlcl8xLkxpc3RlckltcGwoc3ViaiwgZmlsdGVyLCB0aGlzKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnN1bWVyQVBJSW1wbCA9IENvbnN1bWVyQVBJSW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzbWNvbnN1bWVyX2FwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/jsmconsumer_api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/jsmsg.js":
/*!**************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/jsmsg.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JsMsgImpl = exports.parseInfo = exports.toJsMsg = exports.ACK = void 0;\n/*\n * Copyright 2021-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst databuffer_1 = __webpack_require__(/*! ../nats-base-client/databuffer */ \"(rsc)/./node_modules/nats/lib/nats-base-client/databuffer.js\");\nconst codec_1 = __webpack_require__(/*! ../nats-base-client/codec */ \"(rsc)/./node_modules/nats/lib/nats-base-client/codec.js\");\nconst request_1 = __webpack_require__(/*! ../nats-base-client/request */ \"(rsc)/./node_modules/nats/lib/nats-base-client/request.js\");\nconst jsutil_1 = __webpack_require__(/*! ./jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\nexports.ACK = Uint8Array.of(43, 65, 67, 75);\nconst NAK = Uint8Array.of(45, 78, 65, 75);\nconst WPI = Uint8Array.of(43, 87, 80, 73);\nconst NXT = Uint8Array.of(43, 78, 88, 84);\nconst TERM = Uint8Array.of(43, 84, 69, 82, 77);\nconst SPACE = Uint8Array.of(32);\nfunction toJsMsg(m) {\n    return new JsMsgImpl(m);\n}\nexports.toJsMsg = toJsMsg;\nfunction parseInfo(s) {\n    const tokens = s.split(\".\");\n    if (tokens.length === 9) {\n        tokens.splice(2, 0, \"_\", \"\");\n    }\n    if ((tokens.length < 11) || tokens[0] !== \"$JS\" || tokens[1] !== \"ACK\") {\n        throw new Error(`not js message`);\n    }\n    // old\n    // \"$JS.ACK.<stream>.<consumer>.<redeliveryCount><streamSeq><deliverySequence>.<timestamp>.<pending>\"\n    // new\n    // $JS.ACK.<domain>.<accounthash>.<stream>.<consumer>.<redeliveryCount>.<streamSeq>.<deliverySequence>.<timestamp>.<pending>.<random>\n    const di = {};\n    // if domain is \"_\", replace with blank\n    di.domain = tokens[2] === \"_\" ? \"\" : tokens[2];\n    di.account_hash = tokens[3];\n    di.stream = tokens[4];\n    di.consumer = tokens[5];\n    di.redeliveryCount = parseInt(tokens[6], 10);\n    di.redelivered = di.redeliveryCount > 1;\n    di.streamSequence = parseInt(tokens[7], 10);\n    di.deliverySequence = parseInt(tokens[8], 10);\n    di.timestampNanos = parseInt(tokens[9], 10);\n    di.pending = parseInt(tokens[10], 10);\n    return di;\n}\nexports.parseInfo = parseInfo;\nclass JsMsgImpl {\n    constructor(msg) {\n        this.msg = msg;\n        this.didAck = false;\n    }\n    get subject() {\n        return this.msg.subject;\n    }\n    get sid() {\n        return this.msg.sid;\n    }\n    get data() {\n        return this.msg.data;\n    }\n    get headers() {\n        return this.msg.headers;\n    }\n    get info() {\n        if (!this.di) {\n            this.di = parseInfo(this.reply);\n        }\n        return this.di;\n    }\n    get redelivered() {\n        return this.info.redeliveryCount > 1;\n    }\n    get reply() {\n        return this.msg.reply || \"\";\n    }\n    get seq() {\n        return this.info.streamSequence;\n    }\n    doAck(payload) {\n        if (!this.didAck) {\n            // all acks are final with the exception of +WPI\n            this.didAck = !this.isWIP(payload);\n            this.msg.respond(payload);\n        }\n    }\n    isWIP(p) {\n        return p.length === 4 && p[0] === WPI[0] && p[1] === WPI[1] &&\n            p[2] === WPI[2] && p[3] === WPI[3];\n    }\n    // this has to dig into the internals as the message has access\n    // to the protocol but not the high-level client.\n    ackAck() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.didAck) {\n                this.didAck = true;\n                if (this.msg.reply) {\n                    const mi = this.msg;\n                    const proto = mi.publisher;\n                    const trace = !(((_a = proto.options) === null || _a === void 0 ? void 0 : _a.noAsyncTraces) || false);\n                    const r = new request_1.RequestOne(proto.muxSubscriptions, this.msg.reply, {\n                        timeout: 1000,\n                    }, trace);\n                    proto.request(r);\n                    try {\n                        proto.publish(this.msg.reply, exports.ACK, {\n                            reply: `${proto.muxSubscriptions.baseInbox}${r.token}`,\n                        });\n                    }\n                    catch (err) {\n                        r.cancel(err);\n                    }\n                    try {\n                        yield Promise.race([r.timer, r.deferred]);\n                        return true;\n                    }\n                    catch (err) {\n                        r.cancel(err);\n                    }\n                }\n            }\n            return false;\n        });\n    }\n    ack() {\n        this.doAck(exports.ACK);\n    }\n    nak(millis) {\n        let payload = NAK;\n        if (millis) {\n            payload = (0, codec_1.StringCodec)().encode(`-NAK ${JSON.stringify({ delay: (0, jsutil_1.nanos)(millis) })}`);\n        }\n        this.doAck(payload);\n    }\n    working() {\n        this.doAck(WPI);\n    }\n    next(subj, opts = { batch: 1 }) {\n        const args = {};\n        args.batch = opts.batch || 1;\n        args.no_wait = opts.no_wait || false;\n        if (opts.expires && opts.expires > 0) {\n            args.expires = (0, jsutil_1.nanos)(opts.expires);\n        }\n        const data = (0, codec_1.JSONCodec)().encode(args);\n        const payload = databuffer_1.DataBuffer.concat(NXT, SPACE, data);\n        const reqOpts = subj ? { reply: subj } : undefined;\n        this.msg.respond(payload, reqOpts);\n    }\n    term(reason = \"\") {\n        let term = TERM;\n        if ((reason === null || reason === void 0 ? void 0 : reason.length) > 0) {\n            term = (0, codec_1.StringCodec)().encode(`+TERM ${reason}`);\n        }\n        this.doAck(term);\n    }\n    json() {\n        return this.msg.json();\n    }\n    string() {\n        return this.msg.string();\n    }\n}\nexports.JsMsgImpl = JsMsgImpl;\n//# sourceMappingURL=jsmsg.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzbXNnLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsV0FBVztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsb0dBQWdDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLDBGQUEyQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBNkI7QUFDdkQsaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkMsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxpQ0FBaUMsRUFBRSxRQUFRO0FBQ2pGLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlCQUFpQixvQ0FBb0MsRUFBRTtBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzbXNnLmpzPzhlNjAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSnNNc2dJbXBsID0gZXhwb3J0cy5wYXJzZUluZm8gPSBleHBvcnRzLnRvSnNNc2cgPSBleHBvcnRzLkFDSyA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBOQVRTIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBkYXRhYnVmZmVyXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9kYXRhYnVmZmVyXCIpO1xuY29uc3QgY29kZWNfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L2NvZGVjXCIpO1xuY29uc3QgcmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvcmVxdWVzdFwiKTtcbmNvbnN0IGpzdXRpbF8xID0gcmVxdWlyZShcIi4vanN1dGlsXCIpO1xuZXhwb3J0cy5BQ0sgPSBVaW50OEFycmF5Lm9mKDQzLCA2NSwgNjcsIDc1KTtcbmNvbnN0IE5BSyA9IFVpbnQ4QXJyYXkub2YoNDUsIDc4LCA2NSwgNzUpO1xuY29uc3QgV1BJID0gVWludDhBcnJheS5vZig0MywgODcsIDgwLCA3Myk7XG5jb25zdCBOWFQgPSBVaW50OEFycmF5Lm9mKDQzLCA3OCwgODgsIDg0KTtcbmNvbnN0IFRFUk0gPSBVaW50OEFycmF5Lm9mKDQzLCA4NCwgNjksIDgyLCA3Nyk7XG5jb25zdCBTUEFDRSA9IFVpbnQ4QXJyYXkub2YoMzIpO1xuZnVuY3Rpb24gdG9Kc01zZyhtKSB7XG4gICAgcmV0dXJuIG5ldyBKc01zZ0ltcGwobSk7XG59XG5leHBvcnRzLnRvSnNNc2cgPSB0b0pzTXNnO1xuZnVuY3Rpb24gcGFyc2VJbmZvKHMpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBzLnNwbGl0KFwiLlwiKTtcbiAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gOSkge1xuICAgICAgICB0b2tlbnMuc3BsaWNlKDIsIDAsIFwiX1wiLCBcIlwiKTtcbiAgICB9XG4gICAgaWYgKCh0b2tlbnMubGVuZ3RoIDwgMTEpIHx8IHRva2Vuc1swXSAhPT0gXCIkSlNcIiB8fCB0b2tlbnNbMV0gIT09IFwiQUNLXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBub3QganMgbWVzc2FnZWApO1xuICAgIH1cbiAgICAvLyBvbGRcbiAgICAvLyBcIiRKUy5BQ0suPHN0cmVhbT4uPGNvbnN1bWVyPi48cmVkZWxpdmVyeUNvdW50PjxzdHJlYW1TZXE+PGRlbGl2ZXJ5U2VxdWVuY2U+Ljx0aW1lc3RhbXA+LjxwZW5kaW5nPlwiXG4gICAgLy8gbmV3XG4gICAgLy8gJEpTLkFDSy48ZG9tYWluPi48YWNjb3VudGhhc2g+LjxzdHJlYW0+Ljxjb25zdW1lcj4uPHJlZGVsaXZlcnlDb3VudD4uPHN0cmVhbVNlcT4uPGRlbGl2ZXJ5U2VxdWVuY2U+Ljx0aW1lc3RhbXA+LjxwZW5kaW5nPi48cmFuZG9tPlxuICAgIGNvbnN0IGRpID0ge307XG4gICAgLy8gaWYgZG9tYWluIGlzIFwiX1wiLCByZXBsYWNlIHdpdGggYmxhbmtcbiAgICBkaS5kb21haW4gPSB0b2tlbnNbMl0gPT09IFwiX1wiID8gXCJcIiA6IHRva2Vuc1syXTtcbiAgICBkaS5hY2NvdW50X2hhc2ggPSB0b2tlbnNbM107XG4gICAgZGkuc3RyZWFtID0gdG9rZW5zWzRdO1xuICAgIGRpLmNvbnN1bWVyID0gdG9rZW5zWzVdO1xuICAgIGRpLnJlZGVsaXZlcnlDb3VudCA9IHBhcnNlSW50KHRva2Vuc1s2XSwgMTApO1xuICAgIGRpLnJlZGVsaXZlcmVkID0gZGkucmVkZWxpdmVyeUNvdW50ID4gMTtcbiAgICBkaS5zdHJlYW1TZXF1ZW5jZSA9IHBhcnNlSW50KHRva2Vuc1s3XSwgMTApO1xuICAgIGRpLmRlbGl2ZXJ5U2VxdWVuY2UgPSBwYXJzZUludCh0b2tlbnNbOF0sIDEwKTtcbiAgICBkaS50aW1lc3RhbXBOYW5vcyA9IHBhcnNlSW50KHRva2Vuc1s5XSwgMTApO1xuICAgIGRpLnBlbmRpbmcgPSBwYXJzZUludCh0b2tlbnNbMTBdLCAxMCk7XG4gICAgcmV0dXJuIGRpO1xufVxuZXhwb3J0cy5wYXJzZUluZm8gPSBwYXJzZUluZm87XG5jbGFzcyBKc01zZ0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICB0aGlzLm1zZyA9IG1zZztcbiAgICAgICAgdGhpcy5kaWRBY2sgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5zdWJqZWN0O1xuICAgIH1cbiAgICBnZXQgc2lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuc2lkO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLmRhdGE7XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuaGVhZGVycztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIGlmICghdGhpcy5kaSkge1xuICAgICAgICAgICAgdGhpcy5kaSA9IHBhcnNlSW5mbyh0aGlzLnJlcGx5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaTtcbiAgICB9XG4gICAgZ2V0IHJlZGVsaXZlcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLnJlZGVsaXZlcnlDb3VudCA+IDE7XG4gICAgfVxuICAgIGdldCByZXBseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLnJlcGx5IHx8IFwiXCI7XG4gICAgfVxuICAgIGdldCBzZXEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uc3RyZWFtU2VxdWVuY2U7XG4gICAgfVxuICAgIGRvQWNrKHBheWxvYWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpZEFjaykge1xuICAgICAgICAgICAgLy8gYWxsIGFja3MgYXJlIGZpbmFsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiArV1BJXG4gICAgICAgICAgICB0aGlzLmRpZEFjayA9ICF0aGlzLmlzV0lQKHBheWxvYWQpO1xuICAgICAgICAgICAgdGhpcy5tc2cucmVzcG9uZChwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1dJUChwKSB7XG4gICAgICAgIHJldHVybiBwLmxlbmd0aCA9PT0gNCAmJiBwWzBdID09PSBXUElbMF0gJiYgcFsxXSA9PT0gV1BJWzFdICYmXG4gICAgICAgICAgICBwWzJdID09PSBXUElbMl0gJiYgcFszXSA9PT0gV1BJWzNdO1xuICAgIH1cbiAgICAvLyB0aGlzIGhhcyB0byBkaWcgaW50byB0aGUgaW50ZXJuYWxzIGFzIHRoZSBtZXNzYWdlIGhhcyBhY2Nlc3NcbiAgICAvLyB0byB0aGUgcHJvdG9jb2wgYnV0IG5vdCB0aGUgaGlnaC1sZXZlbCBjbGllbnQuXG4gICAgYWNrQWNrKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlkQWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWRBY2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1zZy5yZXBseSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtaSA9IHRoaXMubXNnO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm90byA9IG1pLnB1Ymxpc2hlcjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2UgPSAhKCgoX2EgPSBwcm90by5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9Bc3luY1RyYWNlcykgfHwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gbmV3IHJlcXVlc3RfMS5SZXF1ZXN0T25lKHByb3RvLm11eFN1YnNjcmlwdGlvbnMsIHRoaXMubXNnLnJlcGx5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAxMDAwLFxuICAgICAgICAgICAgICAgICAgICB9LCB0cmFjZSk7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLnJlcXVlc3Qocik7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm90by5wdWJsaXNoKHRoaXMubXNnLnJlcGx5LCBleHBvcnRzLkFDSywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGx5OiBgJHtwcm90by5tdXhTdWJzY3JpcHRpb25zLmJhc2VJbmJveH0ke3IudG9rZW59YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIuY2FuY2VsKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UucmFjZShbci50aW1lciwgci5kZWZlcnJlZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgci5jYW5jZWwoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFjaygpIHtcbiAgICAgICAgdGhpcy5kb0FjayhleHBvcnRzLkFDSyk7XG4gICAgfVxuICAgIG5hayhtaWxsaXMpIHtcbiAgICAgICAgbGV0IHBheWxvYWQgPSBOQUs7XG4gICAgICAgIGlmIChtaWxsaXMpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSAoMCwgY29kZWNfMS5TdHJpbmdDb2RlYykoKS5lbmNvZGUoYC1OQUsgJHtKU09OLnN0cmluZ2lmeSh7IGRlbGF5OiAoMCwganN1dGlsXzEubmFub3MpKG1pbGxpcykgfSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb0FjayhwYXlsb2FkKTtcbiAgICB9XG4gICAgd29ya2luZygpIHtcbiAgICAgICAgdGhpcy5kb0FjayhXUEkpO1xuICAgIH1cbiAgICBuZXh0KHN1YmosIG9wdHMgPSB7IGJhdGNoOiAxIH0pIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHt9O1xuICAgICAgICBhcmdzLmJhdGNoID0gb3B0cy5iYXRjaCB8fCAxO1xuICAgICAgICBhcmdzLm5vX3dhaXQgPSBvcHRzLm5vX3dhaXQgfHwgZmFsc2U7XG4gICAgICAgIGlmIChvcHRzLmV4cGlyZXMgJiYgb3B0cy5leHBpcmVzID4gMCkge1xuICAgICAgICAgICAgYXJncy5leHBpcmVzID0gKDAsIGpzdXRpbF8xLm5hbm9zKShvcHRzLmV4cGlyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgY29kZWNfMS5KU09OQ29kZWMpKCkuZW5jb2RlKGFyZ3MpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YWJ1ZmZlcl8xLkRhdGFCdWZmZXIuY29uY2F0KE5YVCwgU1BBQ0UsIGRhdGEpO1xuICAgICAgICBjb25zdCByZXFPcHRzID0gc3ViaiA/IHsgcmVwbHk6IHN1YmogfSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tc2cucmVzcG9uZChwYXlsb2FkLCByZXFPcHRzKTtcbiAgICB9XG4gICAgdGVybShyZWFzb24gPSBcIlwiKSB7XG4gICAgICAgIGxldCB0ZXJtID0gVEVSTTtcbiAgICAgICAgaWYgKChyZWFzb24gPT09IG51bGwgfHwgcmVhc29uID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWFzb24ubGVuZ3RoKSA+IDApIHtcbiAgICAgICAgICAgIHRlcm0gPSAoMCwgY29kZWNfMS5TdHJpbmdDb2RlYykoKS5lbmNvZGUoYCtURVJNICR7cmVhc29ufWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9BY2sodGVybSk7XG4gICAgfVxuICAgIGpzb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5qc29uKCk7XG4gICAgfVxuICAgIHN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLnN0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSnNNc2dJbXBsID0gSnNNc2dJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNtc2cuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/jsmsg.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/jsmstream_api.js":
/*!**********************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/jsmstream_api.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2021-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StreamsImpl = exports.StoredMsgImpl = exports.StreamAPIImpl = exports.StreamImpl = exports.ConsumersImpl = exports.convertStreamSourceDomain = void 0;\nconst types_1 = __webpack_require__(/*! ../nats-base-client/types */ \"(rsc)/./node_modules/nats/lib/nats-base-client/types.js\");\nconst jsbaseclient_api_1 = __webpack_require__(/*! ./jsbaseclient_api */ \"(rsc)/./node_modules/nats/lib/jetstream/jsbaseclient_api.js\");\nconst jslister_1 = __webpack_require__(/*! ./jslister */ \"(rsc)/./node_modules/nats/lib/jetstream/jslister.js\");\nconst jsutil_1 = __webpack_require__(/*! ./jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\nconst headers_1 = __webpack_require__(/*! ../nats-base-client/headers */ \"(rsc)/./node_modules/nats/lib/nats-base-client/headers.js\");\nconst kv_1 = __webpack_require__(/*! ./kv */ \"(rsc)/./node_modules/nats/lib/jetstream/kv.js\");\nconst objectstore_1 = __webpack_require__(/*! ./objectstore */ \"(rsc)/./node_modules/nats/lib/jetstream/objectstore.js\");\nconst codec_1 = __webpack_require__(/*! ../nats-base-client/codec */ \"(rsc)/./node_modules/nats/lib/nats-base-client/codec.js\");\nconst encoders_1 = __webpack_require__(/*! ../nats-base-client/encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst semver_1 = __webpack_require__(/*! ../nats-base-client/semver */ \"(rsc)/./node_modules/nats/lib/nats-base-client/semver.js\");\nconst types_2 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/nats/lib/jetstream/types.js\");\nconst consumer_1 = __webpack_require__(/*! ./consumer */ \"(rsc)/./node_modules/nats/lib/jetstream/consumer.js\");\nconst jsmconsumer_api_1 = __webpack_require__(/*! ./jsmconsumer_api */ \"(rsc)/./node_modules/nats/lib/jetstream/jsmconsumer_api.js\");\nfunction convertStreamSourceDomain(s) {\n    if (s === undefined) {\n        return undefined;\n    }\n    const { domain } = s;\n    if (domain === undefined) {\n        return s;\n    }\n    const copy = Object.assign({}, s);\n    delete copy.domain;\n    if (domain === \"\") {\n        return copy;\n    }\n    if (copy.external) {\n        throw new Error(\"domain and external are both set\");\n    }\n    copy.external = { api: `$JS.${domain}.API` };\n    return copy;\n}\nexports.convertStreamSourceDomain = convertStreamSourceDomain;\nclass ConsumersImpl {\n    constructor(api) {\n        this.api = api;\n        this.notified = false;\n    }\n    checkVersion() {\n        const fv = this.api.nc.features.get(semver_1.Feature.JS_SIMPLIFICATION);\n        if (!fv.ok) {\n            return Promise.reject(new Error(`consumers framework is only supported on servers ${fv.min} or better`));\n        }\n        return Promise.resolve();\n    }\n    get(stream, name = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof name === \"object\") {\n                return this.ordered(stream, name);\n            }\n            // check we have support for pending msgs and header notifications\n            yield this.checkVersion();\n            return this.api.info(stream, name)\n                .then((ci) => {\n                if (ci.config.deliver_subject !== undefined) {\n                    return Promise.reject(new Error(\"push consumer not supported\"));\n                }\n                return new consumer_1.PullConsumerImpl(this.api, ci);\n            })\n                .catch((err) => {\n                return Promise.reject(err);\n            });\n        });\n    }\n    ordered(stream, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.checkVersion();\n            const impl = this.api;\n            const sapi = new StreamAPIImpl(impl.nc, impl.opts);\n            return sapi.info(stream)\n                .then((_si) => {\n                return Promise.resolve(new consumer_1.OrderedPullConsumerImpl(this.api, stream, opts));\n            })\n                .catch((err) => {\n                return Promise.reject(err);\n            });\n        });\n    }\n}\nexports.ConsumersImpl = ConsumersImpl;\nclass StreamImpl {\n    constructor(api, info) {\n        this.api = api;\n        this._info = info;\n    }\n    get name() {\n        return this._info.config.name;\n    }\n    alternates() {\n        return this.info()\n            .then((si) => {\n            return si.alternates ? si.alternates : [];\n        });\n    }\n    best() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.info();\n            if (this._info.alternates) {\n                const asi = yield this.api.info(this._info.alternates[0].name);\n                return new StreamImpl(this.api, asi);\n            }\n            else {\n                return this;\n            }\n        });\n    }\n    info(cached = false, opts) {\n        if (cached) {\n            return Promise.resolve(this._info);\n        }\n        return this.api.info(this.name, opts)\n            .then((si) => {\n            this._info = si;\n            return this._info;\n        });\n    }\n    getConsumer(name) {\n        return new ConsumersImpl(new jsmconsumer_api_1.ConsumerAPIImpl(this.api.nc, this.api.opts))\n            .get(this.name, name);\n    }\n    getMessage(query) {\n        return this.api.getMessage(this.name, query);\n    }\n    deleteMessage(seq, erase) {\n        return this.api.deleteMessage(this.name, seq, erase);\n    }\n}\nexports.StreamImpl = StreamImpl;\nclass StreamAPIImpl extends jsbaseclient_api_1.BaseApiClient {\n    constructor(nc, opts) {\n        super(nc, opts);\n    }\n    checkStreamConfigVersions(cfg) {\n        const nci = this.nc;\n        if (cfg.metadata) {\n            const { min, ok } = nci.features.get(semver_1.Feature.JS_STREAM_CONSUMER_METADATA);\n            if (!ok) {\n                throw new Error(`stream 'metadata' requires server ${min}`);\n            }\n        }\n        if (cfg.first_seq) {\n            const { min, ok } = nci.features.get(semver_1.Feature.JS_STREAM_FIRST_SEQ);\n            if (!ok) {\n                throw new Error(`stream 'first_seq' requires server ${min}`);\n            }\n        }\n        if (cfg.subject_transform) {\n            const { min, ok } = nci.features.get(semver_1.Feature.JS_STREAM_SUBJECT_TRANSFORM);\n            if (!ok) {\n                throw new Error(`stream 'subject_transform' requires server ${min}`);\n            }\n        }\n        if (cfg.compression) {\n            const { min, ok } = nci.features.get(semver_1.Feature.JS_STREAM_COMPRESSION);\n            if (!ok) {\n                throw new Error(`stream 'compression' requires server ${min}`);\n            }\n        }\n        if (cfg.consumer_limits) {\n            const { min, ok } = nci.features.get(semver_1.Feature.JS_DEFAULT_CONSUMER_LIMITS);\n            if (!ok) {\n                throw new Error(`stream 'consumer_limits' requires server ${min}`);\n            }\n        }\n        function validateStreamSource(context, src) {\n            var _a;\n            const count = ((_a = src.subject_transforms) === null || _a === void 0 ? void 0 : _a.length) || 0;\n            if (count > 0) {\n                const { min, ok } = nci.features.get(semver_1.Feature.JS_STREAM_SOURCE_SUBJECT_TRANSFORM);\n                if (!ok) {\n                    throw new Error(`${context} 'subject_transforms' requires server ${min}`);\n                }\n            }\n        }\n        if (cfg.sources) {\n            cfg.sources.forEach((src) => {\n                validateStreamSource(\"stream sources\", src);\n            });\n        }\n        if (cfg.mirror) {\n            validateStreamSource(\"stream mirror\", cfg.mirror);\n        }\n    }\n    add(cfg = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            this.checkStreamConfigVersions(cfg);\n            (0, jsutil_1.validateStreamName)(cfg.name);\n            cfg.mirror = convertStreamSourceDomain(cfg.mirror);\n            //@ts-ignore: the sources are either set or not - so no item should be undefined in the list\n            cfg.sources = (_a = cfg.sources) === null || _a === void 0 ? void 0 : _a.map(convertStreamSourceDomain);\n            const r = yield this._request(`${this.prefix}.STREAM.CREATE.${cfg.name}`, cfg);\n            const si = r;\n            this._fixInfo(si);\n            return si;\n        });\n    }\n    delete(stream) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, jsutil_1.validateStreamName)(stream);\n            const r = yield this._request(`${this.prefix}.STREAM.DELETE.${stream}`);\n            const cr = r;\n            return cr.success;\n        });\n    }\n    update(name, cfg = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (typeof name === \"object\") {\n                const sc = name;\n                name = sc.name;\n                cfg = sc;\n                console.trace(`\\u001B[33m >> streams.update(config: StreamConfig) api changed to streams.update(name: string, config: StreamUpdateConfig) - this shim will be removed - update your code.  \\u001B[0m`);\n            }\n            this.checkStreamConfigVersions(cfg);\n            (0, jsutil_1.validateStreamName)(name);\n            const old = yield this.info(name);\n            const update = Object.assign(old.config, cfg);\n            update.mirror = convertStreamSourceDomain(update.mirror);\n            //@ts-ignore: the sources are either set or not - so no item should be undefined in the list\n            update.sources = (_a = update.sources) === null || _a === void 0 ? void 0 : _a.map(convertStreamSourceDomain);\n            const r = yield this._request(`${this.prefix}.STREAM.UPDATE.${name}`, update);\n            const si = r;\n            this._fixInfo(si);\n            return si;\n        });\n    }\n    info(name, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, jsutil_1.validateStreamName)(name);\n            const subj = `${this.prefix}.STREAM.INFO.${name}`;\n            const r = yield this._request(subj, data);\n            let si = r;\n            let { total, limit } = si;\n            // check how many subjects we got in the first request\n            let have = si.state.subjects\n                ? Object.getOwnPropertyNames(si.state.subjects).length\n                : 1;\n            // if the response is paged, we have a large list of subjects\n            // handle the paging and return a StreamInfo with all of it\n            if (total && total > have) {\n                const infos = [si];\n                const paged = data || {};\n                let i = 0;\n                // total could change, so it is possible to have collected\n                // more that the total\n                while (total > have) {\n                    i++;\n                    paged.offset = limit * i;\n                    const r = yield this._request(subj, paged);\n                    // update it in case it changed\n                    total = r.total;\n                    infos.push(r);\n                    const count = Object.getOwnPropertyNames(r.state.subjects).length;\n                    have += count;\n                    // if request returns less than limit it is done\n                    if (count < limit) {\n                        // done\n                        break;\n                    }\n                }\n                // collect all the subjects\n                let subjects = {};\n                for (let i = 0; i < infos.length; i++) {\n                    si = infos[i];\n                    if (si.state.subjects) {\n                        subjects = Object.assign(subjects, si.state.subjects);\n                    }\n                }\n                // don't give the impression we paged\n                si.offset = 0;\n                si.total = 0;\n                si.limit = 0;\n                si.state.subjects = subjects;\n            }\n            this._fixInfo(si);\n            return si;\n        });\n    }\n    list(subject = \"\") {\n        const payload = (subject === null || subject === void 0 ? void 0 : subject.length) ? { subject } : {};\n        const listerFilter = (v) => {\n            const slr = v;\n            slr.streams.forEach((si) => {\n                this._fixInfo(si);\n            });\n            return slr.streams;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new jslister_1.ListerImpl(subj, listerFilter, this, payload);\n    }\n    // FIXME: init of sealed, deny_delete, deny_purge shouldn't be necessary\n    //  https://github.com/nats-io/nats-server/issues/2633\n    _fixInfo(si) {\n        si.config.sealed = si.config.sealed || false;\n        si.config.deny_delete = si.config.deny_delete || false;\n        si.config.deny_purge = si.config.deny_purge || false;\n        si.config.allow_rollup_hdrs = si.config.allow_rollup_hdrs || false;\n    }\n    purge(name, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (opts) {\n                const { keep, seq } = opts;\n                if (typeof keep === \"number\" && typeof seq === \"number\") {\n                    throw new Error(\"can specify one of keep or seq\");\n                }\n            }\n            (0, jsutil_1.validateStreamName)(name);\n            const v = yield this._request(`${this.prefix}.STREAM.PURGE.${name}`, opts);\n            return v;\n        });\n    }\n    deleteMessage(stream, seq, erase = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, jsutil_1.validateStreamName)(stream);\n            const dr = { seq };\n            if (!erase) {\n                dr.no_erase = true;\n            }\n            const r = yield this._request(`${this.prefix}.STREAM.MSG.DELETE.${stream}`, dr);\n            const cr = r;\n            return cr.success;\n        });\n    }\n    getMessage(stream, query) {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, jsutil_1.validateStreamName)(stream);\n            const r = yield this._request(`${this.prefix}.STREAM.MSG.GET.${stream}`, query);\n            const sm = r;\n            return new StoredMsgImpl(sm);\n        });\n    }\n    find(subject) {\n        return this.findStream(subject);\n    }\n    listKvs() {\n        const filter = (v) => {\n            var _a, _b;\n            const slr = v;\n            const kvStreams = slr.streams.filter((v) => {\n                return v.config.name.startsWith(types_2.kvPrefix);\n            });\n            kvStreams.forEach((si) => {\n                this._fixInfo(si);\n            });\n            let cluster = \"\";\n            if (kvStreams.length) {\n                cluster = (_b = (_a = this.nc.info) === null || _a === void 0 ? void 0 : _a.cluster) !== null && _b !== void 0 ? _b : \"\";\n            }\n            const status = kvStreams.map((si) => {\n                return new kv_1.KvStatusImpl(si, cluster);\n            });\n            return status;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new jslister_1.ListerImpl(subj, filter, this);\n    }\n    listObjectStores() {\n        const filter = (v) => {\n            const slr = v;\n            const objStreams = slr.streams.filter((v) => {\n                return v.config.name.startsWith(objectstore_1.osPrefix);\n            });\n            objStreams.forEach((si) => {\n                this._fixInfo(si);\n            });\n            const status = objStreams.map((si) => {\n                return new objectstore_1.ObjectStoreStatusImpl(si);\n            });\n            return status;\n        };\n        const subj = `${this.prefix}.STREAM.LIST`;\n        return new jslister_1.ListerImpl(subj, filter, this);\n    }\n    names(subject = \"\") {\n        const payload = (subject === null || subject === void 0 ? void 0 : subject.length) ? { subject } : {};\n        const listerFilter = (v) => {\n            const sr = v;\n            return sr.streams;\n        };\n        const subj = `${this.prefix}.STREAM.NAMES`;\n        return new jslister_1.ListerImpl(subj, listerFilter, this, payload);\n    }\n    get(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const si = yield this.info(name);\n            return Promise.resolve(new StreamImpl(this, si));\n        });\n    }\n}\nexports.StreamAPIImpl = StreamAPIImpl;\nclass StoredMsgImpl {\n    constructor(smr) {\n        this.smr = smr;\n    }\n    get subject() {\n        return this.smr.message.subject;\n    }\n    get seq() {\n        return this.smr.message.seq;\n    }\n    get timestamp() {\n        return this.smr.message.time;\n    }\n    get time() {\n        return new Date(Date.parse(this.timestamp));\n    }\n    get data() {\n        return this.smr.message.data ? this._parse(this.smr.message.data) : types_1.Empty;\n    }\n    get header() {\n        if (!this._header) {\n            if (this.smr.message.hdrs) {\n                const hd = this._parse(this.smr.message.hdrs);\n                this._header = headers_1.MsgHdrsImpl.decode(hd);\n            }\n            else {\n                this._header = (0, headers_1.headers)();\n            }\n        }\n        return this._header;\n    }\n    _parse(s) {\n        const bs = atob(s);\n        const len = bs.length;\n        const bytes = new Uint8Array(len);\n        for (let i = 0; i < len; i++) {\n            bytes[i] = bs.charCodeAt(i);\n        }\n        return bytes;\n    }\n    json(reviver) {\n        return (0, codec_1.JSONCodec)(reviver).decode(this.data);\n    }\n    string() {\n        return encoders_1.TD.decode(this.data);\n    }\n}\nexports.StoredMsgImpl = StoredMsgImpl;\nclass StreamsImpl {\n    constructor(api) {\n        this.api = api;\n    }\n    get(stream) {\n        return this.api.info(stream)\n            .then((si) => {\n            return new StreamImpl(this.api, si);\n        });\n    }\n}\nexports.StreamsImpl = StreamsImpl;\n//# sourceMappingURL=jsmstream_api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzbXN0cmVhbV9hcGkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxrQkFBa0IsR0FBRyxxQkFBcUIsR0FBRyxpQ0FBaUM7QUFDcEosZ0JBQWdCLG1CQUFPLENBQUMsMEZBQTJCO0FBQ25ELDJCQUEyQixtQkFBTyxDQUFDLHVGQUFvQjtBQUN2RCxtQkFBbUIsbUJBQU8sQ0FBQyx1RUFBWTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxtRUFBVTtBQUNuQyxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBNkI7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLDJEQUFNO0FBQzNCLHNCQUFzQixtQkFBTyxDQUFDLDZFQUFlO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLDBGQUEyQjtBQUNuRCxtQkFBbUIsbUJBQU8sQ0FBQyxnR0FBOEI7QUFDekQsaUJBQWlCLG1CQUFPLENBQUMsNEZBQTRCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLGlFQUFTO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLHVFQUFZO0FBQ3ZDLDBCQUEwQixtQkFBTyxDQUFDLHFGQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9qZXRzdHJlYW0vanNtc3RyZWFtX2FwaS5qcz9lZDYxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxLTIwMjMgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJlYW1zSW1wbCA9IGV4cG9ydHMuU3RvcmVkTXNnSW1wbCA9IGV4cG9ydHMuU3RyZWFtQVBJSW1wbCA9IGV4cG9ydHMuU3RyZWFtSW1wbCA9IGV4cG9ydHMuQ29uc3VtZXJzSW1wbCA9IGV4cG9ydHMuY29udmVydFN0cmVhbVNvdXJjZURvbWFpbiA9IHZvaWQgMDtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC90eXBlc1wiKTtcbmNvbnN0IGpzYmFzZWNsaWVudF9hcGlfMSA9IHJlcXVpcmUoXCIuL2pzYmFzZWNsaWVudF9hcGlcIik7XG5jb25zdCBqc2xpc3Rlcl8xID0gcmVxdWlyZShcIi4vanNsaXN0ZXJcIik7XG5jb25zdCBqc3V0aWxfMSA9IHJlcXVpcmUoXCIuL2pzdXRpbFwiKTtcbmNvbnN0IGhlYWRlcnNfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L2hlYWRlcnNcIik7XG5jb25zdCBrdl8xID0gcmVxdWlyZShcIi4va3ZcIik7XG5jb25zdCBvYmplY3RzdG9yZV8xID0gcmVxdWlyZShcIi4vb2JqZWN0c3RvcmVcIik7XG5jb25zdCBjb2RlY18xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvY29kZWNcIik7XG5jb25zdCBlbmNvZGVyc18xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvZW5jb2RlcnNcIik7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3NlbXZlclwiKTtcbmNvbnN0IHR5cGVzXzIgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IGNvbnN1bWVyXzEgPSByZXF1aXJlKFwiLi9jb25zdW1lclwiKTtcbmNvbnN0IGpzbWNvbnN1bWVyX2FwaV8xID0gcmVxdWlyZShcIi4vanNtY29uc3VtZXJfYXBpXCIpO1xuZnVuY3Rpb24gY29udmVydFN0cmVhbVNvdXJjZURvbWFpbihzKSB7XG4gICAgaWYgKHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB7IGRvbWFpbiB9ID0gcztcbiAgICBpZiAoZG9tYWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBzKTtcbiAgICBkZWxldGUgY29weS5kb21haW47XG4gICAgaWYgKGRvbWFpbiA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgaWYgKGNvcHkuZXh0ZXJuYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZG9tYWluIGFuZCBleHRlcm5hbCBhcmUgYm90aCBzZXRcIik7XG4gICAgfVxuICAgIGNvcHkuZXh0ZXJuYWwgPSB7IGFwaTogYCRKUy4ke2RvbWFpbn0uQVBJYCB9O1xuICAgIHJldHVybiBjb3B5O1xufVxuZXhwb3J0cy5jb252ZXJ0U3RyZWFtU291cmNlRG9tYWluID0gY29udmVydFN0cmVhbVNvdXJjZURvbWFpbjtcbmNsYXNzIENvbnN1bWVyc0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKGFwaSkge1xuICAgICAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICAgICAgdGhpcy5ub3RpZmllZCA9IGZhbHNlO1xuICAgIH1cbiAgICBjaGVja1ZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IGZ2ID0gdGhpcy5hcGkubmMuZmVhdHVyZXMuZ2V0KHNlbXZlcl8xLkZlYXR1cmUuSlNfU0lNUExJRklDQVRJT04pO1xuICAgICAgICBpZiAoIWZ2Lm9rKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBjb25zdW1lcnMgZnJhbWV3b3JrIGlzIG9ubHkgc3VwcG9ydGVkIG9uIHNlcnZlcnMgJHtmdi5taW59IG9yIGJldHRlcmApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGdldChzdHJlYW0sIG5hbWUgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JkZXJlZChzdHJlYW0sIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2hlY2sgd2UgaGF2ZSBzdXBwb3J0IGZvciBwZW5kaW5nIG1zZ3MgYW5kIGhlYWRlciBub3RpZmljYXRpb25zXG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNoZWNrVmVyc2lvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmluZm8oc3RyZWFtLCBuYW1lKVxuICAgICAgICAgICAgICAgIC50aGVuKChjaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjaS5jb25maWcuZGVsaXZlcl9zdWJqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInB1c2ggY29uc3VtZXIgbm90IHN1cHBvcnRlZFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgY29uc3VtZXJfMS5QdWxsQ29uc3VtZXJJbXBsKHRoaXMuYXBpLCBjaSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9yZGVyZWQoc3RyZWFtLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNoZWNrVmVyc2lvbigpO1xuICAgICAgICAgICAgY29uc3QgaW1wbCA9IHRoaXMuYXBpO1xuICAgICAgICAgICAgY29uc3Qgc2FwaSA9IG5ldyBTdHJlYW1BUElJbXBsKGltcGwubmMsIGltcGwub3B0cyk7XG4gICAgICAgICAgICByZXR1cm4gc2FwaS5pbmZvKHN0cmVhbSlcbiAgICAgICAgICAgICAgICAudGhlbigoX3NpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgY29uc3VtZXJfMS5PcmRlcmVkUHVsbENvbnN1bWVySW1wbCh0aGlzLmFwaSwgc3RyZWFtLCBvcHRzKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db25zdW1lcnNJbXBsID0gQ29uc3VtZXJzSW1wbDtcbmNsYXNzIFN0cmVhbUltcGwge1xuICAgIGNvbnN0cnVjdG9yKGFwaSwgaW5mbykge1xuICAgICAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICAgICAgdGhpcy5faW5mbyA9IGluZm87XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5mby5jb25maWcubmFtZTtcbiAgICB9XG4gICAgYWx0ZXJuYXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mbygpXG4gICAgICAgICAgICAudGhlbigoc2kpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzaS5hbHRlcm5hdGVzID8gc2kuYWx0ZXJuYXRlcyA6IFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmVzdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuaW5mbygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZm8uYWx0ZXJuYXRlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFzaSA9IHlpZWxkIHRoaXMuYXBpLmluZm8odGhpcy5faW5mby5hbHRlcm5hdGVzWzBdLm5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLmFwaSwgYXNpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5mbyhjYWNoZWQgPSBmYWxzZSwgb3B0cykge1xuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2luZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5pbmZvKHRoaXMubmFtZSwgb3B0cylcbiAgICAgICAgICAgIC50aGVuKChzaSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faW5mbyA9IHNpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZm87XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb25zdW1lcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3VtZXJzSW1wbChuZXcganNtY29uc3VtZXJfYXBpXzEuQ29uc3VtZXJBUElJbXBsKHRoaXMuYXBpLm5jLCB0aGlzLmFwaS5vcHRzKSlcbiAgICAgICAgICAgIC5nZXQodGhpcy5uYW1lLCBuYW1lKTtcbiAgICB9XG4gICAgZ2V0TWVzc2FnZShxdWVyeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGkuZ2V0TWVzc2FnZSh0aGlzLm5hbWUsIHF1ZXJ5KTtcbiAgICB9XG4gICAgZGVsZXRlTWVzc2FnZShzZXEsIGVyYXNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaS5kZWxldGVNZXNzYWdlKHRoaXMubmFtZSwgc2VxLCBlcmFzZSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJlYW1JbXBsID0gU3RyZWFtSW1wbDtcbmNsYXNzIFN0cmVhbUFQSUltcGwgZXh0ZW5kcyBqc2Jhc2VjbGllbnRfYXBpXzEuQmFzZUFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IobmMsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIobmMsIG9wdHMpO1xuICAgIH1cbiAgICBjaGVja1N0cmVhbUNvbmZpZ1ZlcnNpb25zKGNmZykge1xuICAgICAgICBjb25zdCBuY2kgPSB0aGlzLm5jO1xuICAgICAgICBpZiAoY2ZnLm1ldGFkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoc2VtdmVyXzEuRmVhdHVyZS5KU19TVFJFQU1fQ09OU1VNRVJfTUVUQURBVEEpO1xuICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RyZWFtICdtZXRhZGF0YScgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjZmcuZmlyc3Rfc2VxKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoc2VtdmVyXzEuRmVhdHVyZS5KU19TVFJFQU1fRklSU1RfU0VRKTtcbiAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmVhbSAnZmlyc3Rfc2VxJyByZXF1aXJlcyBzZXJ2ZXIgJHttaW59YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5zdWJqZWN0X3RyYW5zZm9ybSkge1xuICAgICAgICAgICAgY29uc3QgeyBtaW4sIG9rIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KHNlbXZlcl8xLkZlYXR1cmUuSlNfU1RSRUFNX1NVQkpFQ1RfVFJBTlNGT1JNKTtcbiAgICAgICAgICAgIGlmICghb2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmVhbSAnc3ViamVjdF90cmFuc2Zvcm0nIHJlcXVpcmVzIHNlcnZlciAke21pbn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ZnLmNvbXByZXNzaW9uKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoc2VtdmVyXzEuRmVhdHVyZS5KU19TVFJFQU1fQ09NUFJFU1NJT04pO1xuICAgICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc3RyZWFtICdjb21wcmVzc2lvbicgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjZmcuY29uc3VtZXJfbGltaXRzKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoc2VtdmVyXzEuRmVhdHVyZS5KU19ERUZBVUxUX0NPTlNVTUVSX0xJTUlUUyk7XG4gICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHJlYW0gJ2NvbnN1bWVyX2xpbWl0cycgcmVxdWlyZXMgc2VydmVyICR7bWlufWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlU3RyZWFtU291cmNlKGNvbnRleHQsIHNyYykge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgY291bnQgPSAoKF9hID0gc3JjLnN1YmplY3RfdHJhbnNmb3JtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG1pbiwgb2sgfSA9IG5jaS5mZWF0dXJlcy5nZXQoc2VtdmVyXzEuRmVhdHVyZS5KU19TVFJFQU1fU09VUkNFX1NVQkpFQ1RfVFJBTlNGT1JNKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fSAnc3ViamVjdF90cmFuc2Zvcm1zJyByZXF1aXJlcyBzZXJ2ZXIgJHttaW59YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjZmcuc291cmNlcykge1xuICAgICAgICAgICAgY2ZnLnNvdXJjZXMuZm9yRWFjaCgoc3JjKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVTdHJlYW1Tb3VyY2UoXCJzdHJlYW0gc291cmNlc1wiLCBzcmMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNmZy5taXJyb3IpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyZWFtU291cmNlKFwic3RyZWFtIG1pcnJvclwiLCBjZmcubWlycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGQoY2ZnID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1N0cmVhbUNvbmZpZ1ZlcnNpb25zKGNmZyk7XG4gICAgICAgICAgICAoMCwganN1dGlsXzEudmFsaWRhdGVTdHJlYW1OYW1lKShjZmcubmFtZSk7XG4gICAgICAgICAgICBjZmcubWlycm9yID0gY29udmVydFN0cmVhbVNvdXJjZURvbWFpbihjZmcubWlycm9yKTtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZTogdGhlIHNvdXJjZXMgYXJlIGVpdGhlciBzZXQgb3Igbm90IC0gc28gbm8gaXRlbSBzaG91bGQgYmUgdW5kZWZpbmVkIGluIHRoZSBsaXN0XG4gICAgICAgICAgICBjZmcuc291cmNlcyA9IChfYSA9IGNmZy5zb3VyY2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKGNvbnZlcnRTdHJlYW1Tb3VyY2VEb21haW4pO1xuICAgICAgICAgICAgY29uc3QgciA9IHlpZWxkIHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5DUkVBVEUuJHtjZmcubmFtZX1gLCBjZmcpO1xuICAgICAgICAgICAgY29uc3Qgc2kgPSByO1xuICAgICAgICAgICAgdGhpcy5fZml4SW5mbyhzaSk7XG4gICAgICAgICAgICByZXR1cm4gc2k7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAoMCwganN1dGlsXzEudmFsaWRhdGVTdHJlYW1OYW1lKShzdHJlYW0pO1xuICAgICAgICAgICAgY29uc3QgciA9IHlpZWxkIHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5ERUxFVEUuJHtzdHJlYW19YCk7XG4gICAgICAgICAgICBjb25zdCBjciA9IHI7XG4gICAgICAgICAgICByZXR1cm4gY3Iuc3VjY2VzcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZShuYW1lLCBjZmcgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYyA9IG5hbWU7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHNjLm5hbWU7XG4gICAgICAgICAgICAgICAgY2ZnID0gc2M7XG4gICAgICAgICAgICAgICAgY29uc29sZS50cmFjZShgXFx1MDAxQlszM20gPj4gc3RyZWFtcy51cGRhdGUoY29uZmlnOiBTdHJlYW1Db25maWcpIGFwaSBjaGFuZ2VkIHRvIHN0cmVhbXMudXBkYXRlKG5hbWU6IHN0cmluZywgY29uZmlnOiBTdHJlYW1VcGRhdGVDb25maWcpIC0gdGhpcyBzaGltIHdpbGwgYmUgcmVtb3ZlZCAtIHVwZGF0ZSB5b3VyIGNvZGUuICBcXHUwMDFCWzBtYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoZWNrU3RyZWFtQ29uZmlnVmVyc2lvbnMoY2ZnKTtcbiAgICAgICAgICAgICgwLCBqc3V0aWxfMS52YWxpZGF0ZVN0cmVhbU5hbWUpKG5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgb2xkID0geWllbGQgdGhpcy5pbmZvKG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlID0gT2JqZWN0LmFzc2lnbihvbGQuY29uZmlnLCBjZmcpO1xuICAgICAgICAgICAgdXBkYXRlLm1pcnJvciA9IGNvbnZlcnRTdHJlYW1Tb3VyY2VEb21haW4odXBkYXRlLm1pcnJvcik7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmU6IHRoZSBzb3VyY2VzIGFyZSBlaXRoZXIgc2V0IG9yIG5vdCAtIHNvIG5vIGl0ZW0gc2hvdWxkIGJlIHVuZGVmaW5lZCBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgdXBkYXRlLnNvdXJjZXMgPSAoX2EgPSB1cGRhdGUuc291cmNlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcChjb252ZXJ0U3RyZWFtU291cmNlRG9tYWluKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB5aWVsZCB0aGlzLl9yZXF1ZXN0KGAke3RoaXMucHJlZml4fS5TVFJFQU0uVVBEQVRFLiR7bmFtZX1gLCB1cGRhdGUpO1xuICAgICAgICAgICAgY29uc3Qgc2kgPSByO1xuICAgICAgICAgICAgdGhpcy5fZml4SW5mbyhzaSk7XG4gICAgICAgICAgICByZXR1cm4gc2k7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmZvKG5hbWUsIGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICgwLCBqc3V0aWxfMS52YWxpZGF0ZVN0cmVhbU5hbWUpKG5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgc3ViaiA9IGAke3RoaXMucHJlZml4fS5TVFJFQU0uSU5GTy4ke25hbWV9YDtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB5aWVsZCB0aGlzLl9yZXF1ZXN0KHN1YmosIGRhdGEpO1xuICAgICAgICAgICAgbGV0IHNpID0gcjtcbiAgICAgICAgICAgIGxldCB7IHRvdGFsLCBsaW1pdCB9ID0gc2k7XG4gICAgICAgICAgICAvLyBjaGVjayBob3cgbWFueSBzdWJqZWN0cyB3ZSBnb3QgaW4gdGhlIGZpcnN0IHJlcXVlc3RcbiAgICAgICAgICAgIGxldCBoYXZlID0gc2kuc3RhdGUuc3ViamVjdHNcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNpLnN0YXRlLnN1YmplY3RzKS5sZW5ndGhcbiAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVzcG9uc2UgaXMgcGFnZWQsIHdlIGhhdmUgYSBsYXJnZSBsaXN0IG9mIHN1YmplY3RzXG4gICAgICAgICAgICAvLyBoYW5kbGUgdGhlIHBhZ2luZyBhbmQgcmV0dXJuIGEgU3RyZWFtSW5mbyB3aXRoIGFsbCBvZiBpdFxuICAgICAgICAgICAgaWYgKHRvdGFsICYmIHRvdGFsID4gaGF2ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZm9zID0gW3NpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlZCA9IGRhdGEgfHwge307XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIC8vIHRvdGFsIGNvdWxkIGNoYW5nZSwgc28gaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBjb2xsZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyBtb3JlIHRoYXQgdGhlIHRvdGFsXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRvdGFsID4gaGF2ZSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2VkLm9mZnNldCA9IGxpbWl0ICogaTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IHlpZWxkIHRoaXMuX3JlcXVlc3Qoc3ViaiwgcGFnZWQpO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgaXQgaW4gY2FzZSBpdCBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsID0gci50b3RhbDtcbiAgICAgICAgICAgICAgICAgICAgaW5mb3MucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyLnN0YXRlLnN1YmplY3RzKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGhhdmUgKz0gY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHJlcXVlc3QgcmV0dXJucyBsZXNzIHRoYW4gbGltaXQgaXQgaXMgZG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPCBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCBhbGwgdGhlIHN1YmplY3RzXG4gICAgICAgICAgICAgICAgbGV0IHN1YmplY3RzID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmZvcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzaSA9IGluZm9zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2kuc3RhdGUuc3ViamVjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3RzID0gT2JqZWN0LmFzc2lnbihzdWJqZWN0cywgc2kuc3RhdGUuc3ViamVjdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGdpdmUgdGhlIGltcHJlc3Npb24gd2UgcGFnZWRcbiAgICAgICAgICAgICAgICBzaS5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIHNpLnRvdGFsID0gMDtcbiAgICAgICAgICAgICAgICBzaS5saW1pdCA9IDA7XG4gICAgICAgICAgICAgICAgc2kuc3RhdGUuc3ViamVjdHMgPSBzdWJqZWN0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2ZpeEluZm8oc2kpO1xuICAgICAgICAgICAgcmV0dXJuIHNpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlzdChzdWJqZWN0ID0gXCJcIikge1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gKHN1YmplY3QgPT09IG51bGwgfHwgc3ViamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3ViamVjdC5sZW5ndGgpID8geyBzdWJqZWN0IH0gOiB7fTtcbiAgICAgICAgY29uc3QgbGlzdGVyRmlsdGVyID0gKHYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNsciA9IHY7XG4gICAgICAgICAgICBzbHIuc3RyZWFtcy5mb3JFYWNoKChzaSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpeEluZm8oc2kpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2xyLnN0cmVhbXM7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN1YmogPSBgJHt0aGlzLnByZWZpeH0uU1RSRUFNLkxJU1RgO1xuICAgICAgICByZXR1cm4gbmV3IGpzbGlzdGVyXzEuTGlzdGVySW1wbChzdWJqLCBsaXN0ZXJGaWx0ZXIsIHRoaXMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvLyBGSVhNRTogaW5pdCBvZiBzZWFsZWQsIGRlbnlfZGVsZXRlLCBkZW55X3B1cmdlIHNob3VsZG4ndCBiZSBuZWNlc3NhcnlcbiAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL25hdHMtaW8vbmF0cy1zZXJ2ZXIvaXNzdWVzLzI2MzNcbiAgICBfZml4SW5mbyhzaSkge1xuICAgICAgICBzaS5jb25maWcuc2VhbGVkID0gc2kuY29uZmlnLnNlYWxlZCB8fCBmYWxzZTtcbiAgICAgICAgc2kuY29uZmlnLmRlbnlfZGVsZXRlID0gc2kuY29uZmlnLmRlbnlfZGVsZXRlIHx8IGZhbHNlO1xuICAgICAgICBzaS5jb25maWcuZGVueV9wdXJnZSA9IHNpLmNvbmZpZy5kZW55X3B1cmdlIHx8IGZhbHNlO1xuICAgICAgICBzaS5jb25maWcuYWxsb3dfcm9sbHVwX2hkcnMgPSBzaS5jb25maWcuYWxsb3dfcm9sbHVwX2hkcnMgfHwgZmFsc2U7XG4gICAgfVxuICAgIHB1cmdlKG5hbWUsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrZWVwLCBzZXEgfSA9IG9wdHM7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZWVwID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBzZXEgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuIHNwZWNpZnkgb25lIG9mIGtlZXAgb3Igc2VxXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCBqc3V0aWxfMS52YWxpZGF0ZVN0cmVhbU5hbWUpKG5hbWUpO1xuICAgICAgICAgICAgY29uc3QgdiA9IHlpZWxkIHRoaXMuX3JlcXVlc3QoYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5QVVJHRS4ke25hbWV9YCwgb3B0cyk7XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZU1lc3NhZ2Uoc3RyZWFtLCBzZXEsIGVyYXNlID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgKDAsIGpzdXRpbF8xLnZhbGlkYXRlU3RyZWFtTmFtZSkoc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGRyID0geyBzZXEgfTtcbiAgICAgICAgICAgIGlmICghZXJhc2UpIHtcbiAgICAgICAgICAgICAgICBkci5ub19lcmFzZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByID0geWllbGQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uU1RSRUFNLk1TRy5ERUxFVEUuJHtzdHJlYW19YCwgZHIpO1xuICAgICAgICAgICAgY29uc3QgY3IgPSByO1xuICAgICAgICAgICAgcmV0dXJuIGNyLnN1Y2Nlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRNZXNzYWdlKHN0cmVhbSwgcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICgwLCBqc3V0aWxfMS52YWxpZGF0ZVN0cmVhbU5hbWUpKHN0cmVhbSk7XG4gICAgICAgICAgICBjb25zdCByID0geWllbGQgdGhpcy5fcmVxdWVzdChgJHt0aGlzLnByZWZpeH0uU1RSRUFNLk1TRy5HRVQuJHtzdHJlYW19YCwgcXVlcnkpO1xuICAgICAgICAgICAgY29uc3Qgc20gPSByO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdG9yZWRNc2dJbXBsKHNtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbmQoc3ViamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kU3RyZWFtKHN1YmplY3QpO1xuICAgIH1cbiAgICBsaXN0S3ZzKCkge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSAodikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHNsciA9IHY7XG4gICAgICAgICAgICBjb25zdCBrdlN0cmVhbXMgPSBzbHIuc3RyZWFtcy5maWx0ZXIoKHYpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5jb25maWcubmFtZS5zdGFydHNXaXRoKHR5cGVzXzIua3ZQcmVmaXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBrdlN0cmVhbXMuZm9yRWFjaCgoc2kpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maXhJbmZvKHNpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGNsdXN0ZXIgPSBcIlwiO1xuICAgICAgICAgICAgaWYgKGt2U3RyZWFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyID0gKF9iID0gKF9hID0gdGhpcy5uYy5pbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2x1c3RlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGt2U3RyZWFtcy5tYXAoKHNpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBrdl8xLkt2U3RhdHVzSW1wbChzaSwgY2x1c3Rlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN1YmogPSBgJHt0aGlzLnByZWZpeH0uU1RSRUFNLkxJU1RgO1xuICAgICAgICByZXR1cm4gbmV3IGpzbGlzdGVyXzEuTGlzdGVySW1wbChzdWJqLCBmaWx0ZXIsIHRoaXMpO1xuICAgIH1cbiAgICBsaXN0T2JqZWN0U3RvcmVzKCkge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSAodikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2xyID0gdjtcbiAgICAgICAgICAgIGNvbnN0IG9ialN0cmVhbXMgPSBzbHIuc3RyZWFtcy5maWx0ZXIoKHYpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi5jb25maWcubmFtZS5zdGFydHNXaXRoKG9iamVjdHN0b3JlXzEub3NQcmVmaXgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvYmpTdHJlYW1zLmZvckVhY2goKHNpKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZml4SW5mbyhzaSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IG9ialN0cmVhbXMubWFwKChzaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgb2JqZWN0c3RvcmVfMS5PYmplY3RTdG9yZVN0YXR1c0ltcGwoc2kpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdWJqID0gYCR7dGhpcy5wcmVmaXh9LlNUUkVBTS5MSVNUYDtcbiAgICAgICAgcmV0dXJuIG5ldyBqc2xpc3Rlcl8xLkxpc3RlckltcGwoc3ViaiwgZmlsdGVyLCB0aGlzKTtcbiAgICB9XG4gICAgbmFtZXMoc3ViamVjdCA9IFwiXCIpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IChzdWJqZWN0ID09PSBudWxsIHx8IHN1YmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1YmplY3QubGVuZ3RoKSA/IHsgc3ViamVjdCB9IDoge307XG4gICAgICAgIGNvbnN0IGxpc3RlckZpbHRlciA9ICh2KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzciA9IHY7XG4gICAgICAgICAgICByZXR1cm4gc3Iuc3RyZWFtcztcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3ViaiA9IGAke3RoaXMucHJlZml4fS5TVFJFQU0uTkFNRVNgO1xuICAgICAgICByZXR1cm4gbmV3IGpzbGlzdGVyXzEuTGlzdGVySW1wbChzdWJqLCBsaXN0ZXJGaWx0ZXIsIHRoaXMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBnZXQobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc2kgPSB5aWVsZCB0aGlzLmluZm8obmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBTdHJlYW1JbXBsKHRoaXMsIHNpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyZWFtQVBJSW1wbCA9IFN0cmVhbUFQSUltcGw7XG5jbGFzcyBTdG9yZWRNc2dJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihzbXIpIHtcbiAgICAgICAgdGhpcy5zbXIgPSBzbXI7XG4gICAgfVxuICAgIGdldCBzdWJqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbXIubWVzc2FnZS5zdWJqZWN0O1xuICAgIH1cbiAgICBnZXQgc2VxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbXIubWVzc2FnZS5zZXE7XG4gICAgfVxuICAgIGdldCB0aW1lc3RhbXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtci5tZXNzYWdlLnRpbWU7XG4gICAgfVxuICAgIGdldCB0aW1lKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5wYXJzZSh0aGlzLnRpbWVzdGFtcCkpO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc21yLm1lc3NhZ2UuZGF0YSA/IHRoaXMuX3BhcnNlKHRoaXMuc21yLm1lc3NhZ2UuZGF0YSkgOiB0eXBlc18xLkVtcHR5O1xuICAgIH1cbiAgICBnZXQgaGVhZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2hlYWRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc21yLm1lc3NhZ2UuaGRycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhkID0gdGhpcy5fcGFyc2UodGhpcy5zbXIubWVzc2FnZS5oZHJzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXIgPSBoZWFkZXJzXzEuTXNnSGRyc0ltcGwuZGVjb2RlKGhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hlYWRlciA9ICgwLCBoZWFkZXJzXzEuaGVhZGVycykoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xuICAgIH1cbiAgICBfcGFyc2Uocykge1xuICAgICAgICBjb25zdCBicyA9IGF0b2Iocyk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGJzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBieXRlc1tpXSA9IGJzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBqc29uKHJldml2ZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCBjb2RlY18xLkpTT05Db2RlYykocmV2aXZlcikuZGVjb2RlKHRoaXMuZGF0YSk7XG4gICAgfVxuICAgIHN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZXJzXzEuVEQuZGVjb2RlKHRoaXMuZGF0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdG9yZWRNc2dJbXBsID0gU3RvcmVkTXNnSW1wbDtcbmNsYXNzIFN0cmVhbXNJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihhcGkpIHtcbiAgICAgICAgdGhpcy5hcGkgPSBhcGk7XG4gICAgfVxuICAgIGdldChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmluZm8oc3RyZWFtKVxuICAgICAgICAgICAgLnRoZW4oKHNpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwodGhpcy5hcGksIHNpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJlYW1zSW1wbCA9IFN0cmVhbXNJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNtc3RyZWFtX2FwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/jsmstream_api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/jsutil.js":
/*!***************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/jsutil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkJsErrorCode = exports.isTerminal409 = exports.setMaxWaitingToFail = exports.Js409Errors = exports.checkJsError = exports.newJsErrorMsg = exports.isHeartbeatMsg = exports.isFlowControlMsg = exports.millis = exports.nanos = exports.validName = exports.validateName = exports.minValidation = exports.validateStreamName = exports.validateDurableName = void 0;\n/*\n * Copyright 2021-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst encoders_1 = __webpack_require__(/*! ../nats-base-client/encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst headers_1 = __webpack_require__(/*! ../nats-base-client/headers */ \"(rsc)/./node_modules/nats/lib/nats-base-client/headers.js\");\nconst msg_1 = __webpack_require__(/*! ../nats-base-client/msg */ \"(rsc)/./node_modules/nats/lib/nats-base-client/msg.js\");\nconst core_1 = __webpack_require__(/*! ../nats-base-client/core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nfunction validateDurableName(name) {\n    return minValidation(\"durable\", name);\n}\nexports.validateDurableName = validateDurableName;\nfunction validateStreamName(name) {\n    return minValidation(\"stream\", name);\n}\nexports.validateStreamName = validateStreamName;\nfunction minValidation(context, name = \"\") {\n    // minimum validation on streams/consumers matches nats cli\n    if (name === \"\") {\n        throw Error(`${context} name required`);\n    }\n    const bad = [\".\", \"*\", \">\", \"/\", \"\\\\\", \" \", \"\\t\", \"\\n\", \"\\r\"];\n    bad.forEach((v) => {\n        if (name.indexOf(v) !== -1) {\n            // make the error have a meaningful character\n            switch (v) {\n                case \"\\n\":\n                    v = \"\\\\n\";\n                    break;\n                case \"\\r\":\n                    v = \"\\\\r\";\n                    break;\n                case \"\\t\":\n                    v = \"\\\\t\";\n                    break;\n                default:\n                // nothing\n            }\n            throw Error(`invalid ${context} name - ${context} name cannot contain '${v}'`);\n        }\n    });\n    return \"\";\n}\nexports.minValidation = minValidation;\nfunction validateName(context, name = \"\") {\n    if (name === \"\") {\n        throw Error(`${context} name required`);\n    }\n    const m = validName(name);\n    if (m.length) {\n        throw new Error(`invalid ${context} name - ${context} name ${m}`);\n    }\n}\nexports.validateName = validateName;\nfunction validName(name = \"\") {\n    if (name === \"\") {\n        throw Error(`name required`);\n    }\n    const RE = /^[-\\w]+$/g;\n    const m = name.match(RE);\n    if (m === null) {\n        for (const c of name.split(\"\")) {\n            const mm = c.match(RE);\n            if (mm === null) {\n                return `cannot contain '${c}'`;\n            }\n        }\n    }\n    return \"\";\n}\nexports.validName = validName;\n/**\n * Converts the specified millis into Nanos\n * @param millis\n */\nfunction nanos(millis) {\n    return millis * 1000000;\n}\nexports.nanos = nanos;\n/**\n * Convert the specified Nanos into millis\n * @param ns\n */\nfunction millis(ns) {\n    return Math.floor(ns / 1000000);\n}\nexports.millis = millis;\n/**\n * Returns true if the message is a flow control message\n * @param msg\n */\nfunction isFlowControlMsg(msg) {\n    if (msg.data.length > 0) {\n        return false;\n    }\n    const h = msg.headers;\n    if (!h) {\n        return false;\n    }\n    return h.code >= 100 && h.code < 200;\n}\nexports.isFlowControlMsg = isFlowControlMsg;\n/**\n * Returns true if the message is a heart beat message\n * @param msg\n */\nfunction isHeartbeatMsg(msg) {\n    var _a;\n    return isFlowControlMsg(msg) && ((_a = msg.headers) === null || _a === void 0 ? void 0 : _a.description) === \"Idle Heartbeat\";\n}\nexports.isHeartbeatMsg = isHeartbeatMsg;\nfunction newJsErrorMsg(code, description, subject) {\n    const h = (0, headers_1.headers)(code, description);\n    const arg = { hdr: 1, sid: 0, size: 0 };\n    const msg = new msg_1.MsgImpl(arg, encoders_1.Empty, {});\n    msg._headers = h;\n    msg._subject = subject;\n    return msg;\n}\nexports.newJsErrorMsg = newJsErrorMsg;\nfunction checkJsError(msg) {\n    // JS error only if no payload - otherwise assume it is application data\n    if (msg.data.length !== 0) {\n        return null;\n    }\n    const h = msg.headers;\n    if (!h) {\n        return null;\n    }\n    return checkJsErrorCode(h.code, h.description);\n}\nexports.checkJsError = checkJsError;\nvar Js409Errors;\n(function (Js409Errors) {\n    Js409Errors[\"MaxBatchExceeded\"] = \"exceeded maxrequestbatch of\";\n    Js409Errors[\"MaxExpiresExceeded\"] = \"exceeded maxrequestexpires of\";\n    Js409Errors[\"MaxBytesExceeded\"] = \"exceeded maxrequestmaxbytes of\";\n    Js409Errors[\"MaxMessageSizeExceeded\"] = \"message size exceeds maxbytes\";\n    Js409Errors[\"PushConsumer\"] = \"consumer is push based\";\n    Js409Errors[\"MaxWaitingExceeded\"] = \"exceeded maxwaiting\";\n    Js409Errors[\"IdleHeartbeatMissed\"] = \"idle heartbeats missed\";\n    Js409Errors[\"ConsumerDeleted\"] = \"consumer deleted\";\n    // FIXME: consumer deleted - instead of no responder (terminal error)\n    //   leadership changed -\n})(Js409Errors || (exports.Js409Errors = Js409Errors = {}));\nlet MAX_WAITING_FAIL = false;\nfunction setMaxWaitingToFail(tf) {\n    MAX_WAITING_FAIL = tf;\n}\nexports.setMaxWaitingToFail = setMaxWaitingToFail;\nfunction isTerminal409(err) {\n    if (err.code !== core_1.ErrorCode.JetStream409) {\n        return false;\n    }\n    const fatal = [\n        Js409Errors.MaxBatchExceeded,\n        Js409Errors.MaxExpiresExceeded,\n        Js409Errors.MaxBytesExceeded,\n        Js409Errors.MaxMessageSizeExceeded,\n        Js409Errors.PushConsumer,\n        Js409Errors.IdleHeartbeatMissed,\n        Js409Errors.ConsumerDeleted,\n    ];\n    if (MAX_WAITING_FAIL) {\n        fatal.push(Js409Errors.MaxWaitingExceeded);\n    }\n    return fatal.find((s) => {\n        return err.message.indexOf(s) !== -1;\n    }) !== undefined;\n}\nexports.isTerminal409 = isTerminal409;\nfunction checkJsErrorCode(code, description = \"\") {\n    if (code < 300) {\n        return null;\n    }\n    description = description.toLowerCase();\n    switch (code) {\n        case 404:\n            // 404 for jetstream will provide different messages ensure we\n            // keep whatever the server returned\n            return new core_1.NatsError(description, core_1.ErrorCode.JetStream404NoMessages);\n        case 408:\n            return new core_1.NatsError(description, core_1.ErrorCode.JetStream408RequestTimeout);\n        case 409: {\n            // the description can be exceeded max waiting or max ack pending, which are\n            // recoverable, but can also be terminal errors where the request exceeds\n            // some value in the consumer configuration\n            const ec = description.startsWith(Js409Errors.IdleHeartbeatMissed)\n                ? core_1.ErrorCode.JetStreamIdleHeartBeat\n                : core_1.ErrorCode.JetStream409;\n            return new core_1.NatsError(description, ec);\n        }\n        case 503:\n            return core_1.NatsError.errorForCode(core_1.ErrorCode.JetStreamNotEnabled, new Error(description));\n        default:\n            if (description === \"\") {\n                description = core_1.ErrorCode.Unknown;\n            }\n            return new core_1.NatsError(description, `${code}`);\n    }\n}\nexports.checkJsErrorCode = checkJsErrorCode;\n//# sourceMappingURL=jsutil.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRywyQkFBMkIsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0IsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGlCQUFpQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLDBCQUEwQixHQUFHLDJCQUEyQjtBQUN0VztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQThCO0FBQ3pELGtCQUFrQixtQkFBTyxDQUFDLDhGQUE2QjtBQUN2RCxjQUFjLG1CQUFPLENBQUMsc0ZBQXlCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyx3RkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUyxTQUFTLFNBQVMsdUJBQXVCLEVBQUU7QUFDdkY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVMsU0FBUyxTQUFTLE9BQU8sRUFBRTtBQUN2RTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEVBQUU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtCQUFrQixtQkFBbUIsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2pzdXRpbC5qcz9mNWNiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja0pzRXJyb3JDb2RlID0gZXhwb3J0cy5pc1Rlcm1pbmFsNDA5ID0gZXhwb3J0cy5zZXRNYXhXYWl0aW5nVG9GYWlsID0gZXhwb3J0cy5KczQwOUVycm9ycyA9IGV4cG9ydHMuY2hlY2tKc0Vycm9yID0gZXhwb3J0cy5uZXdKc0Vycm9yTXNnID0gZXhwb3J0cy5pc0hlYXJ0YmVhdE1zZyA9IGV4cG9ydHMuaXNGbG93Q29udHJvbE1zZyA9IGV4cG9ydHMubWlsbGlzID0gZXhwb3J0cy5uYW5vcyA9IGV4cG9ydHMudmFsaWROYW1lID0gZXhwb3J0cy52YWxpZGF0ZU5hbWUgPSBleHBvcnRzLm1pblZhbGlkYXRpb24gPSBleHBvcnRzLnZhbGlkYXRlU3RyZWFtTmFtZSA9IGV4cG9ydHMudmFsaWRhdGVEdXJhYmxlTmFtZSA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMS0yMDIzIFRoZSBOQVRTIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBlbmNvZGVyc18xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvZW5jb2RlcnNcIik7XG5jb25zdCBoZWFkZXJzXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9oZWFkZXJzXCIpO1xuY29uc3QgbXNnXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9tc2dcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9jb3JlXCIpO1xuZnVuY3Rpb24gdmFsaWRhdGVEdXJhYmxlTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG1pblZhbGlkYXRpb24oXCJkdXJhYmxlXCIsIG5hbWUpO1xufVxuZXhwb3J0cy52YWxpZGF0ZUR1cmFibGVOYW1lID0gdmFsaWRhdGVEdXJhYmxlTmFtZTtcbmZ1bmN0aW9uIHZhbGlkYXRlU3RyZWFtTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIG1pblZhbGlkYXRpb24oXCJzdHJlYW1cIiwgbmFtZSk7XG59XG5leHBvcnRzLnZhbGlkYXRlU3RyZWFtTmFtZSA9IHZhbGlkYXRlU3RyZWFtTmFtZTtcbmZ1bmN0aW9uIG1pblZhbGlkYXRpb24oY29udGV4dCwgbmFtZSA9IFwiXCIpIHtcbiAgICAvLyBtaW5pbXVtIHZhbGlkYXRpb24gb24gc3RyZWFtcy9jb25zdW1lcnMgbWF0Y2hlcyBuYXRzIGNsaVxuICAgIGlmIChuYW1lID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IEVycm9yKGAke2NvbnRleHR9IG5hbWUgcmVxdWlyZWRgKTtcbiAgICB9XG4gICAgY29uc3QgYmFkID0gW1wiLlwiLCBcIipcIiwgXCI+XCIsIFwiL1wiLCBcIlxcXFxcIiwgXCIgXCIsIFwiXFx0XCIsIFwiXFxuXCIsIFwiXFxyXCJdO1xuICAgIGJhZC5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YodikgIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSBlcnJvciBoYXZlIGEgbWVhbmluZ2Z1bCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICAgICAgICAgICAgdiA9IFwiXFxcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgICAgICAgICB2ID0gXCJcXFxcclwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiXFx0XCI6XG4gICAgICAgICAgICAgICAgICAgIHYgPSBcIlxcXFx0XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gbm90aGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYGludmFsaWQgJHtjb250ZXh0fSBuYW1lIC0gJHtjb250ZXh0fSBuYW1lIGNhbm5vdCBjb250YWluICcke3Z9J2ApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFwiXCI7XG59XG5leHBvcnRzLm1pblZhbGlkYXRpb24gPSBtaW5WYWxpZGF0aW9uO1xuZnVuY3Rpb24gdmFsaWRhdGVOYW1lKGNvbnRleHQsIG5hbWUgPSBcIlwiKSB7XG4gICAgaWYgKG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoYCR7Y29udGV4dH0gbmFtZSByZXF1aXJlZGApO1xuICAgIH1cbiAgICBjb25zdCBtID0gdmFsaWROYW1lKG5hbWUpO1xuICAgIGlmIChtLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgJHtjb250ZXh0fSBuYW1lIC0gJHtjb250ZXh0fSBuYW1lICR7bX1gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlTmFtZSA9IHZhbGlkYXRlTmFtZTtcbmZ1bmN0aW9uIHZhbGlkTmFtZShuYW1lID0gXCJcIikge1xuICAgIGlmIChuYW1lID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBuYW1lIHJlcXVpcmVkYCk7XG4gICAgfVxuICAgIGNvbnN0IFJFID0gL15bLVxcd10rJC9nO1xuICAgIGNvbnN0IG0gPSBuYW1lLm1hdGNoKFJFKTtcbiAgICBpZiAobSA9PT0gbnVsbCkge1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgbmFtZS5zcGxpdChcIlwiKSkge1xuICAgICAgICAgICAgY29uc3QgbW0gPSBjLm1hdGNoKFJFKTtcbiAgICAgICAgICAgIGlmIChtbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgY2Fubm90IGNvbnRhaW4gJyR7Y30nYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbmV4cG9ydHMudmFsaWROYW1lID0gdmFsaWROYW1lO1xuLyoqXG4gKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIG1pbGxpcyBpbnRvIE5hbm9zXG4gKiBAcGFyYW0gbWlsbGlzXG4gKi9cbmZ1bmN0aW9uIG5hbm9zKG1pbGxpcykge1xuICAgIHJldHVybiBtaWxsaXMgKiAxMDAwMDAwO1xufVxuZXhwb3J0cy5uYW5vcyA9IG5hbm9zO1xuLyoqXG4gKiBDb252ZXJ0IHRoZSBzcGVjaWZpZWQgTmFub3MgaW50byBtaWxsaXNcbiAqIEBwYXJhbSBuc1xuICovXG5mdW5jdGlvbiBtaWxsaXMobnMpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihucyAvIDEwMDAwMDApO1xufVxuZXhwb3J0cy5taWxsaXMgPSBtaWxsaXM7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbWVzc2FnZSBpcyBhIGZsb3cgY29udHJvbCBtZXNzYWdlXG4gKiBAcGFyYW0gbXNnXG4gKi9cbmZ1bmN0aW9uIGlzRmxvd0NvbnRyb2xNc2cobXNnKSB7XG4gICAgaWYgKG1zZy5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBoID0gbXNnLmhlYWRlcnM7XG4gICAgaWYgKCFoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGguY29kZSA+PSAxMDAgJiYgaC5jb2RlIDwgMjAwO1xufVxuZXhwb3J0cy5pc0Zsb3dDb250cm9sTXNnID0gaXNGbG93Q29udHJvbE1zZztcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBtZXNzYWdlIGlzIGEgaGVhcnQgYmVhdCBtZXNzYWdlXG4gKiBAcGFyYW0gbXNnXG4gKi9cbmZ1bmN0aW9uIGlzSGVhcnRiZWF0TXNnKG1zZykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gaXNGbG93Q29udHJvbE1zZyhtc2cpICYmICgoX2EgPSBtc2cuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc2NyaXB0aW9uKSA9PT0gXCJJZGxlIEhlYXJ0YmVhdFwiO1xufVxuZXhwb3J0cy5pc0hlYXJ0YmVhdE1zZyA9IGlzSGVhcnRiZWF0TXNnO1xuZnVuY3Rpb24gbmV3SnNFcnJvck1zZyhjb2RlLCBkZXNjcmlwdGlvbiwgc3ViamVjdCkge1xuICAgIGNvbnN0IGggPSAoMCwgaGVhZGVyc18xLmhlYWRlcnMpKGNvZGUsIGRlc2NyaXB0aW9uKTtcbiAgICBjb25zdCBhcmcgPSB7IGhkcjogMSwgc2lkOiAwLCBzaXplOiAwIH07XG4gICAgY29uc3QgbXNnID0gbmV3IG1zZ18xLk1zZ0ltcGwoYXJnLCBlbmNvZGVyc18xLkVtcHR5LCB7fSk7XG4gICAgbXNnLl9oZWFkZXJzID0gaDtcbiAgICBtc2cuX3N1YmplY3QgPSBzdWJqZWN0O1xuICAgIHJldHVybiBtc2c7XG59XG5leHBvcnRzLm5ld0pzRXJyb3JNc2cgPSBuZXdKc0Vycm9yTXNnO1xuZnVuY3Rpb24gY2hlY2tKc0Vycm9yKG1zZykge1xuICAgIC8vIEpTIGVycm9yIG9ubHkgaWYgbm8gcGF5bG9hZCAtIG90aGVyd2lzZSBhc3N1bWUgaXQgaXMgYXBwbGljYXRpb24gZGF0YVxuICAgIGlmIChtc2cuZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGggPSBtc2cuaGVhZGVycztcbiAgICBpZiAoIWgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjaGVja0pzRXJyb3JDb2RlKGguY29kZSwgaC5kZXNjcmlwdGlvbik7XG59XG5leHBvcnRzLmNoZWNrSnNFcnJvciA9IGNoZWNrSnNFcnJvcjtcbnZhciBKczQwOUVycm9ycztcbihmdW5jdGlvbiAoSnM0MDlFcnJvcnMpIHtcbiAgICBKczQwOUVycm9yc1tcIk1heEJhdGNoRXhjZWVkZWRcIl0gPSBcImV4Y2VlZGVkIG1heHJlcXVlc3RiYXRjaCBvZlwiO1xuICAgIEpzNDA5RXJyb3JzW1wiTWF4RXhwaXJlc0V4Y2VlZGVkXCJdID0gXCJleGNlZWRlZCBtYXhyZXF1ZXN0ZXhwaXJlcyBvZlwiO1xuICAgIEpzNDA5RXJyb3JzW1wiTWF4Qnl0ZXNFeGNlZWRlZFwiXSA9IFwiZXhjZWVkZWQgbWF4cmVxdWVzdG1heGJ5dGVzIG9mXCI7XG4gICAgSnM0MDlFcnJvcnNbXCJNYXhNZXNzYWdlU2l6ZUV4Y2VlZGVkXCJdID0gXCJtZXNzYWdlIHNpemUgZXhjZWVkcyBtYXhieXRlc1wiO1xuICAgIEpzNDA5RXJyb3JzW1wiUHVzaENvbnN1bWVyXCJdID0gXCJjb25zdW1lciBpcyBwdXNoIGJhc2VkXCI7XG4gICAgSnM0MDlFcnJvcnNbXCJNYXhXYWl0aW5nRXhjZWVkZWRcIl0gPSBcImV4Y2VlZGVkIG1heHdhaXRpbmdcIjtcbiAgICBKczQwOUVycm9yc1tcIklkbGVIZWFydGJlYXRNaXNzZWRcIl0gPSBcImlkbGUgaGVhcnRiZWF0cyBtaXNzZWRcIjtcbiAgICBKczQwOUVycm9yc1tcIkNvbnN1bWVyRGVsZXRlZFwiXSA9IFwiY29uc3VtZXIgZGVsZXRlZFwiO1xuICAgIC8vIEZJWE1FOiBjb25zdW1lciBkZWxldGVkIC0gaW5zdGVhZCBvZiBubyByZXNwb25kZXIgKHRlcm1pbmFsIGVycm9yKVxuICAgIC8vICAgbGVhZGVyc2hpcCBjaGFuZ2VkIC1cbn0pKEpzNDA5RXJyb3JzIHx8IChleHBvcnRzLkpzNDA5RXJyb3JzID0gSnM0MDlFcnJvcnMgPSB7fSkpO1xubGV0IE1BWF9XQUlUSU5HX0ZBSUwgPSBmYWxzZTtcbmZ1bmN0aW9uIHNldE1heFdhaXRpbmdUb0ZhaWwodGYpIHtcbiAgICBNQVhfV0FJVElOR19GQUlMID0gdGY7XG59XG5leHBvcnRzLnNldE1heFdhaXRpbmdUb0ZhaWwgPSBzZXRNYXhXYWl0aW5nVG9GYWlsO1xuZnVuY3Rpb24gaXNUZXJtaW5hbDQwOShlcnIpIHtcbiAgICBpZiAoZXJyLmNvZGUgIT09IGNvcmVfMS5FcnJvckNvZGUuSmV0U3RyZWFtNDA5KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZmF0YWwgPSBbXG4gICAgICAgIEpzNDA5RXJyb3JzLk1heEJhdGNoRXhjZWVkZWQsXG4gICAgICAgIEpzNDA5RXJyb3JzLk1heEV4cGlyZXNFeGNlZWRlZCxcbiAgICAgICAgSnM0MDlFcnJvcnMuTWF4Qnl0ZXNFeGNlZWRlZCxcbiAgICAgICAgSnM0MDlFcnJvcnMuTWF4TWVzc2FnZVNpemVFeGNlZWRlZCxcbiAgICAgICAgSnM0MDlFcnJvcnMuUHVzaENvbnN1bWVyLFxuICAgICAgICBKczQwOUVycm9ycy5JZGxlSGVhcnRiZWF0TWlzc2VkLFxuICAgICAgICBKczQwOUVycm9ycy5Db25zdW1lckRlbGV0ZWQsXG4gICAgXTtcbiAgICBpZiAoTUFYX1dBSVRJTkdfRkFJTCkge1xuICAgICAgICBmYXRhbC5wdXNoKEpzNDA5RXJyb3JzLk1heFdhaXRpbmdFeGNlZWRlZCk7XG4gICAgfVxuICAgIHJldHVybiBmYXRhbC5maW5kKChzKSA9PiB7XG4gICAgICAgIHJldHVybiBlcnIubWVzc2FnZS5pbmRleE9mKHMpICE9PSAtMTtcbiAgICB9KSAhPT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc1Rlcm1pbmFsNDA5ID0gaXNUZXJtaW5hbDQwOTtcbmZ1bmN0aW9uIGNoZWNrSnNFcnJvckNvZGUoY29kZSwgZGVzY3JpcHRpb24gPSBcIlwiKSB7XG4gICAgaWYgKGNvZGUgPCAzMDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24udG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgY2FzZSA0MDQ6XG4gICAgICAgICAgICAvLyA0MDQgZm9yIGpldHN0cmVhbSB3aWxsIHByb3ZpZGUgZGlmZmVyZW50IG1lc3NhZ2VzIGVuc3VyZSB3ZVxuICAgICAgICAgICAgLy8ga2VlcCB3aGF0ZXZlciB0aGUgc2VydmVyIHJldHVybmVkXG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvcmVfMS5OYXRzRXJyb3IoZGVzY3JpcHRpb24sIGNvcmVfMS5FcnJvckNvZGUuSmV0U3RyZWFtNDA0Tm9NZXNzYWdlcyk7XG4gICAgICAgIGNhc2UgNDA4OlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb3JlXzEuTmF0c0Vycm9yKGRlc2NyaXB0aW9uLCBjb3JlXzEuRXJyb3JDb2RlLkpldFN0cmVhbTQwOFJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgY2FzZSA0MDk6IHtcbiAgICAgICAgICAgIC8vIHRoZSBkZXNjcmlwdGlvbiBjYW4gYmUgZXhjZWVkZWQgbWF4IHdhaXRpbmcgb3IgbWF4IGFjayBwZW5kaW5nLCB3aGljaCBhcmVcbiAgICAgICAgICAgIC8vIHJlY292ZXJhYmxlLCBidXQgY2FuIGFsc28gYmUgdGVybWluYWwgZXJyb3JzIHdoZXJlIHRoZSByZXF1ZXN0IGV4Y2VlZHNcbiAgICAgICAgICAgIC8vIHNvbWUgdmFsdWUgaW4gdGhlIGNvbnN1bWVyIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGVjID0gZGVzY3JpcHRpb24uc3RhcnRzV2l0aChKczQwOUVycm9ycy5JZGxlSGVhcnRiZWF0TWlzc2VkKVxuICAgICAgICAgICAgICAgID8gY29yZV8xLkVycm9yQ29kZS5KZXRTdHJlYW1JZGxlSGVhcnRCZWF0XG4gICAgICAgICAgICAgICAgOiBjb3JlXzEuRXJyb3JDb2RlLkpldFN0cmVhbTQwOTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY29yZV8xLk5hdHNFcnJvcihkZXNjcmlwdGlvbiwgZWMpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNTAzOlxuICAgICAgICAgICAgcmV0dXJuIGNvcmVfMS5OYXRzRXJyb3IuZXJyb3JGb3JDb2RlKGNvcmVfMS5FcnJvckNvZGUuSmV0U3RyZWFtTm90RW5hYmxlZCwgbmV3IEVycm9yKGRlc2NyaXB0aW9uKSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRpb24gPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IGNvcmVfMS5FcnJvckNvZGUuVW5rbm93bjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgY29yZV8xLk5hdHNFcnJvcihkZXNjcmlwdGlvbiwgYCR7Y29kZX1gKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrSnNFcnJvckNvZGUgPSBjaGVja0pzRXJyb3JDb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anN1dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/kv.js":
/*!***********************************************!*\
  !*** ./node_modules/nats/lib/jetstream/kv.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2021-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KvStatusImpl = exports.Bucket = exports.validateBucket = exports.hasWildcards = exports.validateSearchKey = exports.validateKey = exports.kvOperationHdr = exports.defaultBucketOpts = exports.NoopKvCodecs = exports.Base64KeyCodec = void 0;\nconst core_1 = __webpack_require__(/*! ../nats-base-client/core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nconst jsutil_1 = __webpack_require__(/*! ./jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\nconst queued_iterator_1 = __webpack_require__(/*! ../nats-base-client/queued_iterator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\");\nconst headers_1 = __webpack_require__(/*! ../nats-base-client/headers */ \"(rsc)/./node_modules/nats/lib/nats-base-client/headers.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/nats/lib/jetstream/types.js\");\nconst semver_1 = __webpack_require__(/*! ../nats-base-client/semver */ \"(rsc)/./node_modules/nats/lib/nats-base-client/semver.js\");\nconst util_1 = __webpack_require__(/*! ../nats-base-client/util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst encoders_1 = __webpack_require__(/*! ../nats-base-client/encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst jsapi_types_1 = __webpack_require__(/*! ./jsapi_types */ \"(rsc)/./node_modules/nats/lib/jetstream/jsapi_types.js\");\nconst jsclient_1 = __webpack_require__(/*! ./jsclient */ \"(rsc)/./node_modules/nats/lib/jetstream/jsclient.js\");\nfunction Base64KeyCodec() {\n    return {\n        encode(key) {\n            return btoa(key);\n        },\n        decode(bkey) {\n            return atob(bkey);\n        },\n    };\n}\nexports.Base64KeyCodec = Base64KeyCodec;\nfunction NoopKvCodecs() {\n    return {\n        key: {\n            encode(k) {\n                return k;\n            },\n            decode(k) {\n                return k;\n            },\n        },\n        value: {\n            encode(v) {\n                return v;\n            },\n            decode(v) {\n                return v;\n            },\n        },\n    };\n}\nexports.NoopKvCodecs = NoopKvCodecs;\nfunction defaultBucketOpts() {\n    return {\n        replicas: 1,\n        history: 1,\n        timeout: 2000,\n        maxBucketSize: -1,\n        maxValueSize: -1,\n        codec: NoopKvCodecs(),\n        storage: jsapi_types_1.StorageType.File,\n    };\n}\nexports.defaultBucketOpts = defaultBucketOpts;\nexports.kvOperationHdr = \"KV-Operation\";\nconst kvSubjectPrefix = \"$KV\";\nconst validKeyRe = /^[-/=.\\w]+$/;\nconst validSearchKey = /^[-/=.>*\\w]+$/;\nconst validBucketRe = /^[-\\w]+$/;\n// this exported for tests\nfunction validateKey(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\") || !validKeyRe.test(k)) {\n        throw new Error(`invalid key: ${k}`);\n    }\n}\nexports.validateKey = validateKey;\nfunction validateSearchKey(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\") || !validSearchKey.test(k)) {\n        throw new Error(`invalid key: ${k}`);\n    }\n}\nexports.validateSearchKey = validateSearchKey;\nfunction hasWildcards(k) {\n    if (k.startsWith(\".\") || k.endsWith(\".\")) {\n        throw new Error(`invalid key: ${k}`);\n    }\n    const chunks = k.split(\".\");\n    let hasWildcards = false;\n    for (let i = 0; i < chunks.length; i++) {\n        switch (chunks[i]) {\n            case \"*\":\n                hasWildcards = true;\n                break;\n            case \">\":\n                if (i !== chunks.length - 1) {\n                    throw new Error(`invalid key: ${k}`);\n                }\n                hasWildcards = true;\n                break;\n            default:\n            // continue\n        }\n    }\n    return hasWildcards;\n}\nexports.hasWildcards = hasWildcards;\n// this exported for tests\nfunction validateBucket(name) {\n    if (!validBucketRe.test(name)) {\n        throw new Error(`invalid bucket name: ${name}`);\n    }\n}\nexports.validateBucket = validateBucket;\nclass Bucket {\n    constructor(bucket, js, jsm) {\n        this.validateKey = validateKey;\n        this.validateSearchKey = validateSearchKey;\n        this.hasWildcards = hasWildcards;\n        validateBucket(bucket);\n        this.js = js;\n        this.jsm = jsm;\n        this.bucket = bucket;\n        this.prefix = kvSubjectPrefix;\n        this.editPrefix = \"\";\n        this.useJsPrefix = false;\n        this._prefixLen = 0;\n    }\n    static create(js, name, opts = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            validateBucket(name);\n            const jsm = yield js.jetstreamManager();\n            const bucket = new Bucket(name, js, jsm);\n            yield bucket.init(opts);\n            return bucket;\n        });\n    }\n    static bind(js, name, opts = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const jsm = yield js.jetstreamManager();\n            const info = yield jsm.streams.info(`${types_1.kvPrefix}${name}`);\n            validateBucket(info.config.name);\n            const bucket = new Bucket(name, js, jsm);\n            Object.assign(bucket, info);\n            bucket.codec = opts.codec || NoopKvCodecs();\n            bucket.direct = (_a = info.config.allow_direct) !== null && _a !== void 0 ? _a : false;\n            bucket.initializePrefixes(info);\n            return bucket;\n        });\n    }\n    init(opts = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const bo = Object.assign(defaultBucketOpts(), opts);\n            this.codec = bo.codec;\n            const sc = {};\n            this.stream = sc.name = (_a = opts.streamName) !== null && _a !== void 0 ? _a : this.bucketName();\n            sc.retention = jsapi_types_1.RetentionPolicy.Limits;\n            sc.max_msgs_per_subject = bo.history;\n            if (bo.maxBucketSize) {\n                bo.max_bytes = bo.maxBucketSize;\n            }\n            if (bo.max_bytes) {\n                sc.max_bytes = bo.max_bytes;\n            }\n            sc.max_msg_size = bo.maxValueSize;\n            sc.storage = bo.storage;\n            const location = (_b = opts.placementCluster) !== null && _b !== void 0 ? _b : \"\";\n            if (location) {\n                opts.placement = {};\n                opts.placement.cluster = location;\n                opts.placement.tags = [];\n            }\n            if (opts.placement) {\n                sc.placement = opts.placement;\n            }\n            if (opts.republish) {\n                sc.republish = opts.republish;\n            }\n            if (opts.description) {\n                sc.description = opts.description;\n            }\n            if (opts.mirror) {\n                const mirror = Object.assign({}, opts.mirror);\n                if (!mirror.name.startsWith(types_1.kvPrefix)) {\n                    mirror.name = `${types_1.kvPrefix}${mirror.name}`;\n                }\n                sc.mirror = mirror;\n                sc.mirror_direct = true;\n            }\n            else if (opts.sources) {\n                const sources = opts.sources.map((s) => {\n                    const c = Object.assign({}, s);\n                    if (!c.name.startsWith(types_1.kvPrefix)) {\n                        c.name = `${types_1.kvPrefix}${c.name}`;\n                    }\n                });\n                sc.sources = sources;\n            }\n            else {\n                sc.subjects = [this.subjectForBucket()];\n            }\n            if (opts.metadata) {\n                sc.metadata = opts.metadata;\n            }\n            if (typeof opts.compression === \"boolean\") {\n                sc.compression = opts.compression\n                    ? jsapi_types_1.StoreCompression.S2\n                    : jsapi_types_1.StoreCompression.None;\n            }\n            const nci = this.js.nc;\n            const have = nci.getServerVersion();\n            const discardNew = have ? (0, semver_1.compare)(have, (0, semver_1.parseSemVer)(\"2.7.2\")) >= 0 : false;\n            sc.discard = discardNew ? jsapi_types_1.DiscardPolicy.New : jsapi_types_1.DiscardPolicy.Old;\n            const { ok: direct, min } = nci.features.get(semver_1.Feature.JS_ALLOW_DIRECT);\n            if (!direct && opts.allow_direct === true) {\n                const v = have\n                    ? `${have.major}.${have.minor}.${have.micro}`\n                    : \"unknown\";\n                return Promise.reject(new Error(`allow_direct is not available on server version ${v} - requires ${min}`));\n            }\n            // if we are given allow_direct we use it, otherwise what\n            // the server supports - in creation this will always rule,\n            // but allows the client to opt-in even if it is already\n            // available on the stream\n            opts.allow_direct = typeof opts.allow_direct === \"boolean\"\n                ? opts.allow_direct\n                : direct;\n            sc.allow_direct = opts.allow_direct;\n            this.direct = sc.allow_direct;\n            sc.num_replicas = bo.replicas;\n            if (bo.ttl) {\n                sc.max_age = (0, jsutil_1.nanos)(bo.ttl);\n            }\n            sc.allow_rollup_hdrs = true;\n            let info;\n            try {\n                info = yield this.jsm.streams.info(sc.name);\n                if (!info.config.allow_direct && this.direct === true) {\n                    this.direct = false;\n                }\n            }\n            catch (err) {\n                if (err.message === \"stream not found\") {\n                    info = yield this.jsm.streams.add(sc);\n                }\n                else {\n                    throw err;\n                }\n            }\n            this.initializePrefixes(info);\n        });\n    }\n    initializePrefixes(info) {\n        this._prefixLen = 0;\n        this.prefix = `$KV.${this.bucket}`;\n        this.useJsPrefix = this.js.apiPrefix !== \"$JS.API\";\n        const { mirror } = info.config;\n        if (mirror) {\n            let n = mirror.name;\n            if (n.startsWith(types_1.kvPrefix)) {\n                n = n.substring(types_1.kvPrefix.length);\n            }\n            if (mirror.external && mirror.external.api !== \"\") {\n                const mb = mirror.name.substring(types_1.kvPrefix.length);\n                this.useJsPrefix = false;\n                this.prefix = `$KV.${mb}`;\n                this.editPrefix = `${mirror.external.api}.$KV.${n}`;\n            }\n            else {\n                this.editPrefix = this.prefix;\n            }\n        }\n    }\n    bucketName() {\n        var _a;\n        return (_a = this.stream) !== null && _a !== void 0 ? _a : `${types_1.kvPrefix}${this.bucket}`;\n    }\n    subjectForBucket() {\n        return `${this.prefix}.${this.bucket}.>`;\n    }\n    subjectForKey(k, edit = false) {\n        const builder = [];\n        if (edit) {\n            if (this.useJsPrefix) {\n                builder.push(this.js.apiPrefix);\n            }\n            if (this.editPrefix !== \"\") {\n                builder.push(this.editPrefix);\n            }\n            else {\n                builder.push(this.prefix);\n            }\n        }\n        else {\n            if (this.prefix) {\n                builder.push(this.prefix);\n            }\n        }\n        builder.push(k);\n        return builder.join(\".\");\n    }\n    fullKeyName(k) {\n        if (this.prefix !== \"\") {\n            return `${this.prefix}.${k}`;\n        }\n        return `${kvSubjectPrefix}.${this.bucket}.${k}`;\n    }\n    get prefixLen() {\n        if (this._prefixLen === 0) {\n            this._prefixLen = this.prefix.length + 1;\n        }\n        return this._prefixLen;\n    }\n    encodeKey(key) {\n        const chunks = [];\n        for (const t of key.split(\".\")) {\n            switch (t) {\n                case \">\":\n                case \"*\":\n                    chunks.push(t);\n                    break;\n                default:\n                    chunks.push(this.codec.key.encode(t));\n                    break;\n            }\n        }\n        return chunks.join(\".\");\n    }\n    decodeKey(ekey) {\n        const chunks = [];\n        for (const t of ekey.split(\".\")) {\n            switch (t) {\n                case \">\":\n                case \"*\":\n                    chunks.push(t);\n                    break;\n                default:\n                    chunks.push(this.codec.key.decode(t));\n                    break;\n            }\n        }\n        return chunks.join(\".\");\n    }\n    close() {\n        return Promise.resolve();\n    }\n    dataLen(data, h) {\n        const slen = h ? h.get(types_1.JsHeaders.MessageSizeHdr) || \"\" : \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return data.length;\n    }\n    smToEntry(sm) {\n        return new KvStoredEntryImpl(this.bucket, this.prefixLen, sm);\n    }\n    jmToEntry(jm) {\n        const key = this.decodeKey(jm.subject.substring(this.prefixLen));\n        return new KvJsMsgEntryImpl(this.bucket, key, jm);\n    }\n    create(k, data) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            let firstErr;\n            try {\n                const n = yield this.put(k, data, { previousSeq: 0 });\n                return Promise.resolve(n);\n            }\n            catch (err) {\n                firstErr = err;\n                if (((_a = err === null || err === void 0 ? void 0 : err.api_error) === null || _a === void 0 ? void 0 : _a.err_code) !== 10071) {\n                    return Promise.reject(err);\n                }\n            }\n            let rev = 0;\n            try {\n                const e = yield this.get(k);\n                if ((e === null || e === void 0 ? void 0 : e.operation) === \"DEL\" || (e === null || e === void 0 ? void 0 : e.operation) === \"PURGE\") {\n                    rev = e !== null ? e.revision : 0;\n                    return this.update(k, data, rev);\n                }\n                else {\n                    return Promise.reject(firstErr);\n                }\n            }\n            catch (err) {\n                return Promise.reject(err);\n            }\n        });\n    }\n    update(k, data, version) {\n        if (version <= 0) {\n            throw new Error(\"version must be greater than 0\");\n        }\n        return this.put(k, data, { previousSeq: version });\n    }\n    put(k, data, opts = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const ek = this.encodeKey(k);\n            this.validateKey(ek);\n            const o = {};\n            if (opts.previousSeq !== undefined) {\n                const h = (0, headers_1.headers)();\n                o.headers = h;\n                h.set(jsclient_1.PubHeaders.ExpectedLastSubjectSequenceHdr, `${opts.previousSeq}`);\n            }\n            try {\n                const pa = yield this.js.publish(this.subjectForKey(ek, true), data, o);\n                return pa.seq;\n            }\n            catch (err) {\n                const ne = err;\n                if (ne.isJetStreamError()) {\n                    ne.message = (_a = ne.api_error) === null || _a === void 0 ? void 0 : _a.description;\n                    ne.code = `${(_b = ne.api_error) === null || _b === void 0 ? void 0 : _b.code}`;\n                    return Promise.reject(ne);\n                }\n                return Promise.reject(err);\n            }\n        });\n    }\n    get(k, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ek = this.encodeKey(k);\n            this.validateKey(ek);\n            let arg = { last_by_subj: this.subjectForKey(ek) };\n            if (opts && opts.revision > 0) {\n                arg = { seq: opts.revision };\n            }\n            let sm;\n            try {\n                if (this.direct) {\n                    const direct = this.jsm.direct;\n                    sm = yield direct.getMessage(this.bucketName(), arg);\n                }\n                else {\n                    sm = yield this.jsm.streams.getMessage(this.bucketName(), arg);\n                }\n                const ke = this.smToEntry(sm);\n                if (ke.key !== ek) {\n                    return null;\n                }\n                return ke;\n            }\n            catch (err) {\n                if (err.code === core_1.ErrorCode.JetStream404NoMessages) {\n                    return null;\n                }\n                throw err;\n            }\n        });\n    }\n    purge(k) {\n        return this._deleteOrPurge(k, \"PURGE\");\n    }\n    delete(k) {\n        return this._deleteOrPurge(k, \"DEL\");\n    }\n    purgeDeletes(olderMillis = 30 * 60 * 1000) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const done = (0, util_1.deferred)();\n            const buf = [];\n            const i = yield this.watch({\n                key: \">\",\n                initializedFn: () => {\n                    done.resolve();\n                },\n            });\n            (() => __awaiter(this, void 0, void 0, function* () {\n                var _a, e_1, _b, _c;\n                try {\n                    for (var _d = true, i_1 = __asyncValues(i), i_1_1; i_1_1 = yield i_1.next(), _a = i_1_1.done, !_a; _d = true) {\n                        _c = i_1_1.value;\n                        _d = false;\n                        const e = _c;\n                        if (e.operation === \"DEL\" || e.operation === \"PURGE\") {\n                            buf.push(e);\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = i_1.return)) yield _b.call(i_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n            }))().then();\n            yield done;\n            i.stop();\n            const min = Date.now() - olderMillis;\n            const proms = buf.map((e) => {\n                const subj = this.subjectForKey(e.key);\n                if (e.created.getTime() >= min) {\n                    return this.jsm.streams.purge(this.stream, { filter: subj, keep: 1 });\n                }\n                else {\n                    return this.jsm.streams.purge(this.stream, { filter: subj, keep: 0 });\n                }\n            });\n            const purged = yield Promise.all(proms);\n            purged.unshift({ success: true, purged: 0 });\n            return purged.reduce((pv, cv) => {\n                pv.purged += cv.purged;\n                return pv;\n            });\n        });\n    }\n    _deleteOrPurge(k, op) {\n        var _a, e_2, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.hasWildcards(k)) {\n                return this._doDeleteOrPurge(k, op);\n            }\n            const iter = yield this.keys(k);\n            const buf = [];\n            try {\n                for (var _d = true, iter_1 = __asyncValues(iter), iter_1_1; iter_1_1 = yield iter_1.next(), _a = iter_1_1.done, !_a; _d = true) {\n                    _c = iter_1_1.value;\n                    _d = false;\n                    const k = _c;\n                    buf.push(this._doDeleteOrPurge(k, op));\n                    if (buf.length === 100) {\n                        yield Promise.all(buf);\n                        buf.length = 0;\n                    }\n                }\n            }\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iter_1.return)) yield _b.call(iter_1);\n                }\n                finally { if (e_2) throw e_2.error; }\n            }\n            if (buf.length > 0) {\n                yield Promise.all(buf);\n            }\n        });\n    }\n    _doDeleteOrPurge(k, op) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ek = this.encodeKey(k);\n            this.validateKey(ek);\n            const h = (0, headers_1.headers)();\n            h.set(exports.kvOperationHdr, op);\n            if (op === \"PURGE\") {\n                h.set(types_1.JsHeaders.RollupHdr, types_1.JsHeaders.RollupValueSubject);\n            }\n            yield this.js.publish(this.subjectForKey(ek, true), encoders_1.Empty, { headers: h });\n        });\n    }\n    _buildCC(k, content, opts = {}) {\n        const ek = this.encodeKey(k);\n        this.validateSearchKey(k);\n        let deliver_policy = jsapi_types_1.DeliverPolicy.LastPerSubject;\n        if (content === types_1.KvWatchInclude.AllHistory) {\n            deliver_policy = jsapi_types_1.DeliverPolicy.All;\n        }\n        if (content === types_1.KvWatchInclude.UpdatesOnly) {\n            deliver_policy = jsapi_types_1.DeliverPolicy.New;\n        }\n        return Object.assign({\n            deliver_policy,\n            \"ack_policy\": jsapi_types_1.AckPolicy.None,\n            \"filter_subject\": this.fullKeyName(ek),\n            \"flow_control\": true,\n            \"idle_heartbeat\": (0, jsutil_1.nanos)(5 * 1000),\n        }, opts);\n    }\n    remove(k) {\n        return this.purge(k);\n    }\n    history(opts = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const k = (_a = opts.key) !== null && _a !== void 0 ? _a : \">\";\n            const qi = new queued_iterator_1.QueuedIteratorImpl();\n            const co = {};\n            co.headers_only = opts.headers_only || false;\n            let fn;\n            fn = () => {\n                qi.stop();\n            };\n            let count = 0;\n            const cc = this._buildCC(k, types_1.KvWatchInclude.AllHistory, co);\n            const subj = cc.filter_subject;\n            const copts = (0, types_1.consumerOpts)(cc);\n            copts.bindStream(this.stream);\n            copts.orderedConsumer();\n            copts.callback((err, jm) => {\n                if (err) {\n                    // sub done\n                    qi.stop(err);\n                    return;\n                }\n                if (jm) {\n                    const e = this.jmToEntry(jm);\n                    qi.push(e);\n                    qi.received++;\n                    //@ts-ignore - function will be removed\n                    if (fn && count > 0 && qi.received >= count || jm.info.pending === 0) {\n                        //@ts-ignore: we are injecting an unexpected type\n                        qi.push(fn);\n                        fn = undefined;\n                    }\n                }\n            });\n            const sub = yield this.js.subscribe(subj, copts);\n            // by the time we are here, likely the subscription got messages\n            if (fn) {\n                const { info: { last } } = sub;\n                // this doesn't sound correct - we should be looking for a seq number instead\n                // then if we see a greater one, we are done.\n                const expect = last.num_pending + last.delivered.consumer_seq;\n                // if the iterator already queued - the only issue is other modifications\n                // did happen like stream was pruned, and the ordered consumer reset, etc\n                // we won't get what we are expecting - so the notification will never fire\n                // the sentinel ought to be coming from the server\n                if (expect === 0 || qi.received >= expect) {\n                    try {\n                        fn();\n                    }\n                    catch (err) {\n                        // fail it - there's something wrong in the user callback\n                        qi.stop(err);\n                    }\n                    finally {\n                        fn = undefined;\n                    }\n                }\n                else {\n                    count = expect;\n                }\n            }\n            qi._data = sub;\n            qi.iterClosed.then(() => {\n                sub.unsubscribe();\n            });\n            sub.closed.then(() => {\n                qi.stop();\n            }).catch((err) => {\n                qi.stop(err);\n            });\n            return qi;\n        });\n    }\n    watch(opts = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const k = (_a = opts.key) !== null && _a !== void 0 ? _a : \">\";\n            const qi = new queued_iterator_1.QueuedIteratorImpl();\n            const co = {};\n            co.headers_only = opts.headers_only || false;\n            let content = types_1.KvWatchInclude.LastValue;\n            if (opts.include === types_1.KvWatchInclude.AllHistory) {\n                content = types_1.KvWatchInclude.AllHistory;\n            }\n            else if (opts.include === types_1.KvWatchInclude.UpdatesOnly) {\n                content = types_1.KvWatchInclude.UpdatesOnly;\n            }\n            const ignoreDeletes = opts.ignoreDeletes === true;\n            let fn = opts.initializedFn;\n            let count = 0;\n            const cc = this._buildCC(k, content, co);\n            const subj = cc.filter_subject;\n            const copts = (0, types_1.consumerOpts)(cc);\n            copts.bindStream(this.stream);\n            copts.orderedConsumer();\n            copts.callback((err, jm) => {\n                if (err) {\n                    // sub done\n                    qi.stop(err);\n                    return;\n                }\n                if (jm) {\n                    const e = this.jmToEntry(jm);\n                    if (ignoreDeletes && e.operation === \"DEL\") {\n                        return;\n                    }\n                    qi.push(e);\n                    qi.received++;\n                    // count could have changed or has already been received\n                    if (fn && (count > 0 && qi.received >= count || jm.info.pending === 0)) {\n                        //@ts-ignore: we are injecting an unexpected type\n                        qi.push(fn);\n                        fn = undefined;\n                    }\n                }\n            });\n            const sub = yield this.js.subscribe(subj, copts);\n            // by the time we are here, likely the subscription got messages\n            if (fn) {\n                const { info: { last } } = sub;\n                // this doesn't sound correct - we should be looking for a seq number instead\n                // then if we see a greater one, we are done.\n                const expect = last.num_pending + last.delivered.consumer_seq;\n                // if the iterator already queued - the only issue is other modifications\n                // did happen like stream was pruned, and the ordered consumer reset, etc\n                // we won't get what we are expecting - so the notification will never fire\n                // the sentinel ought to be coming from the server\n                if (expect === 0 || qi.received >= expect) {\n                    try {\n                        fn();\n                    }\n                    catch (err) {\n                        // fail it - there's something wrong in the user callback\n                        qi.stop(err);\n                    }\n                    finally {\n                        fn = undefined;\n                    }\n                }\n                else {\n                    count = expect;\n                }\n            }\n            qi._data = sub;\n            qi.iterClosed.then(() => {\n                sub.unsubscribe();\n            });\n            sub.closed.then(() => {\n                qi.stop();\n            }).catch((err) => {\n                qi.stop(err);\n            });\n            return qi;\n        });\n    }\n    keys(k = \">\") {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keys = new queued_iterator_1.QueuedIteratorImpl();\n            const cc = this._buildCC(k, types_1.KvWatchInclude.LastValue, {\n                headers_only: true,\n            });\n            const subj = cc.filter_subject;\n            const copts = (0, types_1.consumerOpts)(cc);\n            copts.bindStream(this.stream);\n            copts.orderedConsumer();\n            const sub = yield this.js.subscribe(subj, copts);\n            (() => __awaiter(this, void 0, void 0, function* () {\n                var _a, e_3, _b, _c;\n                var _d;\n                try {\n                    for (var _e = true, sub_1 = __asyncValues(sub), sub_1_1; sub_1_1 = yield sub_1.next(), _a = sub_1_1.done, !_a; _e = true) {\n                        _c = sub_1_1.value;\n                        _e = false;\n                        const jm = _c;\n                        const op = (_d = jm.headers) === null || _d === void 0 ? void 0 : _d.get(exports.kvOperationHdr);\n                        if (op !== \"DEL\" && op !== \"PURGE\") {\n                            const key = this.decodeKey(jm.subject.substring(this.prefixLen));\n                            keys.push(key);\n                        }\n                        if (jm.info.pending === 0) {\n                            sub.unsubscribe();\n                        }\n                    }\n                }\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                finally {\n                    try {\n                        if (!_e && !_a && (_b = sub_1.return)) yield _b.call(sub_1);\n                    }\n                    finally { if (e_3) throw e_3.error; }\n                }\n            }))()\n                .then(() => {\n                keys.stop();\n            })\n                .catch((err) => {\n                keys.stop(err);\n            });\n            const si = sub;\n            if (si.info.last.num_pending === 0) {\n                sub.unsubscribe();\n            }\n            return keys;\n        });\n    }\n    purgeBucket(opts) {\n        return this.jsm.streams.purge(this.bucketName(), opts);\n    }\n    destroy() {\n        return this.jsm.streams.delete(this.bucketName());\n    }\n    status() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const nc = this.js.nc;\n            const cluster = (_b = (_a = nc.info) === null || _a === void 0 ? void 0 : _a.cluster) !== null && _b !== void 0 ? _b : \"\";\n            const bn = this.bucketName();\n            const si = yield this.jsm.streams.info(bn);\n            return new KvStatusImpl(si, cluster);\n        });\n    }\n}\nexports.Bucket = Bucket;\nclass KvStatusImpl {\n    constructor(si, cluster = \"\") {\n        this.si = si;\n        this.cluster = cluster;\n    }\n    get bucket() {\n        return this.si.config.name.startsWith(types_1.kvPrefix)\n            ? this.si.config.name.substring(types_1.kvPrefix.length)\n            : this.si.config.name;\n    }\n    get values() {\n        return this.si.state.messages;\n    }\n    get history() {\n        return this.si.config.max_msgs_per_subject;\n    }\n    get ttl() {\n        return (0, jsutil_1.millis)(this.si.config.max_age);\n    }\n    get bucket_location() {\n        return this.cluster;\n    }\n    get backingStore() {\n        return this.si.config.storage;\n    }\n    get storage() {\n        return this.si.config.storage;\n    }\n    get replicas() {\n        return this.si.config.num_replicas;\n    }\n    get description() {\n        var _a;\n        return (_a = this.si.config.description) !== null && _a !== void 0 ? _a : \"\";\n    }\n    get maxBucketSize() {\n        return this.si.config.max_bytes;\n    }\n    get maxValueSize() {\n        return this.si.config.max_msg_size;\n    }\n    get max_bytes() {\n        return this.si.config.max_bytes;\n    }\n    get placement() {\n        return this.si.config.placement || { cluster: \"\", tags: [] };\n    }\n    get placementCluster() {\n        var _a, _b;\n        return (_b = (_a = this.si.config.placement) === null || _a === void 0 ? void 0 : _a.cluster) !== null && _b !== void 0 ? _b : \"\";\n    }\n    get republish() {\n        var _a;\n        return (_a = this.si.config.republish) !== null && _a !== void 0 ? _a : { src: \"\", dest: \"\" };\n    }\n    get streamInfo() {\n        return this.si;\n    }\n    get size() {\n        return this.si.state.bytes;\n    }\n    get metadata() {\n        var _a;\n        return (_a = this.si.config.metadata) !== null && _a !== void 0 ? _a : {};\n    }\n    get compression() {\n        if (this.si.config.compression) {\n            return this.si.config.compression !== jsapi_types_1.StoreCompression.None;\n        }\n        return false;\n    }\n}\nexports.KvStatusImpl = KvStatusImpl;\nclass KvStoredEntryImpl {\n    constructor(bucket, prefixLen, sm) {\n        this.bucket = bucket;\n        this.prefixLen = prefixLen;\n        this.sm = sm;\n    }\n    get key() {\n        return this.sm.subject.substring(this.prefixLen);\n    }\n    get value() {\n        return this.sm.data;\n    }\n    get delta() {\n        return 0;\n    }\n    get created() {\n        return this.sm.time;\n    }\n    get revision() {\n        return this.sm.seq;\n    }\n    get operation() {\n        return this.sm.header.get(exports.kvOperationHdr) || \"PUT\";\n    }\n    get length() {\n        const slen = this.sm.header.get(types_1.JsHeaders.MessageSizeHdr) || \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return this.sm.data.length;\n    }\n    json() {\n        return this.sm.json();\n    }\n    string() {\n        return this.sm.string();\n    }\n}\nclass KvJsMsgEntryImpl {\n    constructor(bucket, key, sm) {\n        this.bucket = bucket;\n        this.key = key;\n        this.sm = sm;\n    }\n    get value() {\n        return this.sm.data;\n    }\n    get created() {\n        return new Date((0, jsutil_1.millis)(this.sm.info.timestampNanos));\n    }\n    get revision() {\n        return this.sm.seq;\n    }\n    get operation() {\n        var _a;\n        return ((_a = this.sm.headers) === null || _a === void 0 ? void 0 : _a.get(exports.kvOperationHdr)) || \"PUT\";\n    }\n    get delta() {\n        return this.sm.info.pending;\n    }\n    get length() {\n        var _a;\n        const slen = ((_a = this.sm.headers) === null || _a === void 0 ? void 0 : _a.get(types_1.JsHeaders.MessageSizeHdr)) || \"\";\n        if (slen !== \"\") {\n            return parseInt(slen, 10);\n        }\n        return this.sm.data.length;\n    }\n    json() {\n        return this.sm.json();\n    }\n    string() {\n        return this.sm.string();\n    }\n}\n//# sourceMappingURL=kv.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2t2LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsdUZBQXVGLGNBQWM7QUFDaE4sdUJBQXVCLDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxjQUFjLEdBQUcsc0JBQXNCLEdBQUcsb0JBQW9CLEdBQUcseUJBQXlCLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcseUJBQXlCLEdBQUcsb0JBQW9CLEdBQUcsc0JBQXNCO0FBQzVPLGVBQWUsbUJBQU8sQ0FBQyx3RkFBMEI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkMsMEJBQTBCLG1CQUFPLENBQUMsOEdBQXFDO0FBQ3ZFLGtCQUFrQixtQkFBTyxDQUFDLDhGQUE2QjtBQUN2RCxnQkFBZ0IsbUJBQU8sQ0FBQyxpRUFBUztBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyw0RkFBNEI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLHdGQUEwQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyxnR0FBOEI7QUFDekQsc0JBQXNCLG1CQUFPLENBQUMsNkVBQWU7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsdUVBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL2t2LmpzPzJmNjgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19hc3luY1ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX19hc3luY1ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5LdlN0YXR1c0ltcGwgPSBleHBvcnRzLkJ1Y2tldCA9IGV4cG9ydHMudmFsaWRhdGVCdWNrZXQgPSBleHBvcnRzLmhhc1dpbGRjYXJkcyA9IGV4cG9ydHMudmFsaWRhdGVTZWFyY2hLZXkgPSBleHBvcnRzLnZhbGlkYXRlS2V5ID0gZXhwb3J0cy5rdk9wZXJhdGlvbkhkciA9IGV4cG9ydHMuZGVmYXVsdEJ1Y2tldE9wdHMgPSBleHBvcnRzLk5vb3BLdkNvZGVjcyA9IGV4cG9ydHMuQmFzZTY0S2V5Q29kZWMgPSB2b2lkIDA7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9jb3JlXCIpO1xuY29uc3QganN1dGlsXzEgPSByZXF1aXJlKFwiLi9qc3V0aWxcIik7XG5jb25zdCBxdWV1ZWRfaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3F1ZXVlZF9pdGVyYXRvclwiKTtcbmNvbnN0IGhlYWRlcnNfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L2hlYWRlcnNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3NlbXZlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3V0aWxcIik7XG5jb25zdCBlbmNvZGVyc18xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvZW5jb2RlcnNcIik7XG5jb25zdCBqc2FwaV90eXBlc18xID0gcmVxdWlyZShcIi4vanNhcGlfdHlwZXNcIik7XG5jb25zdCBqc2NsaWVudF8xID0gcmVxdWlyZShcIi4vanNjbGllbnRcIik7XG5mdW5jdGlvbiBCYXNlNjRLZXlDb2RlYygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gYnRvYShrZXkpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoYmtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGF0b2IoYmtleSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuQmFzZTY0S2V5Q29kZWMgPSBCYXNlNjRLZXlDb2RlYztcbmZ1bmN0aW9uIE5vb3BLdkNvZGVjcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgIGVuY29kZShrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGs7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVjb2RlKGspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBlbmNvZGUodikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlY29kZSh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLk5vb3BLdkNvZGVjcyA9IE5vb3BLdkNvZGVjcztcbmZ1bmN0aW9uIGRlZmF1bHRCdWNrZXRPcHRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlcGxpY2FzOiAxLFxuICAgICAgICBoaXN0b3J5OiAxLFxuICAgICAgICB0aW1lb3V0OiAyMDAwLFxuICAgICAgICBtYXhCdWNrZXRTaXplOiAtMSxcbiAgICAgICAgbWF4VmFsdWVTaXplOiAtMSxcbiAgICAgICAgY29kZWM6IE5vb3BLdkNvZGVjcygpLFxuICAgICAgICBzdG9yYWdlOiBqc2FwaV90eXBlc18xLlN0b3JhZ2VUeXBlLkZpbGUsXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdEJ1Y2tldE9wdHMgPSBkZWZhdWx0QnVja2V0T3B0cztcbmV4cG9ydHMua3ZPcGVyYXRpb25IZHIgPSBcIktWLU9wZXJhdGlvblwiO1xuY29uc3Qga3ZTdWJqZWN0UHJlZml4ID0gXCIkS1ZcIjtcbmNvbnN0IHZhbGlkS2V5UmUgPSAvXlstLz0uXFx3XSskLztcbmNvbnN0IHZhbGlkU2VhcmNoS2V5ID0gL15bLS89Lj4qXFx3XSskLztcbmNvbnN0IHZhbGlkQnVja2V0UmUgPSAvXlstXFx3XSskLztcbi8vIHRoaXMgZXhwb3J0ZWQgZm9yIHRlc3RzXG5mdW5jdGlvbiB2YWxpZGF0ZUtleShrKSB7XG4gICAgaWYgKGsuc3RhcnRzV2l0aChcIi5cIikgfHwgay5lbmRzV2l0aChcIi5cIikgfHwgIXZhbGlkS2V5UmUudGVzdChrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQga2V5OiAke2t9YCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUtleSA9IHZhbGlkYXRlS2V5O1xuZnVuY3Rpb24gdmFsaWRhdGVTZWFyY2hLZXkoaykge1xuICAgIGlmIChrLnN0YXJ0c1dpdGgoXCIuXCIpIHx8IGsuZW5kc1dpdGgoXCIuXCIpIHx8ICF2YWxpZFNlYXJjaEtleS50ZXN0KGspKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBrZXk6ICR7a31gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU2VhcmNoS2V5ID0gdmFsaWRhdGVTZWFyY2hLZXk7XG5mdW5jdGlvbiBoYXNXaWxkY2FyZHMoaykge1xuICAgIGlmIChrLnN0YXJ0c1dpdGgoXCIuXCIpIHx8IGsuZW5kc1dpdGgoXCIuXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBrZXk6ICR7a31gKTtcbiAgICB9XG4gICAgY29uc3QgY2h1bmtzID0gay5zcGxpdChcIi5cIik7XG4gICAgbGV0IGhhc1dpbGRjYXJkcyA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAoY2h1bmtzW2ldKSB7XG4gICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgIGhhc1dpbGRjYXJkcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBjaHVua3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQga2V5OiAke2t9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhc1dpbGRjYXJkcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gY29udGludWVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzV2lsZGNhcmRzO1xufVxuZXhwb3J0cy5oYXNXaWxkY2FyZHMgPSBoYXNXaWxkY2FyZHM7XG4vLyB0aGlzIGV4cG9ydGVkIGZvciB0ZXN0c1xuZnVuY3Rpb24gdmFsaWRhdGVCdWNrZXQobmFtZSkge1xuICAgIGlmICghdmFsaWRCdWNrZXRSZS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBidWNrZXQgbmFtZTogJHtuYW1lfWApO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVCdWNrZXQgPSB2YWxpZGF0ZUJ1Y2tldDtcbmNsYXNzIEJ1Y2tldCB7XG4gICAgY29uc3RydWN0b3IoYnVja2V0LCBqcywganNtKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGVLZXkgPSB2YWxpZGF0ZUtleTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVNlYXJjaEtleSA9IHZhbGlkYXRlU2VhcmNoS2V5O1xuICAgICAgICB0aGlzLmhhc1dpbGRjYXJkcyA9IGhhc1dpbGRjYXJkcztcbiAgICAgICAgdmFsaWRhdGVCdWNrZXQoYnVja2V0KTtcbiAgICAgICAgdGhpcy5qcyA9IGpzO1xuICAgICAgICB0aGlzLmpzbSA9IGpzbTtcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIHRoaXMucHJlZml4ID0ga3ZTdWJqZWN0UHJlZml4O1xuICAgICAgICB0aGlzLmVkaXRQcmVmaXggPSBcIlwiO1xuICAgICAgICB0aGlzLnVzZUpzUHJlZml4ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ByZWZpeExlbiA9IDA7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoanMsIG5hbWUsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdmFsaWRhdGVCdWNrZXQobmFtZSk7XG4gICAgICAgICAgICBjb25zdCBqc20gPSB5aWVsZCBqcy5qZXRzdHJlYW1NYW5hZ2VyKCk7XG4gICAgICAgICAgICBjb25zdCBidWNrZXQgPSBuZXcgQnVja2V0KG5hbWUsIGpzLCBqc20pO1xuICAgICAgICAgICAgeWllbGQgYnVja2V0LmluaXQob3B0cyk7XG4gICAgICAgICAgICByZXR1cm4gYnVja2V0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGJpbmQoanMsIG5hbWUsIG9wdHMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBqc20gPSB5aWVsZCBqcy5qZXRzdHJlYW1NYW5hZ2VyKCk7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0geWllbGQganNtLnN0cmVhbXMuaW5mbyhgJHt0eXBlc18xLmt2UHJlZml4fSR7bmFtZX1gKTtcbiAgICAgICAgICAgIHZhbGlkYXRlQnVja2V0KGluZm8uY29uZmlnLm5hbWUpO1xuICAgICAgICAgICAgY29uc3QgYnVja2V0ID0gbmV3IEJ1Y2tldChuYW1lLCBqcywganNtKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYnVja2V0LCBpbmZvKTtcbiAgICAgICAgICAgIGJ1Y2tldC5jb2RlYyA9IG9wdHMuY29kZWMgfHwgTm9vcEt2Q29kZWNzKCk7XG4gICAgICAgICAgICBidWNrZXQuZGlyZWN0ID0gKF9hID0gaW5mby5jb25maWcuYWxsb3dfZGlyZWN0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgICAgIGJ1Y2tldC5pbml0aWFsaXplUHJlZml4ZXMoaW5mbyk7XG4gICAgICAgICAgICByZXR1cm4gYnVja2V0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5pdChvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0QnVja2V0T3B0cygpLCBvcHRzKTtcbiAgICAgICAgICAgIHRoaXMuY29kZWMgPSBiby5jb2RlYztcbiAgICAgICAgICAgIGNvbnN0IHNjID0ge307XG4gICAgICAgICAgICB0aGlzLnN0cmVhbSA9IHNjLm5hbWUgPSAoX2EgPSBvcHRzLnN0cmVhbU5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuYnVja2V0TmFtZSgpO1xuICAgICAgICAgICAgc2MucmV0ZW50aW9uID0ganNhcGlfdHlwZXNfMS5SZXRlbnRpb25Qb2xpY3kuTGltaXRzO1xuICAgICAgICAgICAgc2MubWF4X21zZ3NfcGVyX3N1YmplY3QgPSBiby5oaXN0b3J5O1xuICAgICAgICAgICAgaWYgKGJvLm1heEJ1Y2tldFNpemUpIHtcbiAgICAgICAgICAgICAgICBiby5tYXhfYnl0ZXMgPSBiby5tYXhCdWNrZXRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJvLm1heF9ieXRlcykge1xuICAgICAgICAgICAgICAgIHNjLm1heF9ieXRlcyA9IGJvLm1heF9ieXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjLm1heF9tc2dfc2l6ZSA9IGJvLm1heFZhbHVlU2l6ZTtcbiAgICAgICAgICAgIHNjLnN0b3JhZ2UgPSBiby5zdG9yYWdlO1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSAoX2IgPSBvcHRzLnBsYWNlbWVudENsdXN0ZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgICAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBvcHRzLnBsYWNlbWVudCA9IHt9O1xuICAgICAgICAgICAgICAgIG9wdHMucGxhY2VtZW50LmNsdXN0ZXIgPSBsb2NhdGlvbjtcbiAgICAgICAgICAgICAgICBvcHRzLnBsYWNlbWVudC50YWdzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzYy5wbGFjZW1lbnQgPSBvcHRzLnBsYWNlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnJlcHVibGlzaCkge1xuICAgICAgICAgICAgICAgIHNjLnJlcHVibGlzaCA9IG9wdHMucmVwdWJsaXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICBzYy5kZXNjcmlwdGlvbiA9IG9wdHMuZGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5taXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaXJyb3IgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzLm1pcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKCFtaXJyb3IubmFtZS5zdGFydHNXaXRoKHR5cGVzXzEua3ZQcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pcnJvci5uYW1lID0gYCR7dHlwZXNfMS5rdlByZWZpeH0ke21pcnJvci5uYW1lfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjLm1pcnJvciA9IG1pcnJvcjtcbiAgICAgICAgICAgICAgICBzYy5taXJyb3JfZGlyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdHMuc291cmNlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZXMgPSBvcHRzLnNvdXJjZXMubWFwKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBPYmplY3QuYXNzaWduKHt9LCBzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjLm5hbWUuc3RhcnRzV2l0aCh0eXBlc18xLmt2UHJlZml4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYy5uYW1lID0gYCR7dHlwZXNfMS5rdlByZWZpeH0ke2MubmFtZX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2Muc291cmNlcyA9IHNvdXJjZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzYy5zdWJqZWN0cyA9IFt0aGlzLnN1YmplY3RGb3JCdWNrZXQoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHNjLm1ldGFkYXRhID0gb3B0cy5tZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5jb21wcmVzc2lvbiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzYy5jb21wcmVzc2lvbiA9IG9wdHMuY29tcHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgPyBqc2FwaV90eXBlc18xLlN0b3JlQ29tcHJlc3Npb24uUzJcbiAgICAgICAgICAgICAgICAgICAgOiBqc2FwaV90eXBlc18xLlN0b3JlQ29tcHJlc3Npb24uTm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5jaSA9IHRoaXMuanMubmM7XG4gICAgICAgICAgICBjb25zdCBoYXZlID0gbmNpLmdldFNlcnZlclZlcnNpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NhcmROZXcgPSBoYXZlID8gKDAsIHNlbXZlcl8xLmNvbXBhcmUpKGhhdmUsICgwLCBzZW12ZXJfMS5wYXJzZVNlbVZlcikoXCIyLjcuMlwiKSkgPj0gMCA6IGZhbHNlO1xuICAgICAgICAgICAgc2MuZGlzY2FyZCA9IGRpc2NhcmROZXcgPyBqc2FwaV90eXBlc18xLkRpc2NhcmRQb2xpY3kuTmV3IDoganNhcGlfdHlwZXNfMS5EaXNjYXJkUG9saWN5Lk9sZDtcbiAgICAgICAgICAgIGNvbnN0IHsgb2s6IGRpcmVjdCwgbWluIH0gPSBuY2kuZmVhdHVyZXMuZ2V0KHNlbXZlcl8xLkZlYXR1cmUuSlNfQUxMT1dfRElSRUNUKTtcbiAgICAgICAgICAgIGlmICghZGlyZWN0ICYmIG9wdHMuYWxsb3dfZGlyZWN0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IGhhdmVcbiAgICAgICAgICAgICAgICAgICAgPyBgJHtoYXZlLm1ham9yfS4ke2hhdmUubWlub3J9LiR7aGF2ZS5taWNyb31gXG4gICAgICAgICAgICAgICAgICAgIDogXCJ1bmtub3duXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgYWxsb3dfZGlyZWN0IGlzIG5vdCBhdmFpbGFibGUgb24gc2VydmVyIHZlcnNpb24gJHt2fSAtIHJlcXVpcmVzICR7bWlufWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBnaXZlbiBhbGxvd19kaXJlY3Qgd2UgdXNlIGl0LCBvdGhlcndpc2Ugd2hhdFxuICAgICAgICAgICAgLy8gdGhlIHNlcnZlciBzdXBwb3J0cyAtIGluIGNyZWF0aW9uIHRoaXMgd2lsbCBhbHdheXMgcnVsZSxcbiAgICAgICAgICAgIC8vIGJ1dCBhbGxvd3MgdGhlIGNsaWVudCB0byBvcHQtaW4gZXZlbiBpZiBpdCBpcyBhbHJlYWR5XG4gICAgICAgICAgICAvLyBhdmFpbGFibGUgb24gdGhlIHN0cmVhbVxuICAgICAgICAgICAgb3B0cy5hbGxvd19kaXJlY3QgPSB0eXBlb2Ygb3B0cy5hbGxvd19kaXJlY3QgPT09IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgICAgPyBvcHRzLmFsbG93X2RpcmVjdFxuICAgICAgICAgICAgICAgIDogZGlyZWN0O1xuICAgICAgICAgICAgc2MuYWxsb3dfZGlyZWN0ID0gb3B0cy5hbGxvd19kaXJlY3Q7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdCA9IHNjLmFsbG93X2RpcmVjdDtcbiAgICAgICAgICAgIHNjLm51bV9yZXBsaWNhcyA9IGJvLnJlcGxpY2FzO1xuICAgICAgICAgICAgaWYgKGJvLnR0bCkge1xuICAgICAgICAgICAgICAgIHNjLm1heF9hZ2UgPSAoMCwganN1dGlsXzEubmFub3MpKGJvLnR0bCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzYy5hbGxvd19yb2xsdXBfaGRycyA9IHRydWU7XG4gICAgICAgICAgICBsZXQgaW5mbztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaW5mbyA9IHlpZWxkIHRoaXMuanNtLnN0cmVhbXMuaW5mbyhzYy5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWluZm8uY29uZmlnLmFsbG93X2RpcmVjdCAmJiB0aGlzLmRpcmVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgPT09IFwic3RyZWFtIG5vdCBmb3VuZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8gPSB5aWVsZCB0aGlzLmpzbS5zdHJlYW1zLmFkZChzYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplUHJlZml4ZXMoaW5mbyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbml0aWFsaXplUHJlZml4ZXMoaW5mbykge1xuICAgICAgICB0aGlzLl9wcmVmaXhMZW4gPSAwO1xuICAgICAgICB0aGlzLnByZWZpeCA9IGAkS1YuJHt0aGlzLmJ1Y2tldH1gO1xuICAgICAgICB0aGlzLnVzZUpzUHJlZml4ID0gdGhpcy5qcy5hcGlQcmVmaXggIT09IFwiJEpTLkFQSVwiO1xuICAgICAgICBjb25zdCB7IG1pcnJvciB9ID0gaW5mby5jb25maWc7XG4gICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICAgIGxldCBuID0gbWlycm9yLm5hbWU7XG4gICAgICAgICAgICBpZiAobi5zdGFydHNXaXRoKHR5cGVzXzEua3ZQcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgbiA9IG4uc3Vic3RyaW5nKHR5cGVzXzEua3ZQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtaXJyb3IuZXh0ZXJuYWwgJiYgbWlycm9yLmV4dGVybmFsLmFwaSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1iID0gbWlycm9yLm5hbWUuc3Vic3RyaW5nKHR5cGVzXzEua3ZQcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZUpzUHJlZml4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVmaXggPSBgJEtWLiR7bWJ9YDtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRQcmVmaXggPSBgJHttaXJyb3IuZXh0ZXJuYWwuYXBpfS4kS1YuJHtufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRQcmVmaXggPSB0aGlzLnByZWZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBidWNrZXROYW1lKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnN0cmVhbSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYCR7dHlwZXNfMS5rdlByZWZpeH0ke3RoaXMuYnVja2V0fWA7XG4gICAgfVxuICAgIHN1YmplY3RGb3JCdWNrZXQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnByZWZpeH0uJHt0aGlzLmJ1Y2tldH0uPmA7XG4gICAgfVxuICAgIHN1YmplY3RGb3JLZXkoaywgZWRpdCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBbXTtcbiAgICAgICAgaWYgKGVkaXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnVzZUpzUHJlZml4KSB7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5wdXNoKHRoaXMuanMuYXBpUHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRQcmVmaXggIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLnB1c2godGhpcy5lZGl0UHJlZml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1aWxkZXIucHVzaCh0aGlzLnByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLnB1c2godGhpcy5wcmVmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1aWxkZXIucHVzaChrKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuam9pbihcIi5cIik7XG4gICAgfVxuICAgIGZ1bGxLZXlOYW1lKGspIHtcbiAgICAgICAgaWYgKHRoaXMucHJlZml4ICE9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5wcmVmaXh9LiR7a31gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtrdlN1YmplY3RQcmVmaXh9LiR7dGhpcy5idWNrZXR9LiR7a31gO1xuICAgIH1cbiAgICBnZXQgcHJlZml4TGVuKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJlZml4TGVuID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmVmaXhMZW4gPSB0aGlzLnByZWZpeC5sZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVmaXhMZW47XG4gICAgfVxuICAgIGVuY29kZUtleShrZXkpIHtcbiAgICAgICAgY29uc3QgY2h1bmtzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBrZXkuc3BsaXQoXCIuXCIpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLmNvZGVjLmtleS5lbmNvZGUodCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtzLmpvaW4oXCIuXCIpO1xuICAgIH1cbiAgICBkZWNvZGVLZXkoZWtleSkge1xuICAgICAgICBjb25zdCBjaHVua3MgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0IG9mIGVrZXkuc3BsaXQoXCIuXCIpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaCh0aGlzLmNvZGVjLmtleS5kZWNvZGUodCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtzLmpvaW4oXCIuXCIpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBkYXRhTGVuKGRhdGEsIGgpIHtcbiAgICAgICAgY29uc3Qgc2xlbiA9IGggPyBoLmdldCh0eXBlc18xLkpzSGVhZGVycy5NZXNzYWdlU2l6ZUhkcikgfHwgXCJcIiA6IFwiXCI7XG4gICAgICAgIGlmIChzbGVuICE9PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoc2xlbiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgc21Ub0VudHJ5KHNtKSB7XG4gICAgICAgIHJldHVybiBuZXcgS3ZTdG9yZWRFbnRyeUltcGwodGhpcy5idWNrZXQsIHRoaXMucHJlZml4TGVuLCBzbSk7XG4gICAgfVxuICAgIGptVG9FbnRyeShqbSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmRlY29kZUtleShqbS5zdWJqZWN0LnN1YnN0cmluZyh0aGlzLnByZWZpeExlbikpO1xuICAgICAgICByZXR1cm4gbmV3IEt2SnNNc2dFbnRyeUltcGwodGhpcy5idWNrZXQsIGtleSwgam0pO1xuICAgIH1cbiAgICBjcmVhdGUoaywgZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3RFcnI7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSB5aWVsZCB0aGlzLnB1dChrLCBkYXRhLCB7IHByZXZpb3VzU2VxOiAwIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RFcnIgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuYXBpX2Vycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXJyX2NvZGUpICE9PSAxMDA3MSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmV2ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IHlpZWxkIHRoaXMuZ2V0KGspO1xuICAgICAgICAgICAgICAgIGlmICgoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm9wZXJhdGlvbikgPT09IFwiREVMXCIgfHwgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5vcGVyYXRpb24pID09PSBcIlBVUkdFXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ID0gZSAhPT0gbnVsbCA/IGUucmV2aXNpb24gOiAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUoaywgZGF0YSwgcmV2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChmaXJzdEVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlKGssIGRhdGEsIHZlcnNpb24pIHtcbiAgICAgICAgaWYgKHZlcnNpb24gPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmVyc2lvbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChrLCBkYXRhLCB7IHByZXZpb3VzU2VxOiB2ZXJzaW9uIH0pO1xuICAgIH1cbiAgICBwdXQoaywgZGF0YSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBlayA9IHRoaXMuZW5jb2RlS2V5KGspO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUtleShlayk7XG4gICAgICAgICAgICBjb25zdCBvID0ge307XG4gICAgICAgICAgICBpZiAob3B0cy5wcmV2aW91c1NlcSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaCA9ICgwLCBoZWFkZXJzXzEuaGVhZGVycykoKTtcbiAgICAgICAgICAgICAgICBvLmhlYWRlcnMgPSBoO1xuICAgICAgICAgICAgICAgIGguc2V0KGpzY2xpZW50XzEuUHViSGVhZGVycy5FeHBlY3RlZExhc3RTdWJqZWN0U2VxdWVuY2VIZHIsIGAke29wdHMucHJldmlvdXNTZXF9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhID0geWllbGQgdGhpcy5qcy5wdWJsaXNoKHRoaXMuc3ViamVjdEZvcktleShlaywgdHJ1ZSksIGRhdGEsIG8pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYS5zZXE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmUgPSBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKG5lLmlzSmV0U3RyZWFtRXJyb3IoKSkge1xuICAgICAgICAgICAgICAgICAgICBuZS5tZXNzYWdlID0gKF9hID0gbmUuYXBpX2Vycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgICAgIG5lLmNvZGUgPSBgJHsoX2IgPSBuZS5hcGlfZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb2RlfWA7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0KGssIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVrID0gdGhpcy5lbmNvZGVLZXkoayk7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlS2V5KGVrKTtcbiAgICAgICAgICAgIGxldCBhcmcgPSB7IGxhc3RfYnlfc3ViajogdGhpcy5zdWJqZWN0Rm9yS2V5KGVrKSB9O1xuICAgICAgICAgICAgaWYgKG9wdHMgJiYgb3B0cy5yZXZpc2lvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBhcmcgPSB7IHNlcTogb3B0cy5yZXZpc2lvbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHNtO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0ID0gdGhpcy5qc20uZGlyZWN0O1xuICAgICAgICAgICAgICAgICAgICBzbSA9IHlpZWxkIGRpcmVjdC5nZXRNZXNzYWdlKHRoaXMuYnVja2V0TmFtZSgpLCBhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc20gPSB5aWVsZCB0aGlzLmpzbS5zdHJlYW1zLmdldE1lc3NhZ2UodGhpcy5idWNrZXROYW1lKCksIGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtlID0gdGhpcy5zbVRvRW50cnkoc20pO1xuICAgICAgICAgICAgICAgIGlmIChrZS5rZXkgIT09IGVrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ga2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSBjb3JlXzEuRXJyb3JDb2RlLkpldFN0cmVhbTQwNE5vTWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHB1cmdlKGspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGV0ZU9yUHVyZ2UoaywgXCJQVVJHRVwiKTtcbiAgICB9XG4gICAgZGVsZXRlKGspIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGV0ZU9yUHVyZ2UoaywgXCJERUxcIik7XG4gICAgfVxuICAgIHB1cmdlRGVsZXRlcyhvbGRlck1pbGxpcyA9IDMwICogNjAgKiAxMDAwKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkb25lID0gKDAsIHV0aWxfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IFtdO1xuICAgICAgICAgICAgY29uc3QgaSA9IHlpZWxkIHRoaXMud2F0Y2goe1xuICAgICAgICAgICAgICAgIGtleTogXCI+XCIsXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWRGbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBkb25lLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpXzEgPSBfX2FzeW5jVmFsdWVzKGkpLCBpXzFfMTsgaV8xXzEgPSB5aWVsZCBpXzEubmV4dCgpLCBfYSA9IGlfMV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGlfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLm9wZXJhdGlvbiA9PT0gXCJERUxcIiB8fCBlLm9wZXJhdGlvbiA9PT0gXCJQVVJHRVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IGlfMS5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKGlfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSgpLnRoZW4oKTtcbiAgICAgICAgICAgIHlpZWxkIGRvbmU7XG4gICAgICAgICAgICBpLnN0b3AoKTtcbiAgICAgICAgICAgIGNvbnN0IG1pbiA9IERhdGUubm93KCkgLSBvbGRlck1pbGxpcztcbiAgICAgICAgICAgIGNvbnN0IHByb21zID0gYnVmLm1hcCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmogPSB0aGlzLnN1YmplY3RGb3JLZXkoZS5rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChlLmNyZWF0ZWQuZ2V0VGltZSgpID49IG1pbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLnN0cmVhbSwgeyBmaWx0ZXI6IHN1YmosIGtlZXA6IDEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLnN0cmVhbSwgeyBmaWx0ZXI6IHN1YmosIGtlZXA6IDAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBwdXJnZWQgPSB5aWVsZCBQcm9taXNlLmFsbChwcm9tcyk7XG4gICAgICAgICAgICBwdXJnZWQudW5zaGlmdCh7IHN1Y2Nlc3M6IHRydWUsIHB1cmdlZDogMCB9KTtcbiAgICAgICAgICAgIHJldHVybiBwdXJnZWQucmVkdWNlKChwdiwgY3YpID0+IHtcbiAgICAgICAgICAgICAgICBwdi5wdXJnZWQgKz0gY3YucHVyZ2VkO1xuICAgICAgICAgICAgICAgIHJldHVybiBwdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2RlbGV0ZU9yUHVyZ2Uoaywgb3ApIHtcbiAgICAgICAgdmFyIF9hLCBlXzIsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNXaWxkY2FyZHMoaykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9EZWxldGVPclB1cmdlKGssIG9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSB5aWVsZCB0aGlzLmtleXMoayk7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBpdGVyXzEgPSBfX2FzeW5jVmFsdWVzKGl0ZXIpLCBpdGVyXzFfMTsgaXRlcl8xXzEgPSB5aWVsZCBpdGVyXzEubmV4dCgpLCBfYSA9IGl0ZXJfMV8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gaXRlcl8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGsgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2godGhpcy5fZG9EZWxldGVPclB1cmdlKGssIG9wKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWYubGVuZ3RoID09PSAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKGJ1Zik7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWYubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyXzEucmV0dXJuKSkgeWllbGQgX2IuY2FsbChpdGVyXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChidWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2RvRGVsZXRlT3JQdXJnZShrLCBvcCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZWsgPSB0aGlzLmVuY29kZUtleShrKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVLZXkoZWspO1xuICAgICAgICAgICAgY29uc3QgaCA9ICgwLCBoZWFkZXJzXzEuaGVhZGVycykoKTtcbiAgICAgICAgICAgIGguc2V0KGV4cG9ydHMua3ZPcGVyYXRpb25IZHIsIG9wKTtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJQVVJHRVwiKSB7XG4gICAgICAgICAgICAgICAgaC5zZXQodHlwZXNfMS5Kc0hlYWRlcnMuUm9sbHVwSGRyLCB0eXBlc18xLkpzSGVhZGVycy5Sb2xsdXBWYWx1ZVN1YmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdGhpcy5qcy5wdWJsaXNoKHRoaXMuc3ViamVjdEZvcktleShlaywgdHJ1ZSksIGVuY29kZXJzXzEuRW1wdHksIHsgaGVhZGVyczogaCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9idWlsZENDKGssIGNvbnRlbnQsIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBlayA9IHRoaXMuZW5jb2RlS2V5KGspO1xuICAgICAgICB0aGlzLnZhbGlkYXRlU2VhcmNoS2V5KGspO1xuICAgICAgICBsZXQgZGVsaXZlcl9wb2xpY3kgPSBqc2FwaV90eXBlc18xLkRlbGl2ZXJQb2xpY3kuTGFzdFBlclN1YmplY3Q7XG4gICAgICAgIGlmIChjb250ZW50ID09PSB0eXBlc18xLkt2V2F0Y2hJbmNsdWRlLkFsbEhpc3RvcnkpIHtcbiAgICAgICAgICAgIGRlbGl2ZXJfcG9saWN5ID0ganNhcGlfdHlwZXNfMS5EZWxpdmVyUG9saWN5LkFsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udGVudCA9PT0gdHlwZXNfMS5LdldhdGNoSW5jbHVkZS5VcGRhdGVzT25seSkge1xuICAgICAgICAgICAgZGVsaXZlcl9wb2xpY3kgPSBqc2FwaV90eXBlc18xLkRlbGl2ZXJQb2xpY3kuTmV3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGRlbGl2ZXJfcG9saWN5LFxuICAgICAgICAgICAgXCJhY2tfcG9saWN5XCI6IGpzYXBpX3R5cGVzXzEuQWNrUG9saWN5Lk5vbmUsXG4gICAgICAgICAgICBcImZpbHRlcl9zdWJqZWN0XCI6IHRoaXMuZnVsbEtleU5hbWUoZWspLFxuICAgICAgICAgICAgXCJmbG93X2NvbnRyb2xcIjogdHJ1ZSxcbiAgICAgICAgICAgIFwiaWRsZV9oZWFydGJlYXRcIjogKDAsIGpzdXRpbF8xLm5hbm9zKSg1ICogMTAwMCksXG4gICAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICByZW1vdmUoaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdXJnZShrKTtcbiAgICB9XG4gICAgaGlzdG9yeShvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgayA9IChfYSA9IG9wdHMua2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIj5cIjtcbiAgICAgICAgICAgIGNvbnN0IHFpID0gbmV3IHF1ZXVlZF9pdGVyYXRvcl8xLlF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICAgICAgY29uc3QgY28gPSB7fTtcbiAgICAgICAgICAgIGNvLmhlYWRlcnNfb25seSA9IG9wdHMuaGVhZGVyc19vbmx5IHx8IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGZuO1xuICAgICAgICAgICAgZm4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcWkuc3RvcCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBjb25zdCBjYyA9IHRoaXMuX2J1aWxkQ0MoaywgdHlwZXNfMS5LdldhdGNoSW5jbHVkZS5BbGxIaXN0b3J5LCBjbyk7XG4gICAgICAgICAgICBjb25zdCBzdWJqID0gY2MuZmlsdGVyX3N1YmplY3Q7XG4gICAgICAgICAgICBjb25zdCBjb3B0cyA9ICgwLCB0eXBlc18xLmNvbnN1bWVyT3B0cykoY2MpO1xuICAgICAgICAgICAgY29wdHMuYmluZFN0cmVhbSh0aGlzLnN0cmVhbSk7XG4gICAgICAgICAgICBjb3B0cy5vcmRlcmVkQ29uc3VtZXIoKTtcbiAgICAgICAgICAgIGNvcHRzLmNhbGxiYWNrKChlcnIsIGptKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdWIgZG9uZVxuICAgICAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGptKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSB0aGlzLmptVG9FbnRyeShqbSk7XG4gICAgICAgICAgICAgICAgICAgIHFpLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgIHFpLnJlY2VpdmVkKys7XG4gICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIGZ1bmN0aW9uIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoZm4gJiYgY291bnQgPiAwICYmIHFpLnJlY2VpdmVkID49IGNvdW50IHx8IGptLmluZm8ucGVuZGluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlOiB3ZSBhcmUgaW5qZWN0aW5nIGFuIHVuZXhwZWN0ZWQgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgcWkucHVzaChmbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3ViID0geWllbGQgdGhpcy5qcy5zdWJzY3JpYmUoc3ViaiwgY29wdHMpO1xuICAgICAgICAgICAgLy8gYnkgdGhlIHRpbWUgd2UgYXJlIGhlcmUsIGxpa2VseSB0aGUgc3Vic2NyaXB0aW9uIGdvdCBtZXNzYWdlc1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmZvOiB7IGxhc3QgfSB9ID0gc3ViO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgZG9lc24ndCBzb3VuZCBjb3JyZWN0IC0gd2Ugc2hvdWxkIGJlIGxvb2tpbmcgZm9yIGEgc2VxIG51bWJlciBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgLy8gdGhlbiBpZiB3ZSBzZWUgYSBncmVhdGVyIG9uZSwgd2UgYXJlIGRvbmUuXG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ID0gbGFzdC5udW1fcGVuZGluZyArIGxhc3QuZGVsaXZlcmVkLmNvbnN1bWVyX3NlcTtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgaXRlcmF0b3IgYWxyZWFkeSBxdWV1ZWQgLSB0aGUgb25seSBpc3N1ZSBpcyBvdGhlciBtb2RpZmljYXRpb25zXG4gICAgICAgICAgICAgICAgLy8gZGlkIGhhcHBlbiBsaWtlIHN0cmVhbSB3YXMgcHJ1bmVkLCBhbmQgdGhlIG9yZGVyZWQgY29uc3VtZXIgcmVzZXQsIGV0Y1xuICAgICAgICAgICAgICAgIC8vIHdlIHdvbid0IGdldCB3aGF0IHdlIGFyZSBleHBlY3RpbmcgLSBzbyB0aGUgbm90aWZpY2F0aW9uIHdpbGwgbmV2ZXIgZmlyZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzZW50aW5lbCBvdWdodCB0byBiZSBjb21pbmcgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdCA9PT0gMCB8fCBxaS5yZWNlaXZlZCA+PSBleHBlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFpbCBpdCAtIHRoZXJlJ3Mgc29tZXRoaW5nIHdyb25nIGluIHRoZSB1c2VyIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQgPSBleHBlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcWkuX2RhdGEgPSBzdWI7XG4gICAgICAgICAgICBxaS5pdGVyQ2xvc2VkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdWIuY2xvc2VkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHFpLnN0b3AoKTtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBxaTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhdGNoKG9wdHMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gKF9hID0gb3B0cy5rZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiPlwiO1xuICAgICAgICAgICAgY29uc3QgcWkgPSBuZXcgcXVldWVkX2l0ZXJhdG9yXzEuUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgICAgICBjb25zdCBjbyA9IHt9O1xuICAgICAgICAgICAgY28uaGVhZGVyc19vbmx5ID0gb3B0cy5oZWFkZXJzX29ubHkgfHwgZmFsc2U7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHR5cGVzXzEuS3ZXYXRjaEluY2x1ZGUuTGFzdFZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdHMuaW5jbHVkZSA9PT0gdHlwZXNfMS5LdldhdGNoSW5jbHVkZS5BbGxIaXN0b3J5KSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHR5cGVzXzEuS3ZXYXRjaEluY2x1ZGUuQWxsSGlzdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdHMuaW5jbHVkZSA9PT0gdHlwZXNfMS5LdldhdGNoSW5jbHVkZS5VcGRhdGVzT25seSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0eXBlc18xLkt2V2F0Y2hJbmNsdWRlLlVwZGF0ZXNPbmx5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWdub3JlRGVsZXRlcyA9IG9wdHMuaWdub3JlRGVsZXRlcyA9PT0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBmbiA9IG9wdHMuaW5pdGlhbGl6ZWRGbjtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBjb25zdCBjYyA9IHRoaXMuX2J1aWxkQ0MoaywgY29udGVudCwgY28pO1xuICAgICAgICAgICAgY29uc3Qgc3ViaiA9IGNjLmZpbHRlcl9zdWJqZWN0O1xuICAgICAgICAgICAgY29uc3QgY29wdHMgPSAoMCwgdHlwZXNfMS5jb25zdW1lck9wdHMpKGNjKTtcbiAgICAgICAgICAgIGNvcHRzLmJpbmRTdHJlYW0odGhpcy5zdHJlYW0pO1xuICAgICAgICAgICAgY29wdHMub3JkZXJlZENvbnN1bWVyKCk7XG4gICAgICAgICAgICBjb3B0cy5jYWxsYmFjaygoZXJyLCBqbSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ViIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqbSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gdGhpcy5qbVRvRW50cnkoam0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlRGVsZXRlcyAmJiBlLm9wZXJhdGlvbiA9PT0gXCJERUxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHFpLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgICAgIHFpLnJlY2VpdmVkKys7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvdW50IGNvdWxkIGhhdmUgY2hhbmdlZCBvciBoYXMgYWxyZWFkeSBiZWVuIHJlY2VpdmVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbiAmJiAoY291bnQgPiAwICYmIHFpLnJlY2VpdmVkID49IGNvdW50IHx8IGptLmluZm8ucGVuZGluZyA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZTogd2UgYXJlIGluamVjdGluZyBhbiB1bmV4cGVjdGVkIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHFpLnB1c2goZm4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IHlpZWxkIHRoaXMuanMuc3Vic2NyaWJlKHN1YmosIGNvcHRzKTtcbiAgICAgICAgICAgIC8vIGJ5IHRoZSB0aW1lIHdlIGFyZSBoZXJlLCBsaWtlbHkgdGhlIHN1YnNjcmlwdGlvbiBnb3QgbWVzc2FnZXNcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaW5mbzogeyBsYXN0IH0gfSA9IHN1YjtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGRvZXNuJ3Qgc291bmQgY29ycmVjdCAtIHdlIHNob3VsZCBiZSBsb29raW5nIGZvciBhIHNlcSBudW1iZXIgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gaWYgd2Ugc2VlIGEgZ3JlYXRlciBvbmUsIHdlIGFyZSBkb25lLlxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdCA9IGxhc3QubnVtX3BlbmRpbmcgKyBsYXN0LmRlbGl2ZXJlZC5jb25zdW1lcl9zZXE7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGl0ZXJhdG9yIGFscmVhZHkgcXVldWVkIC0gdGhlIG9ubHkgaXNzdWUgaXMgb3RoZXIgbW9kaWZpY2F0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGRpZCBoYXBwZW4gbGlrZSBzdHJlYW0gd2FzIHBydW5lZCwgYW5kIHRoZSBvcmRlcmVkIGNvbnN1bWVyIHJlc2V0LCBldGNcbiAgICAgICAgICAgICAgICAvLyB3ZSB3b24ndCBnZXQgd2hhdCB3ZSBhcmUgZXhwZWN0aW5nIC0gc28gdGhlIG5vdGlmaWNhdGlvbiB3aWxsIG5ldmVyIGZpcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgc2VudGluZWwgb3VnaHQgdG8gYmUgY29taW5nIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgICAgICAgIGlmIChleHBlY3QgPT09IDAgfHwgcWkucmVjZWl2ZWQgPj0gZXhwZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhaWwgaXQgLSB0aGVyZSdzIHNvbWV0aGluZyB3cm9uZyBpbiB0aGUgdXNlciBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gZXhwZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHFpLl9kYXRhID0gc3ViO1xuICAgICAgICAgICAgcWkuaXRlckNsb3NlZC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3ViLmNsb3NlZC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBxaS5zdG9wKCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgcWkuc3RvcChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcWk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlzKGsgPSBcIj5cIikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IG5ldyBxdWV1ZWRfaXRlcmF0b3JfMS5RdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgICAgIGNvbnN0IGNjID0gdGhpcy5fYnVpbGRDQyhrLCB0eXBlc18xLkt2V2F0Y2hJbmNsdWRlLkxhc3RWYWx1ZSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNfb25seTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3ViaiA9IGNjLmZpbHRlcl9zdWJqZWN0O1xuICAgICAgICAgICAgY29uc3QgY29wdHMgPSAoMCwgdHlwZXNfMS5jb25zdW1lck9wdHMpKGNjKTtcbiAgICAgICAgICAgIGNvcHRzLmJpbmRTdHJlYW0odGhpcy5zdHJlYW0pO1xuICAgICAgICAgICAgY29wdHMub3JkZXJlZENvbnN1bWVyKCk7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSB5aWVsZCB0aGlzLmpzLnN1YnNjcmliZShzdWJqLCBjb3B0cyk7XG4gICAgICAgICAgICAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgZV8zLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgdmFyIF9kO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gdHJ1ZSwgc3ViXzEgPSBfX2FzeW5jVmFsdWVzKHN1YiksIHN1Yl8xXzE7IHN1Yl8xXzEgPSB5aWVsZCBzdWJfMS5uZXh0KCksIF9hID0gc3ViXzFfMS5kb25lLCAhX2E7IF9lID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBzdWJfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGptID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcCA9IChfZCA9IGptLmhlYWRlcnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5nZXQoZXhwb3J0cy5rdk9wZXJhdGlvbkhkcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3AgIT09IFwiREVMXCIgJiYgb3AgIT09IFwiUFVSR0VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZGVjb2RlS2V5KGptLnN1YmplY3Quc3Vic3RyaW5nKHRoaXMucHJlZml4TGVuKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoam0uaW5mby5wZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IHN1Yl8xLnJldHVybikpIHlpZWxkIF9iLmNhbGwoc3ViXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSkoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBrZXlzLnN0b3AoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBrZXlzLnN0b3AoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2kgPSBzdWI7XG4gICAgICAgICAgICBpZiAoc2kuaW5mby5sYXN0Lm51bV9wZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHB1cmdlQnVja2V0KG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNtLnN0cmVhbXMucHVyZ2UodGhpcy5idWNrZXROYW1lKCksIG9wdHMpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5qc20uc3RyZWFtcy5kZWxldGUodGhpcy5idWNrZXROYW1lKCkpO1xuICAgIH1cbiAgICBzdGF0dXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuYyA9IHRoaXMuanMubmM7XG4gICAgICAgICAgICBjb25zdCBjbHVzdGVyID0gKF9iID0gKF9hID0gbmMuaW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsdXN0ZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCI7XG4gICAgICAgICAgICBjb25zdCBibiA9IHRoaXMuYnVja2V0TmFtZSgpO1xuICAgICAgICAgICAgY29uc3Qgc2kgPSB5aWVsZCB0aGlzLmpzbS5zdHJlYW1zLmluZm8oYm4pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLdlN0YXR1c0ltcGwoc2ksIGNsdXN0ZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkJ1Y2tldCA9IEJ1Y2tldDtcbmNsYXNzIEt2U3RhdHVzSW1wbCB7XG4gICAgY29uc3RydWN0b3Ioc2ksIGNsdXN0ZXIgPSBcIlwiKSB7XG4gICAgICAgIHRoaXMuc2kgPSBzaTtcbiAgICAgICAgdGhpcy5jbHVzdGVyID0gY2x1c3RlcjtcbiAgICB9XG4gICAgZ2V0IGJ1Y2tldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm5hbWUuc3RhcnRzV2l0aCh0eXBlc18xLmt2UHJlZml4KVxuICAgICAgICAgICAgPyB0aGlzLnNpLmNvbmZpZy5uYW1lLnN1YnN0cmluZyh0eXBlc18xLmt2UHJlZml4Lmxlbmd0aClcbiAgICAgICAgICAgIDogdGhpcy5zaS5jb25maWcubmFtZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuc3RhdGUubWVzc2FnZXM7XG4gICAgfVxuICAgIGdldCBoaXN0b3J5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcubWF4X21zZ3NfcGVyX3N1YmplY3Q7XG4gICAgfVxuICAgIGdldCB0dGwoKSB7XG4gICAgICAgIHJldHVybiAoMCwganN1dGlsXzEubWlsbGlzKSh0aGlzLnNpLmNvbmZpZy5tYXhfYWdlKTtcbiAgICB9XG4gICAgZ2V0IGJ1Y2tldF9sb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2x1c3RlcjtcbiAgICB9XG4gICAgZ2V0IGJhY2tpbmdTdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLnN0b3JhZ2U7XG4gICAgfVxuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcuc3RvcmFnZTtcbiAgICB9XG4gICAgZ2V0IHJlcGxpY2FzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcubnVtX3JlcGxpY2FzO1xuICAgIH1cbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuc2kuY29uZmlnLmRlc2NyaXB0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgIH1cbiAgICBnZXQgbWF4QnVja2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm1heF9ieXRlcztcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm1heF9tc2dfc2l6ZTtcbiAgICB9XG4gICAgZ2V0IG1heF9ieXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm1heF9ieXRlcztcbiAgICB9XG4gICAgZ2V0IHBsYWNlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLnBsYWNlbWVudCB8fCB7IGNsdXN0ZXI6IFwiXCIsIHRhZ3M6IFtdIH07XG4gICAgfVxuICAgIGdldCBwbGFjZW1lbnRDbHVzdGVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5zaS5jb25maWcucGxhY2VtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2x1c3RlcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIjtcbiAgICB9XG4gICAgZ2V0IHJlcHVibGlzaCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5zaS5jb25maWcucmVwdWJsaXNoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7IHNyYzogXCJcIiwgZGVzdDogXCJcIiB9O1xuICAgIH1cbiAgICBnZXQgc3RyZWFtSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2k7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5zdGF0ZS5ieXRlcztcbiAgICB9XG4gICAgZ2V0IG1ldGFkYXRhKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnNpLmNvbmZpZy5tZXRhZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgfVxuICAgIGdldCBjb21wcmVzc2lvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2kuY29uZmlnLmNvbXByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcuY29tcHJlc3Npb24gIT09IGpzYXBpX3R5cGVzXzEuU3RvcmVDb21wcmVzc2lvbi5Ob25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkt2U3RhdHVzSW1wbCA9IEt2U3RhdHVzSW1wbDtcbmNsYXNzIEt2U3RvcmVkRW50cnlJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihidWNrZXQsIHByZWZpeExlbiwgc20pIHtcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIHRoaXMucHJlZml4TGVuID0gcHJlZml4TGVuO1xuICAgICAgICB0aGlzLnNtID0gc207XG4gICAgfVxuICAgIGdldCBrZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtLnN1YmplY3Quc3Vic3RyaW5nKHRoaXMucHJlZml4TGVuKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5kYXRhO1xuICAgIH1cbiAgICBnZXQgZGVsdGEoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBnZXQgY3JlYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20udGltZTtcbiAgICB9XG4gICAgZ2V0IHJldmlzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5zZXE7XG4gICAgfVxuICAgIGdldCBvcGVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtLmhlYWRlci5nZXQoZXhwb3J0cy5rdk9wZXJhdGlvbkhkcikgfHwgXCJQVVRcIjtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgY29uc3Qgc2xlbiA9IHRoaXMuc20uaGVhZGVyLmdldCh0eXBlc18xLkpzSGVhZGVycy5NZXNzYWdlU2l6ZUhkcikgfHwgXCJcIjtcbiAgICAgICAgaWYgKHNsZW4gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzbGVuLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc20uZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGpzb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtLmpzb24oKTtcbiAgICB9XG4gICAgc3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5zdHJpbmcoKTtcbiAgICB9XG59XG5jbGFzcyBLdkpzTXNnRW50cnlJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihidWNrZXQsIGtleSwgc20pIHtcbiAgICAgICAgdGhpcy5idWNrZXQgPSBidWNrZXQ7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnNtID0gc207XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20uZGF0YTtcbiAgICB9XG4gICAgZ2V0IGNyZWF0ZWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgoMCwganN1dGlsXzEubWlsbGlzKSh0aGlzLnNtLmluZm8udGltZXN0YW1wTmFub3MpKTtcbiAgICB9XG4gICAgZ2V0IHJldmlzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5zZXE7XG4gICAgfVxuICAgIGdldCBvcGVyYXRpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLnNtLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoZXhwb3J0cy5rdk9wZXJhdGlvbkhkcikpIHx8IFwiUFVUXCI7XG4gICAgfVxuICAgIGdldCBkZWx0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc20uaW5mby5wZW5kaW5nO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHNsZW4gPSAoKF9hID0gdGhpcy5zbS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KHR5cGVzXzEuSnNIZWFkZXJzLk1lc3NhZ2VTaXplSGRyKSkgfHwgXCJcIjtcbiAgICAgICAgaWYgKHNsZW4gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzbGVuLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc20uZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGpzb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtLmpzb24oKTtcbiAgICB9XG4gICAgc3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbS5zdHJpbmcoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1rdi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/kv.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/mod.js":
/*!************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/mod.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.consumerOpts = exports.StoreCompression = exports.StorageType = exports.RetentionPolicy = exports.RepublishHeaders = exports.ReplayPolicy = exports.JsHeaders = exports.DiscardPolicy = exports.DirectMsgHeaders = exports.DeliverPolicy = exports.ConsumerEvents = exports.ConsumerDebugEvents = exports.AdvisoryKind = exports.AckPolicy = exports.nanos = exports.millis = exports.isHeartbeatMsg = exports.isFlowControlMsg = exports.checkJsError = void 0;\n/*\n * Copyright 2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar internal_mod_1 = __webpack_require__(/*! ./internal_mod */ \"(rsc)/./node_modules/nats/lib/jetstream/internal_mod.js\");\nObject.defineProperty(exports, \"checkJsError\", ({ enumerable: true, get: function () { return internal_mod_1.checkJsError; } }));\nObject.defineProperty(exports, \"isFlowControlMsg\", ({ enumerable: true, get: function () { return internal_mod_1.isFlowControlMsg; } }));\nObject.defineProperty(exports, \"isHeartbeatMsg\", ({ enumerable: true, get: function () { return internal_mod_1.isHeartbeatMsg; } }));\nObject.defineProperty(exports, \"millis\", ({ enumerable: true, get: function () { return internal_mod_1.millis; } }));\nObject.defineProperty(exports, \"nanos\", ({ enumerable: true, get: function () { return internal_mod_1.nanos; } }));\nvar internal_mod_2 = __webpack_require__(/*! ./internal_mod */ \"(rsc)/./node_modules/nats/lib/jetstream/internal_mod.js\");\nObject.defineProperty(exports, \"AckPolicy\", ({ enumerable: true, get: function () { return internal_mod_2.AckPolicy; } }));\nObject.defineProperty(exports, \"AdvisoryKind\", ({ enumerable: true, get: function () { return internal_mod_2.AdvisoryKind; } }));\nObject.defineProperty(exports, \"ConsumerDebugEvents\", ({ enumerable: true, get: function () { return internal_mod_2.ConsumerDebugEvents; } }));\nObject.defineProperty(exports, \"ConsumerEvents\", ({ enumerable: true, get: function () { return internal_mod_2.ConsumerEvents; } }));\nObject.defineProperty(exports, \"DeliverPolicy\", ({ enumerable: true, get: function () { return internal_mod_2.DeliverPolicy; } }));\nObject.defineProperty(exports, \"DirectMsgHeaders\", ({ enumerable: true, get: function () { return internal_mod_2.DirectMsgHeaders; } }));\nObject.defineProperty(exports, \"DiscardPolicy\", ({ enumerable: true, get: function () { return internal_mod_2.DiscardPolicy; } }));\nObject.defineProperty(exports, \"JsHeaders\", ({ enumerable: true, get: function () { return internal_mod_2.JsHeaders; } }));\nObject.defineProperty(exports, \"ReplayPolicy\", ({ enumerable: true, get: function () { return internal_mod_2.ReplayPolicy; } }));\nObject.defineProperty(exports, \"RepublishHeaders\", ({ enumerable: true, get: function () { return internal_mod_2.RepublishHeaders; } }));\nObject.defineProperty(exports, \"RetentionPolicy\", ({ enumerable: true, get: function () { return internal_mod_2.RetentionPolicy; } }));\nObject.defineProperty(exports, \"StorageType\", ({ enumerable: true, get: function () { return internal_mod_2.StorageType; } }));\nObject.defineProperty(exports, \"StoreCompression\", ({ enumerable: true, get: function () { return internal_mod_2.StoreCompression; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/nats/lib/jetstream/types.js\");\nObject.defineProperty(exports, \"consumerOpts\", ({ enumerable: true, get: function () { return types_1.consumerOpts; } }));\n//# sourceMappingURL=mod.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL21vZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRyxtQkFBbUIsR0FBRyx1QkFBdUIsR0FBRyx3QkFBd0IsR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyxxQkFBcUIsR0FBRyxzQkFBc0IsR0FBRywyQkFBMkIsR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUIsR0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLG9CQUFvQjtBQUM5YjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsK0VBQWdCO0FBQzdDLGdEQUErQyxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUM5SCxvREFBbUQsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDdEksa0RBQWlELEVBQUUscUNBQXFDLHlDQUF5QyxFQUFDO0FBQ2xJLDBDQUF5QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNsSCx5Q0FBd0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDaEgscUJBQXFCLG1CQUFPLENBQUMsK0VBQWdCO0FBQzdDLDZDQUE0QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUN4SCxnREFBK0MsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDOUgsdURBQXNELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQzVJLGtEQUFpRCxFQUFFLHFDQUFxQyx5Q0FBeUMsRUFBQztBQUNsSSxpREFBZ0QsRUFBRSxxQ0FBcUMsd0NBQXdDLEVBQUM7QUFDaEksb0RBQW1ELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3RJLGlEQUFnRCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUNoSSw2Q0FBNEMsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDeEgsZ0RBQStDLEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQzlILG9EQUFtRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN0SSxtREFBa0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDcEksK0NBQThDLEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzVILG9EQUFtRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN0SSxjQUFjLG1CQUFPLENBQUMsaUVBQVM7QUFDL0IsZ0RBQStDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3ZIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL21vZC5qcz9lY2I0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25zdW1lck9wdHMgPSBleHBvcnRzLlN0b3JlQ29tcHJlc3Npb24gPSBleHBvcnRzLlN0b3JhZ2VUeXBlID0gZXhwb3J0cy5SZXRlbnRpb25Qb2xpY3kgPSBleHBvcnRzLlJlcHVibGlzaEhlYWRlcnMgPSBleHBvcnRzLlJlcGxheVBvbGljeSA9IGV4cG9ydHMuSnNIZWFkZXJzID0gZXhwb3J0cy5EaXNjYXJkUG9saWN5ID0gZXhwb3J0cy5EaXJlY3RNc2dIZWFkZXJzID0gZXhwb3J0cy5EZWxpdmVyUG9saWN5ID0gZXhwb3J0cy5Db25zdW1lckV2ZW50cyA9IGV4cG9ydHMuQ29uc3VtZXJEZWJ1Z0V2ZW50cyA9IGV4cG9ydHMuQWR2aXNvcnlLaW5kID0gZXhwb3J0cy5BY2tQb2xpY3kgPSBleHBvcnRzLm5hbm9zID0gZXhwb3J0cy5taWxsaXMgPSBleHBvcnRzLmlzSGVhcnRiZWF0TXNnID0gZXhwb3J0cy5pc0Zsb3dDb250cm9sTXNnID0gZXhwb3J0cy5jaGVja0pzRXJyb3IgPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IDIwMjMgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBpbnRlcm5hbF9tb2RfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsX21vZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNoZWNrSnNFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuY2hlY2tKc0Vycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNGbG93Q29udHJvbE1zZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuaXNGbG93Q29udHJvbE1zZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSGVhcnRiZWF0TXNnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5pc0hlYXJ0YmVhdE1zZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1pbGxpc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEubWlsbGlzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmFub3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8xLm5hbm9zOyB9IH0pO1xudmFyIGludGVybmFsX21vZF8yID0gcmVxdWlyZShcIi4vaW50ZXJuYWxfbW9kXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWNrUG9saWN5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMi5BY2tQb2xpY3k7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBZHZpc29yeUtpbmRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8yLkFkdmlzb3J5S2luZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbnN1bWVyRGVidWdFdmVudHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8yLkNvbnN1bWVyRGVidWdFdmVudHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDb25zdW1lckV2ZW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzIuQ29uc3VtZXJFdmVudHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWxpdmVyUG9saWN5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMi5EZWxpdmVyUG9saWN5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRGlyZWN0TXNnSGVhZGVyc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzIuRGlyZWN0TXNnSGVhZGVyczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpc2NhcmRQb2xpY3lcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8yLkRpc2NhcmRQb2xpY3k7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKc0hlYWRlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8yLkpzSGVhZGVyczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcGxheVBvbGljeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzIuUmVwbGF5UG9saWN5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVwdWJsaXNoSGVhZGVyc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzIuUmVwdWJsaXNoSGVhZGVyczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJldGVudGlvblBvbGljeVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzIuUmV0ZW50aW9uUG9saWN5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RvcmFnZVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8yLlN0b3JhZ2VUeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RvcmVDb21wcmVzc2lvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzIuU3RvcmVDb21wcmVzc2lvbjsgfSB9KTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25zdW1lck9wdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGVzXzEuY29uc3VtZXJPcHRzOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/mod.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/objectstore.js":
/*!********************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/objectstore.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2022-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ObjectStoreImpl = exports.ObjectStoreStatusImpl = exports.objectStoreBucketName = exports.objectStoreStreamName = exports.digestType = exports.osPrefix = void 0;\nconst kv_1 = __webpack_require__(/*! ./kv */ \"(rsc)/./node_modules/nats/lib/jetstream/kv.js\");\nconst base64_1 = __webpack_require__(/*! ../nats-base-client/base64 */ \"(rsc)/./node_modules/nats/lib/nats-base-client/base64.js\");\nconst codec_1 = __webpack_require__(/*! ../nats-base-client/codec */ \"(rsc)/./node_modules/nats/lib/nats-base-client/codec.js\");\nconst nuid_1 = __webpack_require__(/*! ../nats-base-client/nuid */ \"(rsc)/./node_modules/nats/lib/nats-base-client/nuid.js\");\nconst util_1 = __webpack_require__(/*! ../nats-base-client/util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst databuffer_1 = __webpack_require__(/*! ../nats-base-client/databuffer */ \"(rsc)/./node_modules/nats/lib/nats-base-client/databuffer.js\");\nconst headers_1 = __webpack_require__(/*! ../nats-base-client/headers */ \"(rsc)/./node_modules/nats/lib/nats-base-client/headers.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/nats/lib/jetstream/types.js\");\nconst queued_iterator_1 = __webpack_require__(/*! ../nats-base-client/queued_iterator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\");\nconst sha256_1 = __webpack_require__(/*! ../nats-base-client/sha256 */ \"(rsc)/./node_modules/nats/lib/nats-base-client/sha256.js\");\nconst jsapi_types_1 = __webpack_require__(/*! ./jsapi_types */ \"(rsc)/./node_modules/nats/lib/jetstream/jsapi_types.js\");\nconst jsclient_1 = __webpack_require__(/*! ./jsclient */ \"(rsc)/./node_modules/nats/lib/jetstream/jsclient.js\");\nexports.osPrefix = \"OBJ_\";\nexports.digestType = \"SHA-256=\";\nfunction objectStoreStreamName(bucket) {\n    (0, kv_1.validateBucket)(bucket);\n    return `${exports.osPrefix}${bucket}`;\n}\nexports.objectStoreStreamName = objectStoreStreamName;\nfunction objectStoreBucketName(stream) {\n    if (stream.startsWith(exports.osPrefix)) {\n        return stream.substring(4);\n    }\n    return stream;\n}\nexports.objectStoreBucketName = objectStoreBucketName;\nclass ObjectStoreStatusImpl {\n    constructor(si) {\n        this.si = si;\n        this.backingStore = \"JetStream\";\n    }\n    get bucket() {\n        return objectStoreBucketName(this.si.config.name);\n    }\n    get description() {\n        var _a;\n        return (_a = this.si.config.description) !== null && _a !== void 0 ? _a : \"\";\n    }\n    get ttl() {\n        return this.si.config.max_age;\n    }\n    get storage() {\n        return this.si.config.storage;\n    }\n    get replicas() {\n        return this.si.config.num_replicas;\n    }\n    get sealed() {\n        return this.si.config.sealed;\n    }\n    get size() {\n        return this.si.state.bytes;\n    }\n    get streamInfo() {\n        return this.si;\n    }\n    get metadata() {\n        return this.si.config.metadata;\n    }\n    get compression() {\n        if (this.si.config.compression) {\n            return this.si.config.compression !== jsapi_types_1.StoreCompression.None;\n        }\n        return false;\n    }\n}\nexports.ObjectStoreStatusImpl = ObjectStoreStatusImpl;\nclass ObjectInfoImpl {\n    constructor(oi) {\n        this.info = oi;\n    }\n    get name() {\n        return this.info.name;\n    }\n    get description() {\n        var _a;\n        return (_a = this.info.description) !== null && _a !== void 0 ? _a : \"\";\n    }\n    get headers() {\n        if (!this.hdrs) {\n            this.hdrs = headers_1.MsgHdrsImpl.fromRecord(this.info.headers || {});\n        }\n        return this.hdrs;\n    }\n    get options() {\n        return this.info.options;\n    }\n    get bucket() {\n        return this.info.bucket;\n    }\n    get chunks() {\n        return this.info.chunks;\n    }\n    get deleted() {\n        var _a;\n        return (_a = this.info.deleted) !== null && _a !== void 0 ? _a : false;\n    }\n    get digest() {\n        return this.info.digest;\n    }\n    get mtime() {\n        return this.info.mtime;\n    }\n    get nuid() {\n        return this.info.nuid;\n    }\n    get size() {\n        return this.info.size;\n    }\n    get revision() {\n        return this.info.revision;\n    }\n    get metadata() {\n        return this.info.metadata || {};\n    }\n    isLink() {\n        var _a, _b;\n        return (((_a = this.info.options) === null || _a === void 0 ? void 0 : _a.link) !== undefined) &&\n            (((_b = this.info.options) === null || _b === void 0 ? void 0 : _b.link) !== null);\n    }\n}\nfunction toServerObjectStoreMeta(meta) {\n    var _a;\n    const v = {\n        name: meta.name,\n        description: (_a = meta.description) !== null && _a !== void 0 ? _a : \"\",\n        options: meta.options,\n        metadata: meta.metadata,\n    };\n    if (meta.headers) {\n        const mhi = meta.headers;\n        v.headers = mhi.toRecord();\n    }\n    return v;\n}\nfunction emptyReadableStream() {\n    return new ReadableStream({\n        pull(c) {\n            c.enqueue(new Uint8Array(0));\n            c.close();\n        },\n    });\n}\nclass ObjectStoreImpl {\n    constructor(name, jsm, js) {\n        this.name = name;\n        this.jsm = jsm;\n        this.js = js;\n    }\n    _checkNotEmpty(name) {\n        if (!name || name.length === 0) {\n            return { name, error: new Error(\"name cannot be empty\") };\n        }\n        return { name };\n    }\n    info(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = yield this.rawInfo(name);\n            return info ? new ObjectInfoImpl(info) : null;\n        });\n    }\n    list() {\n        var _a, e_1, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            const buf = [];\n            const iter = yield this.watch({\n                ignoreDeletes: true,\n                includeHistory: true,\n            });\n            try {\n                for (var _d = true, iter_1 = __asyncValues(iter), iter_1_1; iter_1_1 = yield iter_1.next(), _a = iter_1_1.done, !_a; _d = true) {\n                    _c = iter_1_1.value;\n                    _d = false;\n                    const info = _c;\n                    // watch will give a null when it has initialized\n                    // for us that is the hint we are done\n                    if (info === null) {\n                        break;\n                    }\n                    buf.push(info);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = iter_1.return)) yield _b.call(iter_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            return Promise.resolve(buf);\n        });\n    }\n    rawInfo(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { name: obj, error } = this._checkNotEmpty(name);\n            if (error) {\n                return Promise.reject(error);\n            }\n            const meta = this._metaSubject(obj);\n            try {\n                const m = yield this.jsm.streams.getMessage(this.stream, {\n                    last_by_subj: meta,\n                });\n                const jc = (0, codec_1.JSONCodec)();\n                const soi = jc.decode(m.data);\n                soi.revision = m.seq;\n                return soi;\n            }\n            catch (err) {\n                if (err.code === \"404\") {\n                    return null;\n                }\n                return Promise.reject(err);\n            }\n        });\n    }\n    _si(opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                return yield this.jsm.streams.info(this.stream, opts);\n            }\n            catch (err) {\n                const nerr = err;\n                if (nerr.code === \"404\") {\n                    return null;\n                }\n                return Promise.reject(err);\n            }\n        });\n    }\n    seal() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let info = yield this._si();\n            if (info === null) {\n                return Promise.reject(new Error(\"object store not found\"));\n            }\n            info.config.sealed = true;\n            info = yield this.jsm.streams.update(this.stream, info.config);\n            return Promise.resolve(new ObjectStoreStatusImpl(info));\n        });\n    }\n    status(opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = yield this._si(opts);\n            if (info === null) {\n                return Promise.reject(new Error(\"object store not found\"));\n            }\n            return Promise.resolve(new ObjectStoreStatusImpl(info));\n        });\n    }\n    destroy() {\n        return this.jsm.streams.delete(this.stream);\n    }\n    _put(meta, rs, opts) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const jsopts = this.js.getOptions();\n            opts = opts || { timeout: jsopts.timeout };\n            opts.timeout = opts.timeout || jsopts.timeout;\n            opts.previousRevision = (_a = opts.previousRevision) !== null && _a !== void 0 ? _a : undefined;\n            const { timeout, previousRevision } = opts;\n            const si = this.js.nc.info;\n            const maxPayload = (si === null || si === void 0 ? void 0 : si.max_payload) || 1024;\n            meta = meta || {};\n            meta.options = meta.options || {};\n            let maxChunk = ((_b = meta.options) === null || _b === void 0 ? void 0 : _b.max_chunk_size) || 128 * 1024;\n            maxChunk = maxChunk > maxPayload ? maxPayload : maxChunk;\n            meta.options.max_chunk_size = maxChunk;\n            const old = yield this.info(meta.name);\n            const { name: n, error } = this._checkNotEmpty(meta.name);\n            if (error) {\n                return Promise.reject(error);\n            }\n            const id = nuid_1.nuid.next();\n            const chunkSubj = this._chunkSubject(id);\n            const metaSubj = this._metaSubject(n);\n            const info = Object.assign({\n                bucket: this.name,\n                nuid: id,\n                size: 0,\n                chunks: 0,\n            }, toServerObjectStoreMeta(meta));\n            const d = (0, util_1.deferred)();\n            const proms = [];\n            const db = new databuffer_1.DataBuffer();\n            try {\n                const reader = rs ? rs.getReader() : null;\n                const sha = new sha256_1.SHA256();\n                while (true) {\n                    const { done, value } = reader\n                        ? yield reader.read()\n                        : { done: true, value: undefined };\n                    if (done) {\n                        // put any partial chunk in\n                        if (db.size() > 0) {\n                            const payload = db.drain();\n                            sha.update(payload);\n                            info.chunks++;\n                            info.size += payload.length;\n                            proms.push(this.js.publish(chunkSubj, payload, { timeout }));\n                        }\n                        // wait for all the chunks to write\n                        yield Promise.all(proms);\n                        proms.length = 0;\n                        // prepare the metadata\n                        info.mtime = new Date().toISOString();\n                        const digest = sha.digest(\"base64\");\n                        const pad = digest.length % 3;\n                        const padding = pad > 0 ? \"=\".repeat(pad) : \"\";\n                        info.digest = `${exports.digestType}${digest}${padding}`;\n                        info.deleted = false;\n                        // trailing md for the object\n                        const h = (0, headers_1.headers)();\n                        if (typeof previousRevision === \"number\") {\n                            h.set(jsclient_1.PubHeaders.ExpectedLastSubjectSequenceHdr, `${previousRevision}`);\n                        }\n                        h.set(types_1.JsHeaders.RollupHdr, types_1.JsHeaders.RollupValueSubject);\n                        // try to update the metadata\n                        const pa = yield this.js.publish(metaSubj, (0, codec_1.JSONCodec)().encode(info), {\n                            headers: h,\n                            timeout,\n                        });\n                        // update the revision to point to the sequence where we inserted\n                        info.revision = pa.seq;\n                        // if we are here, the new entry is live\n                        if (old) {\n                            try {\n                                yield this.jsm.streams.purge(this.stream, {\n                                    filter: `$O.${this.name}.C.${old.nuid}`,\n                                });\n                            }\n                            catch (_err) {\n                                // rejecting here, would mean send the wrong signal\n                                // the update succeeded, but cleanup of old chunks failed.\n                            }\n                        }\n                        // resolve the ObjectInfo\n                        d.resolve(new ObjectInfoImpl(info));\n                        // stop\n                        break;\n                    }\n                    if (value) {\n                        db.fill(value);\n                        while (db.size() > maxChunk) {\n                            info.chunks++;\n                            info.size += maxChunk;\n                            const payload = db.drain(meta.options.max_chunk_size);\n                            sha.update(payload);\n                            proms.push(this.js.publish(chunkSubj, payload, { timeout }));\n                        }\n                    }\n                }\n            }\n            catch (err) {\n                // we failed, remove any partials\n                yield this.jsm.streams.purge(this.stream, { filter: chunkSubj });\n                d.reject(err);\n            }\n            return d;\n        });\n    }\n    putBlob(meta, data, opts) {\n        function readableStreamFrom(data) {\n            return new ReadableStream({\n                pull(controller) {\n                    controller.enqueue(data);\n                    controller.close();\n                },\n            });\n        }\n        if (data === null) {\n            data = new Uint8Array(0);\n        }\n        return this.put(meta, readableStreamFrom(data), opts);\n    }\n    put(meta, rs, opts) {\n        var _a;\n        if ((_a = meta === null || meta === void 0 ? void 0 : meta.options) === null || _a === void 0 ? void 0 : _a.link) {\n            return Promise.reject(new Error(\"link cannot be set when putting the object in bucket\"));\n        }\n        return this._put(meta, rs, opts);\n    }\n    getBlob(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            function fromReadableStream(rs) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    const buf = new databuffer_1.DataBuffer();\n                    const reader = rs.getReader();\n                    while (true) {\n                        const { done, value } = yield reader.read();\n                        if (done) {\n                            return buf.drain();\n                        }\n                        if (value && value.length) {\n                            buf.fill(value);\n                        }\n                    }\n                });\n            }\n            const r = yield this.get(name);\n            if (r === null) {\n                return Promise.resolve(null);\n            }\n            const vs = yield Promise.all([r.error, fromReadableStream(r.data)]);\n            if (vs[0]) {\n                return Promise.reject(vs[0]);\n            }\n            else {\n                return Promise.resolve(vs[1]);\n            }\n        });\n    }\n    get(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = yield this.rawInfo(name);\n            if (info === null) {\n                return Promise.resolve(null);\n            }\n            if (info.deleted) {\n                return Promise.resolve(null);\n            }\n            if (info.options && info.options.link) {\n                const ln = info.options.link.name || \"\";\n                if (ln === \"\") {\n                    throw new Error(\"link is a bucket\");\n                }\n                const os = info.options.link.bucket !== this.name\n                    ? yield ObjectStoreImpl.create(this.js, info.options.link.bucket)\n                    : this;\n                return os.get(ln);\n            }\n            const d = (0, util_1.deferred)();\n            const r = {\n                info: new ObjectInfoImpl(info),\n                error: d,\n            };\n            if (info.size === 0) {\n                r.data = emptyReadableStream();\n                d.resolve(null);\n                return Promise.resolve(r);\n            }\n            let controller;\n            const oc = (0, types_1.consumerOpts)();\n            oc.orderedConsumer();\n            const sha = new sha256_1.SHA256();\n            const subj = `$O.${this.name}.C.${info.nuid}`;\n            const sub = yield this.js.subscribe(subj, oc);\n            (() => __awaiter(this, void 0, void 0, function* () {\n                var _a, e_2, _b, _c;\n                try {\n                    for (var _d = true, sub_1 = __asyncValues(sub), sub_1_1; sub_1_1 = yield sub_1.next(), _a = sub_1_1.done, !_a; _d = true) {\n                        _c = sub_1_1.value;\n                        _d = false;\n                        const jm = _c;\n                        if (jm.data.length > 0) {\n                            sha.update(jm.data);\n                            controller.enqueue(jm.data);\n                        }\n                        if (jm.info.pending === 0) {\n                            const hash = sha.digest(\"base64\");\n                            // go pads the hash - which should be multiple of 3 - otherwise pads with '='\n                            const pad = hash.length % 3;\n                            const padding = pad > 0 ? \"=\".repeat(pad) : \"\";\n                            const digest = `${exports.digestType}${hash}${padding}`;\n                            if (digest !== info.digest) {\n                                controller.error(new Error(`received a corrupt object, digests do not match received: ${info.digest} calculated ${digest}`));\n                            }\n                            else {\n                                controller.close();\n                            }\n                            sub.unsubscribe();\n                        }\n                    }\n                }\n                catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = sub_1.return)) yield _b.call(sub_1);\n                    }\n                    finally { if (e_2) throw e_2.error; }\n                }\n            }))()\n                .then(() => {\n                d.resolve();\n            })\n                .catch((err) => {\n                controller.error(err);\n                d.reject(err);\n            });\n            r.data = new ReadableStream({\n                start(c) {\n                    controller = c;\n                },\n                cancel() {\n                    sub.unsubscribe();\n                },\n            });\n            return r;\n        });\n    }\n    linkStore(name, bucket) {\n        if (!(bucket instanceof ObjectStoreImpl)) {\n            return Promise.reject(\"bucket required\");\n        }\n        const osi = bucket;\n        const { name: n, error } = this._checkNotEmpty(name);\n        if (error) {\n            return Promise.reject(error);\n        }\n        const meta = {\n            name: n,\n            options: { link: { bucket: osi.name } },\n        };\n        return this._put(meta, null);\n    }\n    link(name, info) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { name: n, error } = this._checkNotEmpty(name);\n            if (error) {\n                return Promise.reject(error);\n            }\n            if (info.deleted) {\n                return Promise.reject(new Error(\"src object is deleted\"));\n            }\n            if (info.isLink()) {\n                return Promise.reject(new Error(\"src object is a link\"));\n            }\n            const dest = yield this.rawInfo(name);\n            if (dest !== null && !dest.deleted) {\n                return Promise.reject(new Error(\"an object already exists with that name\"));\n            }\n            const link = { bucket: info.bucket, name: info.name };\n            const mm = {\n                name: n,\n                bucket: info.bucket,\n                options: { link: link },\n            };\n            yield this.js.publish(this._metaSubject(name), JSON.stringify(mm));\n            const i = yield this.info(name);\n            return Promise.resolve(i);\n        });\n    }\n    delete(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = yield this.rawInfo(name);\n            if (info === null) {\n                return Promise.resolve({ purged: 0, success: false });\n            }\n            info.deleted = true;\n            info.size = 0;\n            info.chunks = 0;\n            info.digest = \"\";\n            const jc = (0, codec_1.JSONCodec)();\n            const h = (0, headers_1.headers)();\n            h.set(types_1.JsHeaders.RollupHdr, types_1.JsHeaders.RollupValueSubject);\n            yield this.js.publish(this._metaSubject(info.name), jc.encode(info), {\n                headers: h,\n            });\n            return this.jsm.streams.purge(this.stream, {\n                filter: this._chunkSubject(info.nuid),\n            });\n        });\n    }\n    update(name, meta = {}) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const info = yield this.rawInfo(name);\n            if (info === null) {\n                return Promise.reject(new Error(\"object not found\"));\n            }\n            if (info.deleted) {\n                return Promise.reject(new Error(\"cannot update meta for a deleted object\"));\n            }\n            meta.name = (_a = meta.name) !== null && _a !== void 0 ? _a : info.name;\n            const { name: n, error } = this._checkNotEmpty(meta.name);\n            if (error) {\n                return Promise.reject(error);\n            }\n            if (name !== meta.name) {\n                const i = yield this.info(meta.name);\n                if (i && !i.deleted) {\n                    return Promise.reject(new Error(\"an object already exists with that name\"));\n                }\n            }\n            meta.name = n;\n            const ii = Object.assign({}, info, toServerObjectStoreMeta(meta));\n            // if the name changed, delete the old meta\n            const ack = yield this.js.publish(this._metaSubject(ii.name), JSON.stringify(ii));\n            if (name !== meta.name) {\n                yield this.jsm.streams.purge(this.stream, {\n                    filter: this._metaSubject(name),\n                });\n            }\n            return Promise.resolve(ack);\n        });\n    }\n    watch(opts = {}) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            opts.includeHistory = (_a = opts.includeHistory) !== null && _a !== void 0 ? _a : false;\n            opts.ignoreDeletes = (_b = opts.ignoreDeletes) !== null && _b !== void 0 ? _b : false;\n            let initialized = false;\n            const qi = new queued_iterator_1.QueuedIteratorImpl();\n            const subj = this._metaSubjectAll();\n            try {\n                yield this.jsm.streams.getMessage(this.stream, { last_by_subj: subj });\n            }\n            catch (err) {\n                if (err.code === \"404\") {\n                    qi.push(null);\n                    initialized = true;\n                }\n                else {\n                    qi.stop(err);\n                }\n            }\n            const jc = (0, codec_1.JSONCodec)();\n            const copts = (0, types_1.consumerOpts)();\n            copts.orderedConsumer();\n            if (opts.includeHistory) {\n                copts.deliverLastPerSubject();\n            }\n            else {\n                // FIXME: Go's implementation doesn't seem correct - if history is not desired\n                //  the watch should only be giving notifications on new entries\n                initialized = true;\n                copts.deliverNew();\n            }\n            copts.callback((err, jm) => {\n                var _a;\n                if (err) {\n                    qi.stop(err);\n                    return;\n                }\n                if (jm !== null) {\n                    const oi = jc.decode(jm.data);\n                    if (oi.deleted && opts.ignoreDeletes === true) {\n                        // do nothing\n                    }\n                    else {\n                        qi.push(oi);\n                    }\n                    if (((_a = jm.info) === null || _a === void 0 ? void 0 : _a.pending) === 0 && !initialized) {\n                        initialized = true;\n                        qi.push(null);\n                    }\n                }\n            });\n            const sub = yield this.js.subscribe(subj, copts);\n            qi._data = sub;\n            qi.iterClosed.then(() => {\n                sub.unsubscribe();\n            });\n            sub.closed.then(() => {\n                qi.stop();\n            }).catch((err) => {\n                qi.stop(err);\n            });\n            return qi;\n        });\n    }\n    _chunkSubject(id) {\n        return `$O.${this.name}.C.${id}`;\n    }\n    _metaSubject(n) {\n        return `$O.${this.name}.M.${base64_1.Base64UrlPaddedCodec.encode(n)}`;\n    }\n    _metaSubjectAll() {\n        return `$O.${this.name}.M.>`;\n    }\n    init(opts = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                this.stream = objectStoreStreamName(this.name);\n            }\n            catch (err) {\n                return Promise.reject(err);\n            }\n            const max_age = (opts === null || opts === void 0 ? void 0 : opts.ttl) || 0;\n            delete opts.ttl;\n            // pacify the tsc compiler downstream\n            const sc = Object.assign({ max_age }, opts);\n            sc.name = this.stream;\n            sc.allow_direct = true;\n            sc.allow_rollup_hdrs = true;\n            sc.discard = jsapi_types_1.DiscardPolicy.New;\n            sc.subjects = [`$O.${this.name}.C.>`, `$O.${this.name}.M.>`];\n            if (opts.placement) {\n                sc.placement = opts.placement;\n            }\n            if (opts.metadata) {\n                sc.metadata = opts.metadata;\n            }\n            if (typeof opts.compression === \"boolean\") {\n                sc.compression = opts.compression\n                    ? jsapi_types_1.StoreCompression.S2\n                    : jsapi_types_1.StoreCompression.None;\n            }\n            try {\n                yield this.jsm.streams.info(sc.name);\n            }\n            catch (err) {\n                if (err.message === \"stream not found\") {\n                    yield this.jsm.streams.add(sc);\n                }\n            }\n        });\n    }\n    static create(js, name, opts = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const jsm = yield js.jetstreamManager();\n            const os = new ObjectStoreImpl(name, jsm, js);\n            yield os.init(opts);\n            return Promise.resolve(os);\n        });\n    }\n}\nexports.ObjectStoreImpl = ObjectStoreImpl;\n//# sourceMappingURL=objectstore.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL29iamVjdHN0b3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsdUZBQXVGLGNBQWM7QUFDaE4sdUJBQXVCLDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRyxrQkFBa0IsR0FBRyxnQkFBZ0I7QUFDL0osYUFBYSxtQkFBTyxDQUFDLDJEQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLDRGQUE0QjtBQUNyRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRkFBMkI7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLHdGQUEwQjtBQUNqRCxlQUFlLG1CQUFPLENBQUMsd0ZBQTBCO0FBQ2pELHFCQUFxQixtQkFBTyxDQUFDLG9HQUFnQztBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQyw4RkFBNkI7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMsaUVBQVM7QUFDakMsMEJBQTBCLG1CQUFPLENBQUMsOEdBQXFDO0FBQ3ZFLGlCQUFpQixtQkFBTyxDQUFDLDRGQUE0QjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyw2RUFBZTtBQUM3QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RUFBWTtBQUN2QyxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FB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QWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxvQkFBb0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVSxLQUFLLEdBQUc7QUFDdkM7QUFDQTtBQUNBLHFCQUFxQixVQUFVLEtBQUssd0NBQXdDO0FBQzVFO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVUsYUFBYSxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL2pldHN0cmVhbS9vYmplY3RzdG9yZS5qcz9iOTNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyLTIwMjMgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fYXN5bmNWYWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNWYWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT2JqZWN0U3RvcmVJbXBsID0gZXhwb3J0cy5PYmplY3RTdG9yZVN0YXR1c0ltcGwgPSBleHBvcnRzLm9iamVjdFN0b3JlQnVja2V0TmFtZSA9IGV4cG9ydHMub2JqZWN0U3RvcmVTdHJlYW1OYW1lID0gZXhwb3J0cy5kaWdlc3RUeXBlID0gZXhwb3J0cy5vc1ByZWZpeCA9IHZvaWQgMDtcbmNvbnN0IGt2XzEgPSByZXF1aXJlKFwiLi9rdlwiKTtcbmNvbnN0IGJhc2U2NF8xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvYmFzZTY0XCIpO1xuY29uc3QgY29kZWNfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L2NvZGVjXCIpO1xuY29uc3QgbnVpZF8xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvbnVpZFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3V0aWxcIik7XG5jb25zdCBkYXRhYnVmZmVyXzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9kYXRhYnVmZmVyXCIpO1xuY29uc3QgaGVhZGVyc18xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvaGVhZGVyc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNvbnN0IHF1ZXVlZF9pdGVyYXRvcl8xID0gcmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvcXVldWVkX2l0ZXJhdG9yXCIpO1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiLi4vbmF0cy1iYXNlLWNsaWVudC9zaGEyNTZcIik7XG5jb25zdCBqc2FwaV90eXBlc18xID0gcmVxdWlyZShcIi4vanNhcGlfdHlwZXNcIik7XG5jb25zdCBqc2NsaWVudF8xID0gcmVxdWlyZShcIi4vanNjbGllbnRcIik7XG5leHBvcnRzLm9zUHJlZml4ID0gXCJPQkpfXCI7XG5leHBvcnRzLmRpZ2VzdFR5cGUgPSBcIlNIQS0yNTY9XCI7XG5mdW5jdGlvbiBvYmplY3RTdG9yZVN0cmVhbU5hbWUoYnVja2V0KSB7XG4gICAgKDAsIGt2XzEudmFsaWRhdGVCdWNrZXQpKGJ1Y2tldCk7XG4gICAgcmV0dXJuIGAke2V4cG9ydHMub3NQcmVmaXh9JHtidWNrZXR9YDtcbn1cbmV4cG9ydHMub2JqZWN0U3RvcmVTdHJlYW1OYW1lID0gb2JqZWN0U3RvcmVTdHJlYW1OYW1lO1xuZnVuY3Rpb24gb2JqZWN0U3RvcmVCdWNrZXROYW1lKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0uc3RhcnRzV2l0aChleHBvcnRzLm9zUHJlZml4KSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLnN1YnN0cmluZyg0KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmVhbTtcbn1cbmV4cG9ydHMub2JqZWN0U3RvcmVCdWNrZXROYW1lID0gb2JqZWN0U3RvcmVCdWNrZXROYW1lO1xuY2xhc3MgT2JqZWN0U3RvcmVTdGF0dXNJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihzaSkge1xuICAgICAgICB0aGlzLnNpID0gc2k7XG4gICAgICAgIHRoaXMuYmFja2luZ1N0b3JlID0gXCJKZXRTdHJlYW1cIjtcbiAgICB9XG4gICAgZ2V0IGJ1Y2tldCgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdFN0b3JlQnVja2V0TmFtZSh0aGlzLnNpLmNvbmZpZy5uYW1lKTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLnNpLmNvbmZpZy5kZXNjcmlwdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICB9XG4gICAgZ2V0IHR0bCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuY29uZmlnLm1heF9hZ2U7XG4gICAgfVxuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcuc3RvcmFnZTtcbiAgICB9XG4gICAgZ2V0IHJlcGxpY2FzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcubnVtX3JlcGxpY2FzO1xuICAgIH1cbiAgICBnZXQgc2VhbGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcuc2VhbGVkO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2kuc3RhdGUuYnl0ZXM7XG4gICAgfVxuICAgIGdldCBzdHJlYW1JbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaTtcbiAgICB9XG4gICAgZ2V0IG1ldGFkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcubWV0YWRhdGE7XG4gICAgfVxuICAgIGdldCBjb21wcmVzc2lvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2kuY29uZmlnLmNvbXByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaS5jb25maWcuY29tcHJlc3Npb24gIT09IGpzYXBpX3R5cGVzXzEuU3RvcmVDb21wcmVzc2lvbi5Ob25lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLk9iamVjdFN0b3JlU3RhdHVzSW1wbCA9IE9iamVjdFN0b3JlU3RhdHVzSW1wbDtcbmNsYXNzIE9iamVjdEluZm9JbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihvaSkge1xuICAgICAgICB0aGlzLmluZm8gPSBvaTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8ubmFtZTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmluZm8uZGVzY3JpcHRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCI7XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGRycykge1xuICAgICAgICAgICAgdGhpcy5oZHJzID0gaGVhZGVyc18xLk1zZ0hkcnNJbXBsLmZyb21SZWNvcmQodGhpcy5pbmZvLmhlYWRlcnMgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhkcnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBidWNrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uYnVja2V0O1xuICAgIH1cbiAgICBnZXQgY2h1bmtzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLmNodW5rcztcbiAgICB9XG4gICAgZ2V0IGRlbGV0ZWQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuaW5mby5kZWxldGVkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5kaWdlc3Q7XG4gICAgfVxuICAgIGdldCBtdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5mby5tdGltZTtcbiAgICB9XG4gICAgZ2V0IG51aWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8ubnVpZDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8uc2l6ZTtcbiAgICB9XG4gICAgZ2V0IHJldmlzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmZvLnJldmlzaW9uO1xuICAgIH1cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZm8ubWV0YWRhdGEgfHwge307XG4gICAgfVxuICAgIGlzTGluaygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuICgoKF9hID0gdGhpcy5pbmZvLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5saW5rKSAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKCgoX2IgPSB0aGlzLmluZm8ub3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxpbmspICE9PSBudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1NlcnZlck9iamVjdFN0b3JlTWV0YShtZXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHYgPSB7XG4gICAgICAgIG5hbWU6IG1ldGEubmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb246IChfYSA9IG1ldGEuZGVzY3JpcHRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFwiXCIsXG4gICAgICAgIG9wdGlvbnM6IG1ldGEub3B0aW9ucyxcbiAgICAgICAgbWV0YWRhdGE6IG1ldGEubWV0YWRhdGEsXG4gICAgfTtcbiAgICBpZiAobWV0YS5oZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IG1oaSA9IG1ldGEuaGVhZGVycztcbiAgICAgICAgdi5oZWFkZXJzID0gbWhpLnRvUmVjb3JkKCk7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuZnVuY3Rpb24gZW1wdHlSZWFkYWJsZVN0cmVhbSgpIHtcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgcHVsbChjKSB7XG4gICAgICAgICAgICBjLmVucXVldWUobmV3IFVpbnQ4QXJyYXkoMCkpO1xuICAgICAgICAgICAgYy5jbG9zZSgpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuY2xhc3MgT2JqZWN0U3RvcmVJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBqc20sIGpzKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuanNtID0ganNtO1xuICAgICAgICB0aGlzLmpzID0ganM7XG4gICAgfVxuICAgIF9jaGVja05vdEVtcHR5KG5hbWUpIHtcbiAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lLCBlcnJvcjogbmV3IEVycm9yKFwibmFtZSBjYW5ub3QgYmUgZW1wdHlcIikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBuYW1lIH07XG4gICAgfVxuICAgIGluZm8obmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHlpZWxkIHRoaXMucmF3SW5mbyhuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBpbmZvID8gbmV3IE9iamVjdEluZm9JbXBsKGluZm8pIDogbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3QoKSB7XG4gICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBidWYgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXIgPSB5aWVsZCB0aGlzLndhdGNoKHtcbiAgICAgICAgICAgICAgICBpZ25vcmVEZWxldGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVIaXN0b3J5OiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgaXRlcl8xID0gX19hc3luY1ZhbHVlcyhpdGVyKSwgaXRlcl8xXzE7IGl0ZXJfMV8xID0geWllbGQgaXRlcl8xLm5leHQoKSwgX2EgPSBpdGVyXzFfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBfYyA9IGl0ZXJfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0gX2M7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdhdGNoIHdpbGwgZ2l2ZSBhIG51bGwgd2hlbiBpdCBoYXMgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHVzIHRoYXQgaXMgdGhlIGhpbnQgd2UgYXJlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJ1Zi5wdXNoKGluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBpdGVyXzEucmV0dXJuKSkgeWllbGQgX2IuY2FsbChpdGVyXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJ1Zik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByYXdJbmZvKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZTogb2JqLCBlcnJvciB9ID0gdGhpcy5fY2hlY2tOb3RFbXB0eShuYW1lKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YVN1YmplY3Qob2JqKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IHlpZWxkIHRoaXMuanNtLnN0cmVhbXMuZ2V0TWVzc2FnZSh0aGlzLnN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICBsYXN0X2J5X3N1Ymo6IG1ldGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgamMgPSAoMCwgY29kZWNfMS5KU09OQ29kZWMpKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc29pID0gamMuZGVjb2RlKG0uZGF0YSk7XG4gICAgICAgICAgICAgICAgc29pLnJldmlzaW9uID0gbS5zZXE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgPT09IFwiNDA0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3NpKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuanNtLnN0cmVhbXMuaW5mbyh0aGlzLnN0cmVhbSwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmVyciA9IGVycjtcbiAgICAgICAgICAgICAgICBpZiAobmVyci5jb2RlID09PSBcIjQwNFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlYWwoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgaW5mbyA9IHlpZWxkIHRoaXMuX3NpKCk7XG4gICAgICAgICAgICBpZiAoaW5mbyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJvYmplY3Qgc3RvcmUgbm90IGZvdW5kXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZm8uY29uZmlnLnNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgICBpbmZvID0geWllbGQgdGhpcy5qc20uc3RyZWFtcy51cGRhdGUodGhpcy5zdHJlYW0sIGluZm8uY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IE9iamVjdFN0b3JlU3RhdHVzSW1wbChpbmZvKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0dXMob3B0cykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHlpZWxkIHRoaXMuX3NpKG9wdHMpO1xuICAgICAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwib2JqZWN0IHN0b3JlIG5vdCBmb3VuZFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBPYmplY3RTdG9yZVN0YXR1c0ltcGwoaW5mbykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNtLnN0cmVhbXMuZGVsZXRlKHRoaXMuc3RyZWFtKTtcbiAgICB9XG4gICAgX3B1dChtZXRhLCBycywgb3B0cykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QganNvcHRzID0gdGhpcy5qcy5nZXRPcHRpb25zKCk7XG4gICAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7IHRpbWVvdXQ6IGpzb3B0cy50aW1lb3V0IH07XG4gICAgICAgICAgICBvcHRzLnRpbWVvdXQgPSBvcHRzLnRpbWVvdXQgfHwganNvcHRzLnRpbWVvdXQ7XG4gICAgICAgICAgICBvcHRzLnByZXZpb3VzUmV2aXNpb24gPSAoX2EgPSBvcHRzLnByZXZpb3VzUmV2aXNpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHsgdGltZW91dCwgcHJldmlvdXNSZXZpc2lvbiB9ID0gb3B0cztcbiAgICAgICAgICAgIGNvbnN0IHNpID0gdGhpcy5qcy5uYy5pbmZvO1xuICAgICAgICAgICAgY29uc3QgbWF4UGF5bG9hZCA9IChzaSA9PT0gbnVsbCB8fCBzaSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2kubWF4X3BheWxvYWQpIHx8IDEwMjQ7XG4gICAgICAgICAgICBtZXRhID0gbWV0YSB8fCB7fTtcbiAgICAgICAgICAgIG1ldGEub3B0aW9ucyA9IG1ldGEub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIGxldCBtYXhDaHVuayA9ICgoX2IgPSBtZXRhLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhfY2h1bmtfc2l6ZSkgfHwgMTI4ICogMTAyNDtcbiAgICAgICAgICAgIG1heENodW5rID0gbWF4Q2h1bmsgPiBtYXhQYXlsb2FkID8gbWF4UGF5bG9hZCA6IG1heENodW5rO1xuICAgICAgICAgICAgbWV0YS5vcHRpb25zLm1heF9jaHVua19zaXplID0gbWF4Q2h1bms7XG4gICAgICAgICAgICBjb25zdCBvbGQgPSB5aWVsZCB0aGlzLmluZm8obWV0YS5uYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZTogbiwgZXJyb3IgfSA9IHRoaXMuX2NoZWNrTm90RW1wdHkobWV0YS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZCA9IG51aWRfMS5udWlkLm5leHQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNodW5rU3ViaiA9IHRoaXMuX2NodW5rU3ViamVjdChpZCk7XG4gICAgICAgICAgICBjb25zdCBtZXRhU3ViaiA9IHRoaXMuX21ldGFTdWJqZWN0KG4pO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIGJ1Y2tldDogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgIG51aWQ6IGlkLFxuICAgICAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiAwLFxuICAgICAgICAgICAgfSwgdG9TZXJ2ZXJPYmplY3RTdG9yZU1ldGEobWV0YSkpO1xuICAgICAgICAgICAgY29uc3QgZCA9ICgwLCB1dGlsXzEuZGVmZXJyZWQpKCk7XG4gICAgICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZGIgPSBuZXcgZGF0YWJ1ZmZlcl8xLkRhdGFCdWZmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gcnMgPyBycy5nZXRSZWFkZXIoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hhID0gbmV3IHNoYTI1Nl8xLlNIQTI1NigpO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHJlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB5aWVsZCByZWFkZXIucmVhZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHV0IGFueSBwYXJ0aWFsIGNodW5rIGluXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGIuc2l6ZSgpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYi5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYS51cGRhdGUocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5jaHVua3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLnNpemUgKz0gcGF5bG9hZC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXMucHVzaCh0aGlzLmpzLnB1Ymxpc2goY2h1bmtTdWJqLCBwYXlsb2FkLCB7IHRpbWVvdXQgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FpdCBmb3IgYWxsIHRoZSBjaHVua3MgdG8gd3JpdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIHRoZSBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5tdGltZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZ2VzdCA9IHNoYS5kaWdlc3QoXCJiYXNlNjRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWQgPSBkaWdlc3QubGVuZ3RoICUgMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSBwYWQgPiAwID8gXCI9XCIucmVwZWF0KHBhZCkgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5kaWdlc3QgPSBgJHtleHBvcnRzLmRpZ2VzdFR5cGV9JHtkaWdlc3R9JHtwYWRkaW5nfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmRlbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyYWlsaW5nIG1kIGZvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoID0gKDAsIGhlYWRlcnNfMS5oZWFkZXJzKSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2aW91c1JldmlzaW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaC5zZXQoanNjbGllbnRfMS5QdWJIZWFkZXJzLkV4cGVjdGVkTGFzdFN1YmplY3RTZXF1ZW5jZUhkciwgYCR7cHJldmlvdXNSZXZpc2lvbn1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGguc2V0KHR5cGVzXzEuSnNIZWFkZXJzLlJvbGx1cEhkciwgdHlwZXNfMS5Kc0hlYWRlcnMuUm9sbHVwVmFsdWVTdWJqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byB1cGRhdGUgdGhlIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYSA9IHlpZWxkIHRoaXMuanMucHVibGlzaChtZXRhU3ViaiwgKDAsIGNvZGVjXzEuSlNPTkNvZGVjKSgpLmVuY29kZShpbmZvKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSByZXZpc2lvbiB0byBwb2ludCB0byB0aGUgc2VxdWVuY2Ugd2hlcmUgd2UgaW5zZXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8ucmV2aXNpb24gPSBwYS5zZXE7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSwgdGhlIG5ldyBlbnRyeSBpcyBsaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLnN0cmVhbSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBgJE8uJHt0aGlzLm5hbWV9LkMuJHtvbGQubnVpZH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVqZWN0aW5nIGhlcmUsIHdvdWxkIG1lYW4gc2VuZCB0aGUgd3Jvbmcgc2lnbmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSB1cGRhdGUgc3VjY2VlZGVkLCBidXQgY2xlYW51cCBvZiBvbGQgY2h1bmtzIGZhaWxlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHRoZSBPYmplY3RJbmZvXG4gICAgICAgICAgICAgICAgICAgICAgICBkLnJlc29sdmUobmV3IE9iamVjdEluZm9JbXBsKGluZm8pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGIuZmlsbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGIuc2l6ZSgpID4gbWF4Q2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmNodW5rcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uc2l6ZSArPSBtYXhDaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gZGIuZHJhaW4obWV0YS5vcHRpb25zLm1heF9jaHVua19zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGEudXBkYXRlKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21zLnB1c2godGhpcy5qcy5wdWJsaXNoKGNodW5rU3ViaiwgcGF5bG9hZCwgeyB0aW1lb3V0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBmYWlsZWQsIHJlbW92ZSBhbnkgcGFydGlhbHNcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmpzbS5zdHJlYW1zLnB1cmdlKHRoaXMuc3RyZWFtLCB7IGZpbHRlcjogY2h1bmtTdWJqIH0pO1xuICAgICAgICAgICAgICAgIGQucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHB1dEJsb2IobWV0YSwgZGF0YSwgb3B0cykge1xuICAgICAgICBmdW5jdGlvbiByZWFkYWJsZVN0cmVhbUZyb20oZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnB1dChtZXRhLCByZWFkYWJsZVN0cmVhbUZyb20oZGF0YSksIG9wdHMpO1xuICAgIH1cbiAgICBwdXQobWV0YSwgcnMsIG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gbWV0YSA9PT0gbnVsbCB8fCBtZXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXRhLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5saW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwibGluayBjYW5ub3QgYmUgc2V0IHdoZW4gcHV0dGluZyB0aGUgb2JqZWN0IGluIGJ1Y2tldFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3B1dChtZXRhLCBycywgb3B0cyk7XG4gICAgfVxuICAgIGdldEJsb2IobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZnJvbVJlYWRhYmxlU3RyZWFtKHJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmID0gbmV3IGRhdGFidWZmZXJfMS5EYXRhQnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJzLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0geWllbGQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJ1Zi5kcmFpbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1Zi5maWxsKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgciA9IHlpZWxkIHRoaXMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgaWYgKHIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdnMgPSB5aWVsZCBQcm9taXNlLmFsbChbci5lcnJvciwgZnJvbVJlYWRhYmxlU3RyZWFtKHIuZGF0YSldKTtcbiAgICAgICAgICAgIGlmICh2c1swXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh2c1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldChuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBpbmZvID0geWllbGQgdGhpcy5yYXdJbmZvKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGluZm8gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZm8uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5mby5vcHRpb25zICYmIGluZm8ub3B0aW9ucy5saW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG4gPSBpbmZvLm9wdGlvbnMubGluay5uYW1lIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKGxuID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxpbmsgaXMgYSBidWNrZXRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG9zID0gaW5mby5vcHRpb25zLmxpbmsuYnVja2V0ICE9PSB0aGlzLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyB5aWVsZCBPYmplY3RTdG9yZUltcGwuY3JlYXRlKHRoaXMuanMsIGluZm8ub3B0aW9ucy5saW5rLmJ1Y2tldClcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBvcy5nZXQobG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZCA9ICgwLCB1dGlsXzEuZGVmZXJyZWQpKCk7XG4gICAgICAgICAgICBjb25zdCByID0ge1xuICAgICAgICAgICAgICAgIGluZm86IG5ldyBPYmplY3RJbmZvSW1wbChpbmZvKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW5mby5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgci5kYXRhID0gZW1wdHlSZWFkYWJsZVN0cmVhbSgpO1xuICAgICAgICAgICAgICAgIGQucmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvbnRyb2xsZXI7XG4gICAgICAgICAgICBjb25zdCBvYyA9ICgwLCB0eXBlc18xLmNvbnN1bWVyT3B0cykoKTtcbiAgICAgICAgICAgIG9jLm9yZGVyZWRDb25zdW1lcigpO1xuICAgICAgICAgICAgY29uc3Qgc2hhID0gbmV3IHNoYTI1Nl8xLlNIQTI1NigpO1xuICAgICAgICAgICAgY29uc3Qgc3ViaiA9IGAkTy4ke3RoaXMubmFtZX0uQy4ke2luZm8ubnVpZH1gO1xuICAgICAgICAgICAgY29uc3Qgc3ViID0geWllbGQgdGhpcy5qcy5zdWJzY3JpYmUoc3Viaiwgb2MpO1xuICAgICAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMiwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgc3ViXzEgPSBfX2FzeW5jVmFsdWVzKHN1YiksIHN1Yl8xXzE7IHN1Yl8xXzEgPSB5aWVsZCBzdWJfMS5uZXh0KCksIF9hID0gc3ViXzFfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBzdWJfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGptID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoam0uZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhLnVwZGF0ZShqbS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoam0uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoam0uaW5mby5wZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IHNoYS5kaWdlc3QoXCJiYXNlNjRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ28gcGFkcyB0aGUgaGFzaCAtIHdoaWNoIHNob3VsZCBiZSBtdWx0aXBsZSBvZiAzIC0gb3RoZXJ3aXNlIHBhZHMgd2l0aCAnPSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWQgPSBoYXNoLmxlbmd0aCAlIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZyA9IHBhZCA+IDAgPyBcIj1cIi5yZXBlYXQocGFkKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlnZXN0ID0gYCR7ZXhwb3J0cy5kaWdlc3RUeXBlfSR7aGFzaH0ke3BhZGRpbmd9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlnZXN0ICE9PSBpbmZvLmRpZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihgcmVjZWl2ZWQgYSBjb3JydXB0IG9iamVjdCwgZGlnZXN0cyBkbyBub3QgbWF0Y2ggcmVjZWl2ZWQ6ICR7aW5mby5kaWdlc3R9IGNhbGN1bGF0ZWQgJHtkaWdlc3R9YCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gc3ViXzEucmV0dXJuKSkgeWllbGQgX2IuY2FsbChzdWJfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByLmRhdGEgPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgICAgIHN0YXJ0KGMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlciA9IGM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYW5jZWwoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlua1N0b3JlKG5hbWUsIGJ1Y2tldCkge1xuICAgICAgICBpZiAoIShidWNrZXQgaW5zdGFuY2VvZiBPYmplY3RTdG9yZUltcGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJidWNrZXQgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3NpID0gYnVja2V0O1xuICAgICAgICBjb25zdCB7IG5hbWU6IG4sIGVycm9yIH0gPSB0aGlzLl9jaGVja05vdEVtcHR5KG5hbWUpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IG4sXG4gICAgICAgICAgICBvcHRpb25zOiB7IGxpbms6IHsgYnVja2V0OiBvc2kubmFtZSB9IH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9wdXQobWV0YSwgbnVsbCk7XG4gICAgfVxuICAgIGxpbmsobmFtZSwgaW5mbykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lOiBuLCBlcnJvciB9ID0gdGhpcy5fY2hlY2tOb3RFbXB0eShuYW1lKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5mby5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcInNyYyBvYmplY3QgaXMgZGVsZXRlZFwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5mby5pc0xpbmsoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJzcmMgb2JqZWN0IGlzIGEgbGlua1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXN0ID0geWllbGQgdGhpcy5yYXdJbmZvKG5hbWUpO1xuICAgICAgICAgICAgaWYgKGRlc3QgIT09IG51bGwgJiYgIWRlc3QuZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJhbiBvYmplY3QgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGF0IG5hbWVcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGluayA9IHsgYnVja2V0OiBpbmZvLmJ1Y2tldCwgbmFtZTogaW5mby5uYW1lIH07XG4gICAgICAgICAgICBjb25zdCBtbSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuLFxuICAgICAgICAgICAgICAgIGJ1Y2tldDogaW5mby5idWNrZXQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogeyBsaW5rOiBsaW5rIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeWllbGQgdGhpcy5qcy5wdWJsaXNoKHRoaXMuX21ldGFTdWJqZWN0KG5hbWUpLCBKU09OLnN0cmluZ2lmeShtbSkpO1xuICAgICAgICAgICAgY29uc3QgaSA9IHlpZWxkIHRoaXMuaW5mbyhuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHlpZWxkIHRoaXMucmF3SW5mbyhuYW1lKTtcbiAgICAgICAgICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHB1cmdlZDogMCwgc3VjY2VzczogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmZvLmRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaW5mby5zaXplID0gMDtcbiAgICAgICAgICAgIGluZm8uY2h1bmtzID0gMDtcbiAgICAgICAgICAgIGluZm8uZGlnZXN0ID0gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGpjID0gKDAsIGNvZGVjXzEuSlNPTkNvZGVjKSgpO1xuICAgICAgICAgICAgY29uc3QgaCA9ICgwLCBoZWFkZXJzXzEuaGVhZGVycykoKTtcbiAgICAgICAgICAgIGguc2V0KHR5cGVzXzEuSnNIZWFkZXJzLlJvbGx1cEhkciwgdHlwZXNfMS5Kc0hlYWRlcnMuUm9sbHVwVmFsdWVTdWJqZWN0KTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuanMucHVibGlzaCh0aGlzLl9tZXRhU3ViamVjdChpbmZvLm5hbWUpLCBqYy5lbmNvZGUoaW5mbyksIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5qc20uc3RyZWFtcy5wdXJnZSh0aGlzLnN0cmVhbSwge1xuICAgICAgICAgICAgICAgIGZpbHRlcjogdGhpcy5fY2h1bmtTdWJqZWN0KGluZm8ubnVpZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZShuYW1lLCBtZXRhID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHlpZWxkIHRoaXMucmF3SW5mbyhuYW1lKTtcbiAgICAgICAgICAgIGlmIChpbmZvID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIm9iamVjdCBub3QgZm91bmRcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZm8uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJjYW5ub3QgdXBkYXRlIG1ldGEgZm9yIGEgZGVsZXRlZCBvYmplY3RcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YS5uYW1lID0gKF9hID0gbWV0YS5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBpbmZvLm5hbWU7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWU6IG4sIGVycm9yIH0gPSB0aGlzLl9jaGVja05vdEVtcHR5KG1ldGEubmFtZSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgIT09IG1ldGEubmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkgPSB5aWVsZCB0aGlzLmluZm8obWV0YS5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoaSAmJiAhaS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJhbiBvYmplY3QgYWxyZWFkeSBleGlzdHMgd2l0aCB0aGF0IG5hbWVcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGEubmFtZSA9IG47XG4gICAgICAgICAgICBjb25zdCBpaSA9IE9iamVjdC5hc3NpZ24oe30sIGluZm8sIHRvU2VydmVyT2JqZWN0U3RvcmVNZXRhKG1ldGEpKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBuYW1lIGNoYW5nZWQsIGRlbGV0ZSB0aGUgb2xkIG1ldGFcbiAgICAgICAgICAgIGNvbnN0IGFjayA9IHlpZWxkIHRoaXMuanMucHVibGlzaCh0aGlzLl9tZXRhU3ViamVjdChpaS5uYW1lKSwgSlNPTi5zdHJpbmdpZnkoaWkpKTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBtZXRhLm5hbWUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmpzbS5zdHJlYW1zLnB1cmdlKHRoaXMuc3RyZWFtLCB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogdGhpcy5fbWV0YVN1YmplY3QobmFtZSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3YXRjaChvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIG9wdHMuaW5jbHVkZUhpc3RvcnkgPSAoX2EgPSBvcHRzLmluY2x1ZGVIaXN0b3J5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZTtcbiAgICAgICAgICAgIG9wdHMuaWdub3JlRGVsZXRlcyA9IChfYiA9IG9wdHMuaWdub3JlRGVsZXRlcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgICAgICAgICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHFpID0gbmV3IHF1ZXVlZF9pdGVyYXRvcl8xLlF1ZXVlZEl0ZXJhdG9ySW1wbCgpO1xuICAgICAgICAgICAgY29uc3Qgc3ViaiA9IHRoaXMuX21ldGFTdWJqZWN0QWxsKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuanNtLnN0cmVhbXMuZ2V0TWVzc2FnZSh0aGlzLnN0cmVhbSwgeyBsYXN0X2J5X3N1Ymo6IHN1YmogfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlID09PSBcIjQwNFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBqYyA9ICgwLCBjb2RlY18xLkpTT05Db2RlYykoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvcHRzID0gKDAsIHR5cGVzXzEuY29uc3VtZXJPcHRzKSgpO1xuICAgICAgICAgICAgY29wdHMub3JkZXJlZENvbnN1bWVyKCk7XG4gICAgICAgICAgICBpZiAob3B0cy5pbmNsdWRlSGlzdG9yeSkge1xuICAgICAgICAgICAgICAgIGNvcHRzLmRlbGl2ZXJMYXN0UGVyU3ViamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IEdvJ3MgaW1wbGVtZW50YXRpb24gZG9lc24ndCBzZWVtIGNvcnJlY3QgLSBpZiBoaXN0b3J5IGlzIG5vdCBkZXNpcmVkXG4gICAgICAgICAgICAgICAgLy8gIHRoZSB3YXRjaCBzaG91bGQgb25seSBiZSBnaXZpbmcgbm90aWZpY2F0aW9ucyBvbiBuZXcgZW50cmllc1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb3B0cy5kZWxpdmVyTmV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3B0cy5jYWxsYmFjaygoZXJyLCBqbSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoam0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2kgPSBqYy5kZWNvZGUoam0uZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvaS5kZWxldGVkICYmIG9wdHMuaWdub3JlRGVsZXRlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcWkucHVzaChvaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBqbS5pbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVuZGluZykgPT09IDAgJiYgIWluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBxaS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSB5aWVsZCB0aGlzLmpzLnN1YnNjcmliZShzdWJqLCBjb3B0cyk7XG4gICAgICAgICAgICBxaS5fZGF0YSA9IHN1YjtcbiAgICAgICAgICAgIHFpLml0ZXJDbG9zZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN1Yi5jbG9zZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgcWkuc3RvcCgpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHFpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NodW5rU3ViamVjdChpZCkge1xuICAgICAgICByZXR1cm4gYCRPLiR7dGhpcy5uYW1lfS5DLiR7aWR9YDtcbiAgICB9XG4gICAgX21ldGFTdWJqZWN0KG4pIHtcbiAgICAgICAgcmV0dXJuIGAkTy4ke3RoaXMubmFtZX0uTS4ke2Jhc2U2NF8xLkJhc2U2NFVybFBhZGRlZENvZGVjLmVuY29kZShuKX1gO1xuICAgIH1cbiAgICBfbWV0YVN1YmplY3RBbGwoKSB7XG4gICAgICAgIHJldHVybiBgJE8uJHt0aGlzLm5hbWV9Lk0uPmA7XG4gICAgfVxuICAgIGluaXQob3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtID0gb2JqZWN0U3RvcmVTdHJlYW1OYW1lKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXhfYWdlID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy50dGwpIHx8IDA7XG4gICAgICAgICAgICBkZWxldGUgb3B0cy50dGw7XG4gICAgICAgICAgICAvLyBwYWNpZnkgdGhlIHRzYyBjb21waWxlciBkb3duc3RyZWFtXG4gICAgICAgICAgICBjb25zdCBzYyA9IE9iamVjdC5hc3NpZ24oeyBtYXhfYWdlIH0sIG9wdHMpO1xuICAgICAgICAgICAgc2MubmFtZSA9IHRoaXMuc3RyZWFtO1xuICAgICAgICAgICAgc2MuYWxsb3dfZGlyZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHNjLmFsbG93X3JvbGx1cF9oZHJzID0gdHJ1ZTtcbiAgICAgICAgICAgIHNjLmRpc2NhcmQgPSBqc2FwaV90eXBlc18xLkRpc2NhcmRQb2xpY3kuTmV3O1xuICAgICAgICAgICAgc2Muc3ViamVjdHMgPSBbYCRPLiR7dGhpcy5uYW1lfS5DLj5gLCBgJE8uJHt0aGlzLm5hbWV9Lk0uPmBdO1xuICAgICAgICAgICAgaWYgKG9wdHMucGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgc2MucGxhY2VtZW50ID0gb3B0cy5wbGFjZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHNjLm1ldGFkYXRhID0gb3B0cy5tZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5jb21wcmVzc2lvbiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBzYy5jb21wcmVzc2lvbiA9IG9wdHMuY29tcHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgPyBqc2FwaV90eXBlc18xLlN0b3JlQ29tcHJlc3Npb24uUzJcbiAgICAgICAgICAgICAgICAgICAgOiBqc2FwaV90eXBlc18xLlN0b3JlQ29tcHJlc3Npb24uTm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5qc20uc3RyZWFtcy5pbmZvKHNjLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gXCJzdHJlYW0gbm90IGZvdW5kXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5qc20uc3RyZWFtcy5hZGQoc2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoanMsIG5hbWUsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QganNtID0geWllbGQganMuamV0c3RyZWFtTWFuYWdlcigpO1xuICAgICAgICAgICAgY29uc3Qgb3MgPSBuZXcgT2JqZWN0U3RvcmVJbXBsKG5hbWUsIGpzbSwganMpO1xuICAgICAgICAgICAgeWllbGQgb3MuaW5pdChvcHRzKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUob3MpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk9iamVjdFN0b3JlSW1wbCA9IE9iamVjdFN0b3JlSW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9iamVjdHN0b3JlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/objectstore.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/jetstream/types.js":
/*!**************************************************!*\
  !*** ./node_modules/nats/lib/jetstream/types.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isConsumerOptsBuilder = exports.consumerOpts = exports.ConsumerOptsBuilderImpl = exports.kvPrefix = exports.RepublishHeaders = exports.DirectMsgHeaders = exports.KvWatchInclude = exports.JsHeaders = exports.AdvisoryKind = void 0;\nconst jsapi_types_1 = __webpack_require__(/*! ./jsapi_types */ \"(rsc)/./node_modules/nats/lib/jetstream/jsapi_types.js\");\nconst jsutil_1 = __webpack_require__(/*! ./jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\n/**\n * The different kinds of Advisories\n */\nvar AdvisoryKind;\n(function (AdvisoryKind) {\n    AdvisoryKind[\"API\"] = \"api_audit\";\n    AdvisoryKind[\"StreamAction\"] = \"stream_action\";\n    AdvisoryKind[\"ConsumerAction\"] = \"consumer_action\";\n    AdvisoryKind[\"SnapshotCreate\"] = \"snapshot_create\";\n    AdvisoryKind[\"SnapshotComplete\"] = \"snapshot_complete\";\n    AdvisoryKind[\"RestoreCreate\"] = \"restore_create\";\n    AdvisoryKind[\"RestoreComplete\"] = \"restore_complete\";\n    AdvisoryKind[\"MaxDeliver\"] = \"max_deliver\";\n    AdvisoryKind[\"Terminated\"] = \"terminated\";\n    AdvisoryKind[\"Ack\"] = \"consumer_ack\";\n    AdvisoryKind[\"StreamLeaderElected\"] = \"stream_leader_elected\";\n    AdvisoryKind[\"StreamQuorumLost\"] = \"stream_quorum_lost\";\n    AdvisoryKind[\"ConsumerLeaderElected\"] = \"consumer_leader_elected\";\n    AdvisoryKind[\"ConsumerQuorumLost\"] = \"consumer_quorum_lost\";\n})(AdvisoryKind || (exports.AdvisoryKind = AdvisoryKind = {}));\nvar JsHeaders;\n(function (JsHeaders) {\n    /**\n     * Set if message is from a stream source - format is `stream seq`\n     */\n    JsHeaders[\"StreamSourceHdr\"] = \"Nats-Stream-Source\";\n    /**\n     * Set for heartbeat messages\n     */\n    JsHeaders[\"LastConsumerSeqHdr\"] = \"Nats-Last-Consumer\";\n    /**\n     * Set for heartbeat messages\n     */\n    JsHeaders[\"LastStreamSeqHdr\"] = \"Nats-Last-Stream\";\n    /**\n     * Set for heartbeat messages if the consumer is stalled\n     */\n    JsHeaders[\"ConsumerStalledHdr\"] = \"Nats-Consumer-Stalled\";\n    /**\n     * Set for headers_only consumers indicates the number of bytes in the payload\n     */\n    JsHeaders[\"MessageSizeHdr\"] = \"Nats-Msg-Size\";\n    // rollup header\n    JsHeaders[\"RollupHdr\"] = \"Nats-Rollup\";\n    // value for rollup header when rolling up a subject\n    JsHeaders[\"RollupValueSubject\"] = \"sub\";\n    // value for rollup header when rolling up all subjects\n    JsHeaders[\"RollupValueAll\"] = \"all\";\n    /**\n     * Set on protocol messages to indicate pull request message count that\n     * was not honored.\n     */\n    JsHeaders[\"PendingMessagesHdr\"] = \"Nats-Pending-Messages\";\n    /**\n     * Set on protocol messages to indicate pull request byte count that\n     * was not honored\n     */\n    JsHeaders[\"PendingBytesHdr\"] = \"Nats-Pending-Bytes\";\n})(JsHeaders || (exports.JsHeaders = JsHeaders = {}));\nvar KvWatchInclude;\n(function (KvWatchInclude) {\n    /**\n     * Include the last value for all the keys\n     */\n    KvWatchInclude[\"LastValue\"] = \"\";\n    /**\n     * Include all available history for all keys\n     */\n    KvWatchInclude[\"AllHistory\"] = \"history\";\n    /**\n     * Don't include history or last values, only notify\n     * of updates\n     */\n    KvWatchInclude[\"UpdatesOnly\"] = \"updates\";\n})(KvWatchInclude || (exports.KvWatchInclude = KvWatchInclude = {}));\nvar DirectMsgHeaders;\n(function (DirectMsgHeaders) {\n    DirectMsgHeaders[\"Stream\"] = \"Nats-Stream\";\n    DirectMsgHeaders[\"Sequence\"] = \"Nats-Sequence\";\n    DirectMsgHeaders[\"TimeStamp\"] = \"Nats-Time-Stamp\";\n    DirectMsgHeaders[\"Subject\"] = \"Nats-Subject\";\n})(DirectMsgHeaders || (exports.DirectMsgHeaders = DirectMsgHeaders = {}));\nvar RepublishHeaders;\n(function (RepublishHeaders) {\n    /**\n     * The source stream of the message\n     */\n    RepublishHeaders[\"Stream\"] = \"Nats-Stream\";\n    /**\n     * The original subject of the message\n     */\n    RepublishHeaders[\"Subject\"] = \"Nats-Subject\";\n    /**\n     * The sequence of the republished message\n     */\n    RepublishHeaders[\"Sequence\"] = \"Nats-Sequence\";\n    /**\n     * The stream sequence id of the last message ingested to the same original subject (or 0 if none or deleted)\n     */\n    RepublishHeaders[\"LastSequence\"] = \"Nats-Last-Sequence\";\n    /**\n     * The size in bytes of the message's body - Only if {@link Republish#headers_only} is set.\n     */\n    RepublishHeaders[\"Size\"] = \"Nats-Msg-Size\";\n})(RepublishHeaders || (exports.RepublishHeaders = RepublishHeaders = {}));\nexports.kvPrefix = \"KV_\";\n// FIXME: some items here that may need to be addressed\n// 503s?\n// maxRetries()\n// retryBackoff()\n// ackWait(time)\n// replayOriginal()\n// rateLimit(bytesPerSec)\nclass ConsumerOptsBuilderImpl {\n    constructor(opts) {\n        this.stream = \"\";\n        this.mack = false;\n        this.ordered = false;\n        this.config = (0, jsapi_types_1.defaultConsumer)(\"\", opts || {});\n    }\n    getOpts() {\n        var _a;\n        const o = {};\n        o.config = Object.assign({}, this.config);\n        if (o.config.filter_subject) {\n            this.filterSubject(o.config.filter_subject);\n            o.config.filter_subject = undefined;\n        }\n        if (o.config.filter_subjects) {\n            (_a = o.config.filter_subjects) === null || _a === void 0 ? void 0 : _a.forEach((v) => {\n                this.filterSubject(v);\n            });\n            o.config.filter_subjects = undefined;\n        }\n        o.mack = this.mack;\n        o.stream = this.stream;\n        o.callbackFn = this.callbackFn;\n        o.max = this.max;\n        o.queue = this.qname;\n        o.ordered = this.ordered;\n        o.config.ack_policy = o.ordered ? jsapi_types_1.AckPolicy.None : o.config.ack_policy;\n        o.isBind = o.isBind || false;\n        if (this.filters) {\n            switch (this.filters.length) {\n                case 0:\n                    break;\n                case 1:\n                    o.config.filter_subject = this.filters[0];\n                    break;\n                default:\n                    o.config.filter_subjects = this.filters;\n            }\n        }\n        return o;\n    }\n    description(description) {\n        this.config.description = description;\n        return this;\n    }\n    deliverTo(subject) {\n        this.config.deliver_subject = subject;\n        return this;\n    }\n    durable(name) {\n        (0, jsutil_1.validateDurableName)(name);\n        this.config.durable_name = name;\n        return this;\n    }\n    startSequence(seq) {\n        if (seq <= 0) {\n            throw new Error(\"sequence must be greater than 0\");\n        }\n        this.config.deliver_policy = jsapi_types_1.DeliverPolicy.StartSequence;\n        this.config.opt_start_seq = seq;\n        return this;\n    }\n    startTime(time) {\n        this.config.deliver_policy = jsapi_types_1.DeliverPolicy.StartTime;\n        this.config.opt_start_time = time.toISOString();\n        return this;\n    }\n    deliverAll() {\n        this.config.deliver_policy = jsapi_types_1.DeliverPolicy.All;\n        return this;\n    }\n    deliverLastPerSubject() {\n        this.config.deliver_policy = jsapi_types_1.DeliverPolicy.LastPerSubject;\n        return this;\n    }\n    deliverLast() {\n        this.config.deliver_policy = jsapi_types_1.DeliverPolicy.Last;\n        return this;\n    }\n    deliverNew() {\n        this.config.deliver_policy = jsapi_types_1.DeliverPolicy.New;\n        return this;\n    }\n    startAtTimeDelta(millis) {\n        this.startTime(new Date(Date.now() - millis));\n        return this;\n    }\n    headersOnly() {\n        this.config.headers_only = true;\n        return this;\n    }\n    ackNone() {\n        this.config.ack_policy = jsapi_types_1.AckPolicy.None;\n        return this;\n    }\n    ackAll() {\n        this.config.ack_policy = jsapi_types_1.AckPolicy.All;\n        return this;\n    }\n    ackExplicit() {\n        this.config.ack_policy = jsapi_types_1.AckPolicy.Explicit;\n        return this;\n    }\n    ackWait(millis) {\n        this.config.ack_wait = (0, jsutil_1.nanos)(millis);\n        return this;\n    }\n    maxDeliver(max) {\n        this.config.max_deliver = max;\n        return this;\n    }\n    filterSubject(s) {\n        this.filters = this.filters || [];\n        this.filters.push(s);\n        return this;\n    }\n    replayInstantly() {\n        this.config.replay_policy = jsapi_types_1.ReplayPolicy.Instant;\n        return this;\n    }\n    replayOriginal() {\n        this.config.replay_policy = jsapi_types_1.ReplayPolicy.Original;\n        return this;\n    }\n    sample(n) {\n        n = Math.trunc(n);\n        if (n < 0 || n > 100) {\n            throw new Error(`value must be between 0-100`);\n        }\n        this.config.sample_freq = `${n}%`;\n        return this;\n    }\n    limit(n) {\n        this.config.rate_limit_bps = n;\n        return this;\n    }\n    maxWaiting(max) {\n        this.config.max_waiting = max;\n        return this;\n    }\n    maxAckPending(max) {\n        this.config.max_ack_pending = max;\n        return this;\n    }\n    idleHeartbeat(millis) {\n        this.config.idle_heartbeat = (0, jsutil_1.nanos)(millis);\n        return this;\n    }\n    flowControl() {\n        this.config.flow_control = true;\n        return this;\n    }\n    deliverGroup(name) {\n        this.queue(name);\n        return this;\n    }\n    manualAck() {\n        this.mack = true;\n        return this;\n    }\n    maxMessages(max) {\n        this.max = max;\n        return this;\n    }\n    callback(fn) {\n        this.callbackFn = fn;\n        return this;\n    }\n    queue(n) {\n        this.qname = n;\n        this.config.deliver_group = n;\n        return this;\n    }\n    orderedConsumer() {\n        this.ordered = true;\n        return this;\n    }\n    bind(stream, durable) {\n        this.stream = stream;\n        this.config.durable_name = durable;\n        this.isBind = true;\n        return this;\n    }\n    bindStream(stream) {\n        this.stream = stream;\n        return this;\n    }\n    inactiveEphemeralThreshold(millis) {\n        this.config.inactive_threshold = (0, jsutil_1.nanos)(millis);\n        return this;\n    }\n    maxPullBatch(n) {\n        this.config.max_batch = n;\n        return this;\n    }\n    maxPullRequestExpires(millis) {\n        this.config.max_expires = (0, jsutil_1.nanos)(millis);\n        return this;\n    }\n    memory() {\n        this.config.mem_storage = true;\n        return this;\n    }\n    numReplicas(n) {\n        this.config.num_replicas = n;\n        return this;\n    }\n}\nexports.ConsumerOptsBuilderImpl = ConsumerOptsBuilderImpl;\nfunction consumerOpts(opts) {\n    return new ConsumerOptsBuilderImpl(opts);\n}\nexports.consumerOpts = consumerOpts;\nfunction isConsumerOptsBuilder(o) {\n    return typeof o.getOpts === \"function\";\n}\nexports.isConsumerOptsBuilder = isConsumerOptsBuilder;\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvamV0c3RyZWFtL3R5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyxvQkFBb0IsR0FBRywrQkFBK0IsR0FBRyxnQkFBZ0IsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRyxzQkFBc0IsR0FBRyxpQkFBaUIsR0FBRyxvQkFBb0I7QUFDbk8sc0JBQXNCLG1CQUFPLENBQUMsNkVBQWU7QUFDN0MsaUJBQWlCLG1CQUFPLENBQUMsbUVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQixvQkFBb0Isb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUIsd0JBQXdCLHdCQUF3QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw4QkFBOEI7QUFDeEY7QUFDQTtBQUNBLENBQUMsdUJBQXVCLHdCQUF3Qix3QkFBd0I7QUFDeEUsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL2pldHN0cmVhbS90eXBlcy5qcz9mZGQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIzIFRoZSBOQVRTIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzQ29uc3VtZXJPcHRzQnVpbGRlciA9IGV4cG9ydHMuY29uc3VtZXJPcHRzID0gZXhwb3J0cy5Db25zdW1lck9wdHNCdWlsZGVySW1wbCA9IGV4cG9ydHMua3ZQcmVmaXggPSBleHBvcnRzLlJlcHVibGlzaEhlYWRlcnMgPSBleHBvcnRzLkRpcmVjdE1zZ0hlYWRlcnMgPSBleHBvcnRzLkt2V2F0Y2hJbmNsdWRlID0gZXhwb3J0cy5Kc0hlYWRlcnMgPSBleHBvcnRzLkFkdmlzb3J5S2luZCA9IHZvaWQgMDtcbmNvbnN0IGpzYXBpX3R5cGVzXzEgPSByZXF1aXJlKFwiLi9qc2FwaV90eXBlc1wiKTtcbmNvbnN0IGpzdXRpbF8xID0gcmVxdWlyZShcIi4vanN1dGlsXCIpO1xuLyoqXG4gKiBUaGUgZGlmZmVyZW50IGtpbmRzIG9mIEFkdmlzb3JpZXNcbiAqL1xudmFyIEFkdmlzb3J5S2luZDtcbihmdW5jdGlvbiAoQWR2aXNvcnlLaW5kKSB7XG4gICAgQWR2aXNvcnlLaW5kW1wiQVBJXCJdID0gXCJhcGlfYXVkaXRcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJTdHJlYW1BY3Rpb25cIl0gPSBcInN0cmVhbV9hY3Rpb25cIjtcbiAgICBBZHZpc29yeUtpbmRbXCJDb25zdW1lckFjdGlvblwiXSA9IFwiY29uc3VtZXJfYWN0aW9uXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiU25hcHNob3RDcmVhdGVcIl0gPSBcInNuYXBzaG90X2NyZWF0ZVwiO1xuICAgIEFkdmlzb3J5S2luZFtcIlNuYXBzaG90Q29tcGxldGVcIl0gPSBcInNuYXBzaG90X2NvbXBsZXRlXCI7XG4gICAgQWR2aXNvcnlLaW5kW1wiUmVzdG9yZUNyZWF0ZVwiXSA9IFwicmVzdG9yZV9jcmVhdGVcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJSZXN0b3JlQ29tcGxldGVcIl0gPSBcInJlc3RvcmVfY29tcGxldGVcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJNYXhEZWxpdmVyXCJdID0gXCJtYXhfZGVsaXZlclwiO1xuICAgIEFkdmlzb3J5S2luZFtcIlRlcm1pbmF0ZWRcIl0gPSBcInRlcm1pbmF0ZWRcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJBY2tcIl0gPSBcImNvbnN1bWVyX2Fja1wiO1xuICAgIEFkdmlzb3J5S2luZFtcIlN0cmVhbUxlYWRlckVsZWN0ZWRcIl0gPSBcInN0cmVhbV9sZWFkZXJfZWxlY3RlZFwiO1xuICAgIEFkdmlzb3J5S2luZFtcIlN0cmVhbVF1b3J1bUxvc3RcIl0gPSBcInN0cmVhbV9xdW9ydW1fbG9zdFwiO1xuICAgIEFkdmlzb3J5S2luZFtcIkNvbnN1bWVyTGVhZGVyRWxlY3RlZFwiXSA9IFwiY29uc3VtZXJfbGVhZGVyX2VsZWN0ZWRcIjtcbiAgICBBZHZpc29yeUtpbmRbXCJDb25zdW1lclF1b3J1bUxvc3RcIl0gPSBcImNvbnN1bWVyX3F1b3J1bV9sb3N0XCI7XG59KShBZHZpc29yeUtpbmQgfHwgKGV4cG9ydHMuQWR2aXNvcnlLaW5kID0gQWR2aXNvcnlLaW5kID0ge30pKTtcbnZhciBKc0hlYWRlcnM7XG4oZnVuY3Rpb24gKEpzSGVhZGVycykge1xuICAgIC8qKlxuICAgICAqIFNldCBpZiBtZXNzYWdlIGlzIGZyb20gYSBzdHJlYW0gc291cmNlIC0gZm9ybWF0IGlzIGBzdHJlYW0gc2VxYFxuICAgICAqL1xuICAgIEpzSGVhZGVyc1tcIlN0cmVhbVNvdXJjZUhkclwiXSA9IFwiTmF0cy1TdHJlYW0tU291cmNlXCI7XG4gICAgLyoqXG4gICAgICogU2V0IGZvciBoZWFydGJlYXQgbWVzc2FnZXNcbiAgICAgKi9cbiAgICBKc0hlYWRlcnNbXCJMYXN0Q29uc3VtZXJTZXFIZHJcIl0gPSBcIk5hdHMtTGFzdC1Db25zdW1lclwiO1xuICAgIC8qKlxuICAgICAqIFNldCBmb3IgaGVhcnRiZWF0IG1lc3NhZ2VzXG4gICAgICovXG4gICAgSnNIZWFkZXJzW1wiTGFzdFN0cmVhbVNlcUhkclwiXSA9IFwiTmF0cy1MYXN0LVN0cmVhbVwiO1xuICAgIC8qKlxuICAgICAqIFNldCBmb3IgaGVhcnRiZWF0IG1lc3NhZ2VzIGlmIHRoZSBjb25zdW1lciBpcyBzdGFsbGVkXG4gICAgICovXG4gICAgSnNIZWFkZXJzW1wiQ29uc3VtZXJTdGFsbGVkSGRyXCJdID0gXCJOYXRzLUNvbnN1bWVyLVN0YWxsZWRcIjtcbiAgICAvKipcbiAgICAgKiBTZXQgZm9yIGhlYWRlcnNfb25seSBjb25zdW1lcnMgaW5kaWNhdGVzIHRoZSBudW1iZXIgb2YgYnl0ZXMgaW4gdGhlIHBheWxvYWRcbiAgICAgKi9cbiAgICBKc0hlYWRlcnNbXCJNZXNzYWdlU2l6ZUhkclwiXSA9IFwiTmF0cy1Nc2ctU2l6ZVwiO1xuICAgIC8vIHJvbGx1cCBoZWFkZXJcbiAgICBKc0hlYWRlcnNbXCJSb2xsdXBIZHJcIl0gPSBcIk5hdHMtUm9sbHVwXCI7XG4gICAgLy8gdmFsdWUgZm9yIHJvbGx1cCBoZWFkZXIgd2hlbiByb2xsaW5nIHVwIGEgc3ViamVjdFxuICAgIEpzSGVhZGVyc1tcIlJvbGx1cFZhbHVlU3ViamVjdFwiXSA9IFwic3ViXCI7XG4gICAgLy8gdmFsdWUgZm9yIHJvbGx1cCBoZWFkZXIgd2hlbiByb2xsaW5nIHVwIGFsbCBzdWJqZWN0c1xuICAgIEpzSGVhZGVyc1tcIlJvbGx1cFZhbHVlQWxsXCJdID0gXCJhbGxcIjtcbiAgICAvKipcbiAgICAgKiBTZXQgb24gcHJvdG9jb2wgbWVzc2FnZXMgdG8gaW5kaWNhdGUgcHVsbCByZXF1ZXN0IG1lc3NhZ2UgY291bnQgdGhhdFxuICAgICAqIHdhcyBub3QgaG9ub3JlZC5cbiAgICAgKi9cbiAgICBKc0hlYWRlcnNbXCJQZW5kaW5nTWVzc2FnZXNIZHJcIl0gPSBcIk5hdHMtUGVuZGluZy1NZXNzYWdlc1wiO1xuICAgIC8qKlxuICAgICAqIFNldCBvbiBwcm90b2NvbCBtZXNzYWdlcyB0byBpbmRpY2F0ZSBwdWxsIHJlcXVlc3QgYnl0ZSBjb3VudCB0aGF0XG4gICAgICogd2FzIG5vdCBob25vcmVkXG4gICAgICovXG4gICAgSnNIZWFkZXJzW1wiUGVuZGluZ0J5dGVzSGRyXCJdID0gXCJOYXRzLVBlbmRpbmctQnl0ZXNcIjtcbn0pKEpzSGVhZGVycyB8fCAoZXhwb3J0cy5Kc0hlYWRlcnMgPSBKc0hlYWRlcnMgPSB7fSkpO1xudmFyIEt2V2F0Y2hJbmNsdWRlO1xuKGZ1bmN0aW9uIChLdldhdGNoSW5jbHVkZSkge1xuICAgIC8qKlxuICAgICAqIEluY2x1ZGUgdGhlIGxhc3QgdmFsdWUgZm9yIGFsbCB0aGUga2V5c1xuICAgICAqL1xuICAgIEt2V2F0Y2hJbmNsdWRlW1wiTGFzdFZhbHVlXCJdID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBJbmNsdWRlIGFsbCBhdmFpbGFibGUgaGlzdG9yeSBmb3IgYWxsIGtleXNcbiAgICAgKi9cbiAgICBLdldhdGNoSW5jbHVkZVtcIkFsbEhpc3RvcnlcIl0gPSBcImhpc3RvcnlcIjtcbiAgICAvKipcbiAgICAgKiBEb24ndCBpbmNsdWRlIGhpc3Rvcnkgb3IgbGFzdCB2YWx1ZXMsIG9ubHkgbm90aWZ5XG4gICAgICogb2YgdXBkYXRlc1xuICAgICAqL1xuICAgIEt2V2F0Y2hJbmNsdWRlW1wiVXBkYXRlc09ubHlcIl0gPSBcInVwZGF0ZXNcIjtcbn0pKEt2V2F0Y2hJbmNsdWRlIHx8IChleHBvcnRzLkt2V2F0Y2hJbmNsdWRlID0gS3ZXYXRjaEluY2x1ZGUgPSB7fSkpO1xudmFyIERpcmVjdE1zZ0hlYWRlcnM7XG4oZnVuY3Rpb24gKERpcmVjdE1zZ0hlYWRlcnMpIHtcbiAgICBEaXJlY3RNc2dIZWFkZXJzW1wiU3RyZWFtXCJdID0gXCJOYXRzLVN0cmVhbVwiO1xuICAgIERpcmVjdE1zZ0hlYWRlcnNbXCJTZXF1ZW5jZVwiXSA9IFwiTmF0cy1TZXF1ZW5jZVwiO1xuICAgIERpcmVjdE1zZ0hlYWRlcnNbXCJUaW1lU3RhbXBcIl0gPSBcIk5hdHMtVGltZS1TdGFtcFwiO1xuICAgIERpcmVjdE1zZ0hlYWRlcnNbXCJTdWJqZWN0XCJdID0gXCJOYXRzLVN1YmplY3RcIjtcbn0pKERpcmVjdE1zZ0hlYWRlcnMgfHwgKGV4cG9ydHMuRGlyZWN0TXNnSGVhZGVycyA9IERpcmVjdE1zZ0hlYWRlcnMgPSB7fSkpO1xudmFyIFJlcHVibGlzaEhlYWRlcnM7XG4oZnVuY3Rpb24gKFJlcHVibGlzaEhlYWRlcnMpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc291cmNlIHN0cmVhbSBvZiB0aGUgbWVzc2FnZVxuICAgICAqL1xuICAgIFJlcHVibGlzaEhlYWRlcnNbXCJTdHJlYW1cIl0gPSBcIk5hdHMtU3RyZWFtXCI7XG4gICAgLyoqXG4gICAgICogVGhlIG9yaWdpbmFsIHN1YmplY3Qgb2YgdGhlIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBSZXB1Ymxpc2hIZWFkZXJzW1wiU3ViamVjdFwiXSA9IFwiTmF0cy1TdWJqZWN0XCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcXVlbmNlIG9mIHRoZSByZXB1Ymxpc2hlZCBtZXNzYWdlXG4gICAgICovXG4gICAgUmVwdWJsaXNoSGVhZGVyc1tcIlNlcXVlbmNlXCJdID0gXCJOYXRzLVNlcXVlbmNlXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHN0cmVhbSBzZXF1ZW5jZSBpZCBvZiB0aGUgbGFzdCBtZXNzYWdlIGluZ2VzdGVkIHRvIHRoZSBzYW1lIG9yaWdpbmFsIHN1YmplY3QgKG9yIDAgaWYgbm9uZSBvciBkZWxldGVkKVxuICAgICAqL1xuICAgIFJlcHVibGlzaEhlYWRlcnNbXCJMYXN0U2VxdWVuY2VcIl0gPSBcIk5hdHMtTGFzdC1TZXF1ZW5jZVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIGluIGJ5dGVzIG9mIHRoZSBtZXNzYWdlJ3MgYm9keSAtIE9ubHkgaWYge0BsaW5rIFJlcHVibGlzaCNoZWFkZXJzX29ubHl9IGlzIHNldC5cbiAgICAgKi9cbiAgICBSZXB1Ymxpc2hIZWFkZXJzW1wiU2l6ZVwiXSA9IFwiTmF0cy1Nc2ctU2l6ZVwiO1xufSkoUmVwdWJsaXNoSGVhZGVycyB8fCAoZXhwb3J0cy5SZXB1Ymxpc2hIZWFkZXJzID0gUmVwdWJsaXNoSGVhZGVycyA9IHt9KSk7XG5leHBvcnRzLmt2UHJlZml4ID0gXCJLVl9cIjtcbi8vIEZJWE1FOiBzb21lIGl0ZW1zIGhlcmUgdGhhdCBtYXkgbmVlZCB0byBiZSBhZGRyZXNzZWRcbi8vIDUwM3M/XG4vLyBtYXhSZXRyaWVzKClcbi8vIHJldHJ5QmFja29mZigpXG4vLyBhY2tXYWl0KHRpbWUpXG4vLyByZXBsYXlPcmlnaW5hbCgpXG4vLyByYXRlTGltaXQoYnl0ZXNQZXJTZWMpXG5jbGFzcyBDb25zdW1lck9wdHNCdWlsZGVySW1wbCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IFwiXCI7XG4gICAgICAgIHRoaXMubWFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9yZGVyZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb25maWcgPSAoMCwganNhcGlfdHlwZXNfMS5kZWZhdWx0Q29uc3VtZXIpKFwiXCIsIG9wdHMgfHwge30pO1xuICAgIH1cbiAgICBnZXRPcHRzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG8gPSB7fTtcbiAgICAgICAgby5jb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIGlmIChvLmNvbmZpZy5maWx0ZXJfc3ViamVjdCkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJTdWJqZWN0KG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0KTtcbiAgICAgICAgICAgIG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvLmNvbmZpZy5maWx0ZXJfc3ViamVjdHMpIHtcbiAgICAgICAgICAgIChfYSA9IG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbHRlclN1YmplY3Qodik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBvLm1hY2sgPSB0aGlzLm1hY2s7XG4gICAgICAgIG8uc3RyZWFtID0gdGhpcy5zdHJlYW07XG4gICAgICAgIG8uY2FsbGJhY2tGbiA9IHRoaXMuY2FsbGJhY2tGbjtcbiAgICAgICAgby5tYXggPSB0aGlzLm1heDtcbiAgICAgICAgby5xdWV1ZSA9IHRoaXMucW5hbWU7XG4gICAgICAgIG8ub3JkZXJlZCA9IHRoaXMub3JkZXJlZDtcbiAgICAgICAgby5jb25maWcuYWNrX3BvbGljeSA9IG8ub3JkZXJlZCA/IGpzYXBpX3R5cGVzXzEuQWNrUG9saWN5Lk5vbmUgOiBvLmNvbmZpZy5hY2tfcG9saWN5O1xuICAgICAgICBvLmlzQmluZCA9IG8uaXNCaW5kIHx8IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgby5jb25maWcuZmlsdGVyX3N1YmplY3QgPSB0aGlzLmZpbHRlcnNbMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG8uY29uZmlnLmZpbHRlcl9zdWJqZWN0cyA9IHRoaXMuZmlsdGVycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgZGVzY3JpcHRpb24oZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGl2ZXJUbyhzdWJqZWN0KSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGl2ZXJfc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkdXJhYmxlKG5hbWUpIHtcbiAgICAgICAgKDAsIGpzdXRpbF8xLnZhbGlkYXRlRHVyYWJsZU5hbWUpKG5hbWUpO1xuICAgICAgICB0aGlzLmNvbmZpZy5kdXJhYmxlX25hbWUgPSBuYW1lO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRTZXF1ZW5jZShzZXEpIHtcbiAgICAgICAgaWYgKHNlcSA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXF1ZW5jZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGl2ZXJfcG9saWN5ID0ganNhcGlfdHlwZXNfMS5EZWxpdmVyUG9saWN5LlN0YXJ0U2VxdWVuY2U7XG4gICAgICAgIHRoaXMuY29uZmlnLm9wdF9zdGFydF9zZXEgPSBzZXE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzdGFydFRpbWUodGltZSkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IGpzYXBpX3R5cGVzXzEuRGVsaXZlclBvbGljeS5TdGFydFRpbWU7XG4gICAgICAgIHRoaXMuY29uZmlnLm9wdF9zdGFydF90aW1lID0gdGltZS50b0lTT1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsaXZlckFsbCgpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGVsaXZlcl9wb2xpY3kgPSBqc2FwaV90eXBlc18xLkRlbGl2ZXJQb2xpY3kuQWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsaXZlckxhc3RQZXJTdWJqZWN0KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IGpzYXBpX3R5cGVzXzEuRGVsaXZlclBvbGljeS5MYXN0UGVyU3ViamVjdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGl2ZXJMYXN0KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5kZWxpdmVyX3BvbGljeSA9IGpzYXBpX3R5cGVzXzEuRGVsaXZlclBvbGljeS5MYXN0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsaXZlck5ldygpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZGVsaXZlcl9wb2xpY3kgPSBqc2FwaV90eXBlc18xLkRlbGl2ZXJQb2xpY3kuTmV3O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRBdFRpbWVEZWx0YShtaWxsaXMpIHtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUobmV3IERhdGUoRGF0ZS5ub3coKSAtIG1pbGxpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaGVhZGVyc09ubHkoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmhlYWRlcnNfb25seSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhY2tOb25lKCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5hY2tfcG9saWN5ID0ganNhcGlfdHlwZXNfMS5BY2tQb2xpY3kuTm9uZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFja0FsbCgpIHtcbiAgICAgICAgdGhpcy5jb25maWcuYWNrX3BvbGljeSA9IGpzYXBpX3R5cGVzXzEuQWNrUG9saWN5LkFsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFja0V4cGxpY2l0KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5hY2tfcG9saWN5ID0ganNhcGlfdHlwZXNfMS5BY2tQb2xpY3kuRXhwbGljaXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhY2tXYWl0KG1pbGxpcykge1xuICAgICAgICB0aGlzLmNvbmZpZy5hY2tfd2FpdCA9ICgwLCBqc3V0aWxfMS5uYW5vcykobWlsbGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1heERlbGl2ZXIobWF4KSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1heF9kZWxpdmVyID0gbWF4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZmlsdGVyU3ViamVjdChzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycyA9IHRoaXMuZmlsdGVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2gocyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXBsYXlJbnN0YW50bHkoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJlcGxheV9wb2xpY3kgPSBqc2FwaV90eXBlc18xLlJlcGxheVBvbGljeS5JbnN0YW50O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVwbGF5T3JpZ2luYWwoKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJlcGxheV9wb2xpY3kgPSBqc2FwaV90eXBlc18xLlJlcGxheVBvbGljeS5PcmlnaW5hbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNhbXBsZShuKSB7XG4gICAgICAgIG4gPSBNYXRoLnRydW5jKG4pO1xuICAgICAgICBpZiAobiA8IDAgfHwgbiA+IDEwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB2YWx1ZSBtdXN0IGJlIGJldHdlZW4gMC0xMDBgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZy5zYW1wbGVfZnJlcSA9IGAke259JWA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsaW1pdChuKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLnJhdGVfbGltaXRfYnBzID0gbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1heFdhaXRpbmcobWF4KSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1heF93YWl0aW5nID0gbWF4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWF4QWNrUGVuZGluZyhtYXgpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWF4X2Fja19wZW5kaW5nID0gbWF4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaWRsZUhlYXJ0YmVhdChtaWxsaXMpIHtcbiAgICAgICAgdGhpcy5jb25maWcuaWRsZV9oZWFydGJlYXQgPSAoMCwganN1dGlsXzEubmFub3MpKG1pbGxpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmbG93Q29udHJvbCgpIHtcbiAgICAgICAgdGhpcy5jb25maWcuZmxvd19jb250cm9sID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlbGl2ZXJHcm91cChuYW1lKSB7XG4gICAgICAgIHRoaXMucXVldWUobmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYW51YWxBY2soKSB7XG4gICAgICAgIHRoaXMubWFjayA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYXhNZXNzYWdlcyhtYXgpIHtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjYWxsYmFjayhmbikge1xuICAgICAgICB0aGlzLmNhbGxiYWNrRm4gPSBmbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHF1ZXVlKG4pIHtcbiAgICAgICAgdGhpcy5xbmFtZSA9IG47XG4gICAgICAgIHRoaXMuY29uZmlnLmRlbGl2ZXJfZ3JvdXAgPSBuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3JkZXJlZENvbnN1bWVyKCkge1xuICAgICAgICB0aGlzLm9yZGVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYmluZChzdHJlYW0sIGR1cmFibGUpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuY29uZmlnLmR1cmFibGVfbmFtZSA9IGR1cmFibGU7XG4gICAgICAgIHRoaXMuaXNCaW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJpbmRTdHJlYW0oc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgaW5hY3RpdmVFcGhlbWVyYWxUaHJlc2hvbGQobWlsbGlzKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmluYWN0aXZlX3RocmVzaG9sZCA9ICgwLCBqc3V0aWxfMS5uYW5vcykobWlsbGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG1heFB1bGxCYXRjaChuKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1heF9iYXRjaCA9IG47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBtYXhQdWxsUmVxdWVzdEV4cGlyZXMobWlsbGlzKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm1heF9leHBpcmVzID0gKDAsIGpzdXRpbF8xLm5hbm9zKShtaWxsaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWVtb3J5KCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5tZW1fc3RvcmFnZSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBudW1SZXBsaWNhcyhuKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLm51bV9yZXBsaWNhcyA9IG47XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uc3VtZXJPcHRzQnVpbGRlckltcGwgPSBDb25zdW1lck9wdHNCdWlsZGVySW1wbDtcbmZ1bmN0aW9uIGNvbnN1bWVyT3B0cyhvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdW1lck9wdHNCdWlsZGVySW1wbChvcHRzKTtcbn1cbmV4cG9ydHMuY29uc3VtZXJPcHRzID0gY29uc3VtZXJPcHRzO1xuZnVuY3Rpb24gaXNDb25zdW1lck9wdHNCdWlsZGVyKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG8uZ2V0T3B0cyA9PT0gXCJmdW5jdGlvblwiO1xufVxuZXhwb3J0cy5pc0NvbnN1bWVyT3B0c0J1aWxkZXIgPSBpc0NvbnN1bWVyT3B0c0J1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/jetstream/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/authenticator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/authenticator.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.credsAuthenticator = exports.jwtAuthenticator = exports.nkeyAuthenticator = exports.tokenAuthenticator = exports.usernamePasswordAuthenticator = exports.noAuthFn = exports.multiAuthenticator = void 0;\n/*\n * Copyright 2020-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst nkeys_1 = __webpack_require__(/*! ./nkeys */ \"(rsc)/./node_modules/nats/lib/nats-base-client/nkeys.js\");\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nfunction multiAuthenticator(authenticators) {\n    return (nonce) => {\n        let auth = {};\n        authenticators.forEach((a) => {\n            const args = a(nonce) || {};\n            auth = Object.assign(auth, args);\n        });\n        return auth;\n    };\n}\nexports.multiAuthenticator = multiAuthenticator;\nfunction noAuthFn() {\n    return () => {\n        return;\n    };\n}\nexports.noAuthFn = noAuthFn;\n/**\n * Returns a user/pass authenticator for the specified user and optional password\n * @param { string | () => string } user\n * @param {string | () => string } pass\n * @return {UserPass}\n */\nfunction usernamePasswordAuthenticator(user, pass) {\n    return () => {\n        const u = typeof user === \"function\" ? user() : user;\n        const p = typeof pass === \"function\" ? pass() : pass;\n        return { user: u, pass: p };\n    };\n}\nexports.usernamePasswordAuthenticator = usernamePasswordAuthenticator;\n/**\n * Returns a token authenticator for the specified token\n * @param { string | () => string } token\n * @return {TokenAuth}\n */\nfunction tokenAuthenticator(token) {\n    return () => {\n        const auth_token = typeof token === \"function\" ? token() : token;\n        return { auth_token };\n    };\n}\nexports.tokenAuthenticator = tokenAuthenticator;\n/**\n * Returns an Authenticator that returns a NKeyAuth based that uses the\n * specified seed or function returning a seed.\n * @param {Uint8Array | (() => Uint8Array)} seed - the nkey seed\n * @return {NKeyAuth}\n */\nfunction nkeyAuthenticator(seed) {\n    return (nonce) => {\n        const s = typeof seed === \"function\" ? seed() : seed;\n        const kp = s ? nkeys_1.nkeys.fromSeed(s) : undefined;\n        const nkey = kp ? kp.getPublicKey() : \"\";\n        const challenge = encoders_1.TE.encode(nonce || \"\");\n        const sigBytes = kp !== undefined && nonce ? kp.sign(challenge) : undefined;\n        const sig = sigBytes ? nkeys_1.nkeys.encode(sigBytes) : \"\";\n        return { nkey, sig };\n    };\n}\nexports.nkeyAuthenticator = nkeyAuthenticator;\n/**\n * Returns an Authenticator function that returns a JwtAuth.\n * If a seed is provided, the public key, and signature are\n * calculated.\n *\n * @param {string | ()=>string} ajwt - the jwt\n * @param {Uint8Array | ()=> Uint8Array } seed - the optional nkey seed\n * @return {Authenticator}\n */\nfunction jwtAuthenticator(ajwt, seed) {\n    return (nonce) => {\n        const jwt = typeof ajwt === \"function\" ? ajwt() : ajwt;\n        const fn = nkeyAuthenticator(seed);\n        const { nkey, sig } = fn(nonce);\n        return { jwt, nkey, sig };\n    };\n}\nexports.jwtAuthenticator = jwtAuthenticator;\n/**\n * Returns an Authenticator function that returns a JwtAuth.\n * This is a convenience Authenticator that parses the\n * specified creds and delegates to the jwtAuthenticator.\n * @param {Uint8Array | () => Uint8Array } creds - the contents of a creds file or a function that returns the creds\n * @returns {JwtAuth}\n */\nfunction credsAuthenticator(creds) {\n    const fn = typeof creds !== \"function\" ? () => creds : creds;\n    const parse = () => {\n        const CREDS = /\\s*(?:(?:[-]{3,}[^\\n]*[-]{3,}\\n)(.+)(?:\\n\\s*[-]{3,}[^\\n]*[-]{3,}\\n))/ig;\n        const s = encoders_1.TD.decode(fn());\n        // get the JWT\n        let m = CREDS.exec(s);\n        if (!m) {\n            throw core_1.NatsError.errorForCode(core_1.ErrorCode.BadCreds);\n        }\n        const jwt = m[1].trim();\n        // get the nkey\n        m = CREDS.exec(s);\n        if (!m) {\n            throw core_1.NatsError.errorForCode(core_1.ErrorCode.BadCreds);\n        }\n        if (!m) {\n            throw core_1.NatsError.errorForCode(core_1.ErrorCode.BadCreds);\n        }\n        const seed = encoders_1.TE.encode(m[1].trim());\n        return { jwt, seed };\n    };\n    const jwtFn = () => {\n        const { jwt } = parse();\n        return jwt;\n    };\n    const nkeyFn = () => {\n        const { seed } = parse();\n        return seed;\n    };\n    return jwtAuthenticator(jwtFn, nkeyFn);\n}\nexports.credsAuthenticator = credsAuthenticator;\n//# sourceMappingURL=authenticator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9hdXRoZW50aWNhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQixHQUFHLHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLHFDQUFxQyxHQUFHLGdCQUFnQixHQUFHLDBCQUEwQjtBQUN0TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQVM7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsOEVBQVk7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMsV0FBVyx3QkFBd0I7QUFDbkMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLCtCQUErQjtBQUMxQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBZ0M7QUFDM0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUcsVUFBVSxHQUFHLG1CQUFtQixHQUFHLFVBQVUsR0FBRztBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L2F1dGhlbnRpY2F0b3IuanM/ODU5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlZHNBdXRoZW50aWNhdG9yID0gZXhwb3J0cy5qd3RBdXRoZW50aWNhdG9yID0gZXhwb3J0cy5ua2V5QXV0aGVudGljYXRvciA9IGV4cG9ydHMudG9rZW5BdXRoZW50aWNhdG9yID0gZXhwb3J0cy51c2VybmFtZVBhc3N3b3JkQXV0aGVudGljYXRvciA9IGV4cG9ydHMubm9BdXRoRm4gPSBleHBvcnRzLm11bHRpQXV0aGVudGljYXRvciA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIzIFRoZSBOQVRTIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBua2V5c18xID0gcmVxdWlyZShcIi4vbmtleXNcIik7XG5jb25zdCBlbmNvZGVyc18xID0gcmVxdWlyZShcIi4vZW5jb2RlcnNcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuZnVuY3Rpb24gbXVsdGlBdXRoZW50aWNhdG9yKGF1dGhlbnRpY2F0b3JzKSB7XG4gICAgcmV0dXJuIChub25jZSkgPT4ge1xuICAgICAgICBsZXQgYXV0aCA9IHt9O1xuICAgICAgICBhdXRoZW50aWNhdG9ycy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gYShub25jZSkgfHwge307XG4gICAgICAgICAgICBhdXRoID0gT2JqZWN0LmFzc2lnbihhdXRoLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhdXRoO1xuICAgIH07XG59XG5leHBvcnRzLm11bHRpQXV0aGVudGljYXRvciA9IG11bHRpQXV0aGVudGljYXRvcjtcbmZ1bmN0aW9uIG5vQXV0aEZuKCkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufVxuZXhwb3J0cy5ub0F1dGhGbiA9IG5vQXV0aEZuO1xuLyoqXG4gKiBSZXR1cm5zIGEgdXNlci9wYXNzIGF1dGhlbnRpY2F0b3IgZm9yIHRoZSBzcGVjaWZpZWQgdXNlciBhbmQgb3B0aW9uYWwgcGFzc3dvcmRcbiAqIEBwYXJhbSB7IHN0cmluZyB8ICgpID0+IHN0cmluZyB9IHVzZXJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgKCkgPT4gc3RyaW5nIH0gcGFzc1xuICogQHJldHVybiB7VXNlclBhc3N9XG4gKi9cbmZ1bmN0aW9uIHVzZXJuYW1lUGFzc3dvcmRBdXRoZW50aWNhdG9yKHVzZXIsIHBhc3MpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCB1ID0gdHlwZW9mIHVzZXIgPT09IFwiZnVuY3Rpb25cIiA/IHVzZXIoKSA6IHVzZXI7XG4gICAgICAgIGNvbnN0IHAgPSB0eXBlb2YgcGFzcyA9PT0gXCJmdW5jdGlvblwiID8gcGFzcygpIDogcGFzcztcbiAgICAgICAgcmV0dXJuIHsgdXNlcjogdSwgcGFzczogcCB9O1xuICAgIH07XG59XG5leHBvcnRzLnVzZXJuYW1lUGFzc3dvcmRBdXRoZW50aWNhdG9yID0gdXNlcm5hbWVQYXNzd29yZEF1dGhlbnRpY2F0b3I7XG4vKipcbiAqIFJldHVybnMgYSB0b2tlbiBhdXRoZW50aWNhdG9yIGZvciB0aGUgc3BlY2lmaWVkIHRva2VuXG4gKiBAcGFyYW0geyBzdHJpbmcgfCAoKSA9PiBzdHJpbmcgfSB0b2tlblxuICogQHJldHVybiB7VG9rZW5BdXRofVxuICovXG5mdW5jdGlvbiB0b2tlbkF1dGhlbnRpY2F0b3IodG9rZW4pIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBhdXRoX3Rva2VuID0gdHlwZW9mIHRva2VuID09PSBcImZ1bmN0aW9uXCIgPyB0b2tlbigpIDogdG9rZW47XG4gICAgICAgIHJldHVybiB7IGF1dGhfdG9rZW4gfTtcbiAgICB9O1xufVxuZXhwb3J0cy50b2tlbkF1dGhlbnRpY2F0b3IgPSB0b2tlbkF1dGhlbnRpY2F0b3I7XG4vKipcbiAqIFJldHVybnMgYW4gQXV0aGVudGljYXRvciB0aGF0IHJldHVybnMgYSBOS2V5QXV0aCBiYXNlZCB0aGF0IHVzZXMgdGhlXG4gKiBzcGVjaWZpZWQgc2VlZCBvciBmdW5jdGlvbiByZXR1cm5pbmcgYSBzZWVkLlxuICogQHBhcmFtIHtVaW50OEFycmF5IHwgKCgpID0+IFVpbnQ4QXJyYXkpfSBzZWVkIC0gdGhlIG5rZXkgc2VlZFxuICogQHJldHVybiB7TktleUF1dGh9XG4gKi9cbmZ1bmN0aW9uIG5rZXlBdXRoZW50aWNhdG9yKHNlZWQpIHtcbiAgICByZXR1cm4gKG5vbmNlKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSB0eXBlb2Ygc2VlZCA9PT0gXCJmdW5jdGlvblwiID8gc2VlZCgpIDogc2VlZDtcbiAgICAgICAgY29uc3Qga3AgPSBzID8gbmtleXNfMS5ua2V5cy5mcm9tU2VlZChzKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgbmtleSA9IGtwID8ga3AuZ2V0UHVibGljS2V5KCkgOiBcIlwiO1xuICAgICAgICBjb25zdCBjaGFsbGVuZ2UgPSBlbmNvZGVyc18xLlRFLmVuY29kZShub25jZSB8fCBcIlwiKTtcbiAgICAgICAgY29uc3Qgc2lnQnl0ZXMgPSBrcCAhPT0gdW5kZWZpbmVkICYmIG5vbmNlID8ga3Auc2lnbihjaGFsbGVuZ2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWcgPSBzaWdCeXRlcyA/IG5rZXlzXzEubmtleXMuZW5jb2RlKHNpZ0J5dGVzKSA6IFwiXCI7XG4gICAgICAgIHJldHVybiB7IG5rZXksIHNpZyB9O1xuICAgIH07XG59XG5leHBvcnRzLm5rZXlBdXRoZW50aWNhdG9yID0gbmtleUF1dGhlbnRpY2F0b3I7XG4vKipcbiAqIFJldHVybnMgYW4gQXV0aGVudGljYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBKd3RBdXRoLlxuICogSWYgYSBzZWVkIGlzIHByb3ZpZGVkLCB0aGUgcHVibGljIGtleSwgYW5kIHNpZ25hdHVyZSBhcmVcbiAqIGNhbGN1bGF0ZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCAoKT0+c3RyaW5nfSBhand0IC0gdGhlIGp3dFxuICogQHBhcmFtIHtVaW50OEFycmF5IHwgKCk9PiBVaW50OEFycmF5IH0gc2VlZCAtIHRoZSBvcHRpb25hbCBua2V5IHNlZWRcbiAqIEByZXR1cm4ge0F1dGhlbnRpY2F0b3J9XG4gKi9cbmZ1bmN0aW9uIGp3dEF1dGhlbnRpY2F0b3IoYWp3dCwgc2VlZCkge1xuICAgIHJldHVybiAobm9uY2UpID0+IHtcbiAgICAgICAgY29uc3Qgand0ID0gdHlwZW9mIGFqd3QgPT09IFwiZnVuY3Rpb25cIiA/IGFqd3QoKSA6IGFqd3Q7XG4gICAgICAgIGNvbnN0IGZuID0gbmtleUF1dGhlbnRpY2F0b3Ioc2VlZCk7XG4gICAgICAgIGNvbnN0IHsgbmtleSwgc2lnIH0gPSBmbihub25jZSk7XG4gICAgICAgIHJldHVybiB7IGp3dCwgbmtleSwgc2lnIH07XG4gICAgfTtcbn1cbmV4cG9ydHMuand0QXV0aGVudGljYXRvciA9IGp3dEF1dGhlbnRpY2F0b3I7XG4vKipcbiAqIFJldHVybnMgYW4gQXV0aGVudGljYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBKd3RBdXRoLlxuICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIEF1dGhlbnRpY2F0b3IgdGhhdCBwYXJzZXMgdGhlXG4gKiBzcGVjaWZpZWQgY3JlZHMgYW5kIGRlbGVnYXRlcyB0byB0aGUgand0QXV0aGVudGljYXRvci5cbiAqIEBwYXJhbSB7VWludDhBcnJheSB8ICgpID0+IFVpbnQ4QXJyYXkgfSBjcmVkcyAtIHRoZSBjb250ZW50cyBvZiBhIGNyZWRzIGZpbGUgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyZWRzXG4gKiBAcmV0dXJucyB7Snd0QXV0aH1cbiAqL1xuZnVuY3Rpb24gY3JlZHNBdXRoZW50aWNhdG9yKGNyZWRzKSB7XG4gICAgY29uc3QgZm4gPSB0eXBlb2YgY3JlZHMgIT09IFwiZnVuY3Rpb25cIiA/ICgpID0+IGNyZWRzIDogY3JlZHM7XG4gICAgY29uc3QgcGFyc2UgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IENSRURTID0gL1xccyooPzooPzpbLV17Myx9W15cXG5dKlstXXszLH1cXG4pKC4rKSg/OlxcblxccypbLV17Myx9W15cXG5dKlstXXszLH1cXG4pKS9pZztcbiAgICAgICAgY29uc3QgcyA9IGVuY29kZXJzXzEuVEQuZGVjb2RlKGZuKCkpO1xuICAgICAgICAvLyBnZXQgdGhlIEpXVFxuICAgICAgICBsZXQgbSA9IENSRURTLmV4ZWMocyk7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgdGhyb3cgY29yZV8xLk5hdHNFcnJvci5lcnJvckZvckNvZGUoY29yZV8xLkVycm9yQ29kZS5CYWRDcmVkcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgand0ID0gbVsxXS50cmltKCk7XG4gICAgICAgIC8vIGdldCB0aGUgbmtleVxuICAgICAgICBtID0gQ1JFRFMuZXhlYyhzKTtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICB0aHJvdyBjb3JlXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLkJhZENyZWRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHRocm93IGNvcmVfMS5OYXRzRXJyb3IuZXJyb3JGb3JDb2RlKGNvcmVfMS5FcnJvckNvZGUuQmFkQ3JlZHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSBlbmNvZGVyc18xLlRFLmVuY29kZShtWzFdLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB7IGp3dCwgc2VlZCB9O1xuICAgIH07XG4gICAgY29uc3Qgand0Rm4gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgand0IH0gPSBwYXJzZSgpO1xuICAgICAgICByZXR1cm4gand0O1xuICAgIH07XG4gICAgY29uc3QgbmtleUZuID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNlZWQgfSA9IHBhcnNlKCk7XG4gICAgICAgIHJldHVybiBzZWVkO1xuICAgIH07XG4gICAgcmV0dXJuIGp3dEF1dGhlbnRpY2F0b3Ioand0Rm4sIG5rZXlGbik7XG59XG5leHBvcnRzLmNyZWRzQXV0aGVudGljYXRvciA9IGNyZWRzQXV0aGVudGljYXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF1dGhlbnRpY2F0b3IuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/authenticator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/base64.js":
/*!**********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/base64.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Base64UrlPaddedCodec = exports.Base64UrlCodec = exports.Base64Codec = void 0;\nclass Base64Codec {\n    static encode(bytes) {\n        if (typeof bytes === \"string\") {\n            return btoa(bytes);\n        }\n        const a = Array.from(bytes);\n        return btoa(String.fromCharCode(...a));\n    }\n    static decode(s, binary = false) {\n        const bin = atob(s);\n        if (!binary) {\n            return bin;\n        }\n        return Uint8Array.from(bin, (c) => c.charCodeAt(0));\n    }\n}\nexports.Base64Codec = Base64Codec;\nclass Base64UrlCodec {\n    static encode(bytes) {\n        return Base64UrlCodec.toB64URLEncoding(Base64Codec.encode(bytes));\n    }\n    static decode(s, binary = false) {\n        return Base64Codec.decode(Base64UrlCodec.fromB64URLEncoding(s), binary);\n    }\n    static toB64URLEncoding(b64str) {\n        return b64str\n            .replace(/=/g, \"\")\n            .replace(/\\+/g, \"-\")\n            .replace(/\\//g, \"_\");\n    }\n    static fromB64URLEncoding(b64str) {\n        // pads are % 4, but not necessary on decoding\n        return b64str\n            .replace(/_/g, \"/\")\n            .replace(/-/g, \"+\");\n    }\n}\nexports.Base64UrlCodec = Base64UrlCodec;\nclass Base64UrlPaddedCodec {\n    static encode(bytes) {\n        return Base64UrlPaddedCodec.toB64URLEncoding(Base64Codec.encode(bytes));\n    }\n    static decode(s, binary = false) {\n        return Base64UrlPaddedCodec.decode(Base64UrlPaddedCodec.fromB64URLEncoding(s), binary);\n    }\n    static toB64URLEncoding(b64str) {\n        return b64str\n            .replace(/\\+/g, \"-\")\n            .replace(/\\//g, \"_\");\n    }\n    static fromB64URLEncoding(b64str) {\n        // pads are % 4, but not necessary on decoding\n        return b64str\n            .replace(/_/g, \"/\")\n            .replace(/-/g, \"+\");\n    }\n}\nexports.Base64UrlPaddedCodec = Base64UrlPaddedCodec;\n//# sourceMappingURL=base64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9iYXNlNjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsc0JBQXNCLEdBQUcsbUJBQW1CO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L2Jhc2U2NC5qcz9kOWU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlNjRVcmxQYWRkZWRDb2RlYyA9IGV4cG9ydHMuQmFzZTY0VXJsQ29kZWMgPSBleHBvcnRzLkJhc2U2NENvZGVjID0gdm9pZCAwO1xuY2xhc3MgQmFzZTY0Q29kZWMge1xuICAgIHN0YXRpYyBlbmNvZGUoYnl0ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGJ0b2EoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGEgPSBBcnJheS5mcm9tKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5hKSk7XG4gICAgfVxuICAgIHN0YXRpYyBkZWNvZGUocywgYmluYXJ5ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYmluID0gYXRvYihzKTtcbiAgICAgICAgaWYgKCFiaW5hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShiaW4sIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZTY0Q29kZWMgPSBCYXNlNjRDb2RlYztcbmNsYXNzIEJhc2U2NFVybENvZGVjIHtcbiAgICBzdGF0aWMgZW5jb2RlKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBCYXNlNjRVcmxDb2RlYy50b0I2NFVSTEVuY29kaW5nKEJhc2U2NENvZGVjLmVuY29kZShieXRlcykpO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlKHMsIGJpbmFyeSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBCYXNlNjRDb2RlYy5kZWNvZGUoQmFzZTY0VXJsQ29kZWMuZnJvbUI2NFVSTEVuY29kaW5nKHMpLCBiaW5hcnkpO1xuICAgIH1cbiAgICBzdGF0aWMgdG9CNjRVUkxFbmNvZGluZyhiNjRzdHIpIHtcbiAgICAgICAgcmV0dXJuIGI2NHN0clxuICAgICAgICAgICAgLnJlcGxhY2UoLz0vZywgXCJcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgXCItXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvL2csIFwiX1wiKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CNjRVUkxFbmNvZGluZyhiNjRzdHIpIHtcbiAgICAgICAgLy8gcGFkcyBhcmUgJSA0LCBidXQgbm90IG5lY2Vzc2FyeSBvbiBkZWNvZGluZ1xuICAgICAgICByZXR1cm4gYjY0c3RyXG4gICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8tL2csIFwiK1wiKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2U2NFVybENvZGVjID0gQmFzZTY0VXJsQ29kZWM7XG5jbGFzcyBCYXNlNjRVcmxQYWRkZWRDb2RlYyB7XG4gICAgc3RhdGljIGVuY29kZShieXRlcykge1xuICAgICAgICByZXR1cm4gQmFzZTY0VXJsUGFkZGVkQ29kZWMudG9CNjRVUkxFbmNvZGluZyhCYXNlNjRDb2RlYy5lbmNvZGUoYnl0ZXMpKTtcbiAgICB9XG4gICAgc3RhdGljIGRlY29kZShzLCBiaW5hcnkgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gQmFzZTY0VXJsUGFkZGVkQ29kZWMuZGVjb2RlKEJhc2U2NFVybFBhZGRlZENvZGVjLmZyb21CNjRVUkxFbmNvZGluZyhzKSwgYmluYXJ5KTtcbiAgICB9XG4gICAgc3RhdGljIHRvQjY0VVJMRW5jb2RpbmcoYjY0c3RyKSB7XG4gICAgICAgIHJldHVybiBiNjRzdHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgXCItXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvL2csIFwiX1wiKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CNjRVUkxFbmNvZGluZyhiNjRzdHIpIHtcbiAgICAgICAgLy8gcGFkcyBhcmUgJSA0LCBidXQgbm90IG5lY2Vzc2FyeSBvbiBkZWNvZGluZ1xuICAgICAgICByZXR1cm4gYjY0c3RyXG4gICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC8tL2csIFwiK1wiKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2U2NFVybFBhZGRlZENvZGVjID0gQmFzZTY0VXJsUGFkZGVkQ29kZWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlNjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/base64.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/bench.js":
/*!*********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/bench.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2020-2022 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.humanizeBytes = exports.msgThroughput = exports.throughput = exports.Bench = exports.Metric = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/nats/lib/nats-base-client/types.js\");\nconst nuid_1 = __webpack_require__(/*! ./nuid */ \"(rsc)/./node_modules/nats/lib/nats-base-client/nuid.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nclass Metric {\n    constructor(name, duration) {\n        this.name = name;\n        this.duration = duration;\n        this.date = Date.now();\n        this.payload = 0;\n        this.msgs = 0;\n        this.bytes = 0;\n    }\n    toString() {\n        const sec = (this.duration) / 1000;\n        const mps = Math.round(this.msgs / sec);\n        const label = this.asyncRequests ? \"asyncRequests\" : \"\";\n        let minmax = \"\";\n        if (this.max) {\n            minmax = `${this.min}/${this.max}`;\n        }\n        return `${this.name}${label ? \" [asyncRequests]\" : \"\"} ${humanizeNumber(mps)} msgs/sec - [${sec.toFixed(2)} secs] ~ ${throughput(this.bytes, sec)} ${minmax}`;\n    }\n    toCsv() {\n        return `\"${this.name}\",${new Date(this.date).toISOString()},${this.lang},${this.version},${this.msgs},${this.payload},${this.bytes},${this.duration},${this.asyncRequests ? this.asyncRequests : false}\\n`;\n    }\n    static header() {\n        return `Test,Date,Lang,Version,Count,MsgPayload,Bytes,Millis,Async\\n`;\n    }\n}\nexports.Metric = Metric;\nclass Bench {\n    constructor(nc, opts = {\n        msgs: 100000,\n        size: 128,\n        subject: \"\",\n        asyncRequests: false,\n        pub: false,\n        sub: false,\n        req: false,\n        rep: false,\n    }) {\n        this.nc = nc;\n        this.callbacks = opts.callbacks || false;\n        this.msgs = opts.msgs || 0;\n        this.size = opts.size || 0;\n        this.subject = opts.subject || nuid_1.nuid.next();\n        this.asyncRequests = opts.asyncRequests || false;\n        this.pub = opts.pub || false;\n        this.sub = opts.sub || false;\n        this.req = opts.req || false;\n        this.rep = opts.rep || false;\n        this.perf = new util_1.Perf();\n        this.payload = this.size ? new Uint8Array(this.size) : types_1.Empty;\n        if (!this.pub && !this.sub && !this.req && !this.rep) {\n            throw new Error(\"no bench option selected\");\n        }\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.nc.closed()\n                .then((err) => {\n                if (err) {\n                    throw new core_1.NatsError(`bench closed with an error: ${err.message}`, core_1.ErrorCode.Unknown, err);\n                }\n            });\n            if (this.callbacks) {\n                yield this.runCallbacks();\n            }\n            else {\n                yield this.runAsync();\n            }\n            return this.processMetrics();\n        });\n    }\n    processMetrics() {\n        const nc = this.nc;\n        const { lang, version } = nc.protocol.transport;\n        if (this.pub && this.sub) {\n            this.perf.measure(\"pubsub\", \"pubStart\", \"subStop\");\n        }\n        if (this.req && this.rep) {\n            this.perf.measure(\"reqrep\", \"reqStart\", \"reqStop\");\n        }\n        const measures = this.perf.getEntries();\n        const pubsub = measures.find((m) => m.name === \"pubsub\");\n        const reqrep = measures.find((m) => m.name === \"reqrep\");\n        const req = measures.find((m) => m.name === \"req\");\n        const rep = measures.find((m) => m.name === \"rep\");\n        const pub = measures.find((m) => m.name === \"pub\");\n        const sub = measures.find((m) => m.name === \"sub\");\n        const stats = this.nc.stats();\n        const metrics = [];\n        if (pubsub) {\n            const { name, duration } = pubsub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs * 2;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (reqrep) {\n            const { name, duration } = reqrep;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs * 2;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (pub) {\n            const { name, duration } = pub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (sub) {\n            const { name, duration } = sub;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (rep) {\n            const { name, duration } = rep;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        if (req) {\n            const { name, duration } = req;\n            const m = new Metric(name, duration);\n            m.msgs = this.msgs;\n            m.bytes = stats.inBytes + stats.outBytes;\n            m.lang = lang;\n            m.version = version;\n            m.payload = this.payload.length;\n            metrics.push(m);\n        }\n        return metrics;\n    }\n    runCallbacks() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const jobs = [];\n            if (this.sub) {\n                const d = (0, util_1.deferred)();\n                jobs.push(d);\n                let i = 0;\n                this.nc.subscribe(this.subject, {\n                    max: this.msgs,\n                    callback: () => {\n                        i++;\n                        if (i === 1) {\n                            this.perf.mark(\"subStart\");\n                        }\n                        if (i === this.msgs) {\n                            this.perf.mark(\"subStop\");\n                            this.perf.measure(\"sub\", \"subStart\", \"subStop\");\n                            d.resolve();\n                        }\n                    },\n                });\n            }\n            if (this.rep) {\n                const d = (0, util_1.deferred)();\n                jobs.push(d);\n                let i = 0;\n                this.nc.subscribe(this.subject, {\n                    max: this.msgs,\n                    callback: (_, m) => {\n                        m.respond(this.payload);\n                        i++;\n                        if (i === 1) {\n                            this.perf.mark(\"repStart\");\n                        }\n                        if (i === this.msgs) {\n                            this.perf.mark(\"repStop\");\n                            this.perf.measure(\"rep\", \"repStart\", \"repStop\");\n                            d.resolve();\n                        }\n                    },\n                });\n            }\n            if (this.pub) {\n                const job = (() => __awaiter(this, void 0, void 0, function* () {\n                    this.perf.mark(\"pubStart\");\n                    for (let i = 0; i < this.msgs; i++) {\n                        this.nc.publish(this.subject, this.payload);\n                    }\n                    yield this.nc.flush();\n                    this.perf.mark(\"pubStop\");\n                    this.perf.measure(\"pub\", \"pubStart\", \"pubStop\");\n                }))();\n                jobs.push(job);\n            }\n            if (this.req) {\n                const job = (() => __awaiter(this, void 0, void 0, function* () {\n                    if (this.asyncRequests) {\n                        this.perf.mark(\"reqStart\");\n                        const a = [];\n                        for (let i = 0; i < this.msgs; i++) {\n                            a.push(this.nc.request(this.subject, this.payload, { timeout: 20000 }));\n                        }\n                        yield Promise.all(a);\n                        this.perf.mark(\"reqStop\");\n                        this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                    }\n                    else {\n                        this.perf.mark(\"reqStart\");\n                        for (let i = 0; i < this.msgs; i++) {\n                            yield this.nc.request(this.subject);\n                        }\n                        this.perf.mark(\"reqStop\");\n                        this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                    }\n                }))();\n                jobs.push(job);\n            }\n            yield Promise.all(jobs);\n        });\n    }\n    runAsync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const jobs = [];\n            if (this.rep) {\n                let first = false;\n                const sub = this.nc.subscribe(this.subject, { max: this.msgs });\n                const job = (() => __awaiter(this, void 0, void 0, function* () {\n                    var _a, e_1, _b, _c;\n                    try {\n                        for (var _d = true, sub_1 = __asyncValues(sub), sub_1_1; sub_1_1 = yield sub_1.next(), _a = sub_1_1.done, !_a; _d = true) {\n                            _c = sub_1_1.value;\n                            _d = false;\n                            const m = _c;\n                            if (!first) {\n                                this.perf.mark(\"repStart\");\n                                first = true;\n                            }\n                            m.respond(this.payload);\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (!_d && !_a && (_b = sub_1.return)) yield _b.call(sub_1);\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                    yield this.nc.flush();\n                    this.perf.mark(\"repStop\");\n                    this.perf.measure(\"rep\", \"repStart\", \"repStop\");\n                }))();\n                jobs.push(job);\n            }\n            if (this.sub) {\n                let first = false;\n                const sub = this.nc.subscribe(this.subject, { max: this.msgs });\n                const job = (() => __awaiter(this, void 0, void 0, function* () {\n                    var _e, e_2, _f, _g;\n                    try {\n                        for (var _h = true, sub_2 = __asyncValues(sub), sub_2_1; sub_2_1 = yield sub_2.next(), _e = sub_2_1.done, !_e; _h = true) {\n                            _g = sub_2_1.value;\n                            _h = false;\n                            const _m = _g;\n                            if (!first) {\n                                this.perf.mark(\"subStart\");\n                                first = true;\n                            }\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (!_h && !_e && (_f = sub_2.return)) yield _f.call(sub_2);\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                    this.perf.mark(\"subStop\");\n                    this.perf.measure(\"sub\", \"subStart\", \"subStop\");\n                }))();\n                jobs.push(job);\n            }\n            if (this.pub) {\n                const job = (() => __awaiter(this, void 0, void 0, function* () {\n                    this.perf.mark(\"pubStart\");\n                    for (let i = 0; i < this.msgs; i++) {\n                        this.nc.publish(this.subject, this.payload);\n                    }\n                    yield this.nc.flush();\n                    this.perf.mark(\"pubStop\");\n                    this.perf.measure(\"pub\", \"pubStart\", \"pubStop\");\n                }))();\n                jobs.push(job);\n            }\n            if (this.req) {\n                const job = (() => __awaiter(this, void 0, void 0, function* () {\n                    if (this.asyncRequests) {\n                        this.perf.mark(\"reqStart\");\n                        const a = [];\n                        for (let i = 0; i < this.msgs; i++) {\n                            a.push(this.nc.request(this.subject, this.payload, { timeout: 20000 }));\n                        }\n                        yield Promise.all(a);\n                        this.perf.mark(\"reqStop\");\n                        this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                    }\n                    else {\n                        this.perf.mark(\"reqStart\");\n                        for (let i = 0; i < this.msgs; i++) {\n                            yield this.nc.request(this.subject);\n                        }\n                        this.perf.mark(\"reqStop\");\n                        this.perf.measure(\"req\", \"reqStart\", \"reqStop\");\n                    }\n                }))();\n                jobs.push(job);\n            }\n            yield Promise.all(jobs);\n        });\n    }\n}\nexports.Bench = Bench;\nfunction throughput(bytes, seconds) {\n    return `${humanizeBytes(bytes / seconds)}/sec`;\n}\nexports.throughput = throughput;\nfunction msgThroughput(msgs, seconds) {\n    return `${(Math.floor(msgs / seconds))} msgs/sec`;\n}\nexports.msgThroughput = msgThroughput;\nfunction humanizeBytes(bytes, si = false) {\n    const base = si ? 1000 : 1024;\n    const pre = si\n        ? [\"k\", \"M\", \"G\", \"T\", \"P\", \"E\"]\n        : [\"K\", \"M\", \"G\", \"T\", \"P\", \"E\"];\n    const post = si ? \"iB\" : \"B\";\n    if (bytes < base) {\n        return `${bytes.toFixed(2)} ${post}`;\n    }\n    const exp = parseInt(Math.log(bytes) / Math.log(base) + \"\");\n    const index = parseInt((exp - 1) + \"\");\n    return `${(bytes / Math.pow(base, exp)).toFixed(2)} ${pre[index]}${post}`;\n}\nexports.humanizeBytes = humanizeBytes;\nfunction humanizeNumber(n) {\n    return n.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n}\n//# sourceMappingURL=bench.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9iZW5jaC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCLEdBQUcscUJBQXFCLEdBQUcsa0JBQWtCLEdBQUcsYUFBYSxHQUFHLGNBQWM7QUFDbkcsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQVM7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxzRUFBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMsc0VBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVMsR0FBRyxTQUFTO0FBQzdDO0FBQ0Esa0JBQWtCLFVBQVUsRUFBRSxpQ0FBaUMsRUFBRSxxQkFBcUIsY0FBYyxnQkFBZ0IsVUFBVSw2QkFBNkIsRUFBRSxPQUFPO0FBQ3BLO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVSxJQUFJLGtDQUFrQyxHQUFHLFVBQVUsR0FBRyxhQUFhLEdBQUcsVUFBVSxHQUFHLGFBQWEsR0FBRyxXQUFXLEdBQUcsY0FBYyxHQUFHLGdE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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RCxpRkFBaUYsZ0JBQWdCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWMsK0JBQStCO0FBQzdDO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsY0FBYyw4QkFBOEI7QUFDNUM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCLEVBQUUsS0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQSxjQUFjLDBDQUEwQyxFQUFFLFdBQVcsRUFBRSxLQUFLO0FBQzVFO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsMENBQTBDLEVBQUU7QUFDNUM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL25hdHMtYmFzZS1jbGllbnQvYmVuY2guanM/Zjg4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIyIFRoZSBOQVRTIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2FzeW5jVmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jVmFsdWVzKSB8fCBmdW5jdGlvbiAobykge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmh1bWFuaXplQnl0ZXMgPSBleHBvcnRzLm1zZ1Rocm91Z2hwdXQgPSBleHBvcnRzLnRocm91Z2hwdXQgPSBleHBvcnRzLkJlbmNoID0gZXhwb3J0cy5NZXRyaWMgPSB2b2lkIDA7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBudWlkXzEgPSByZXF1aXJlKFwiLi9udWlkXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jbGFzcyBNZXRyaWMge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGR1cmF0aW9uKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgdGhpcy5kYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5wYXlsb2FkID0gMDtcbiAgICAgICAgdGhpcy5tc2dzID0gMDtcbiAgICAgICAgdGhpcy5ieXRlcyA9IDA7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBzZWMgPSAodGhpcy5kdXJhdGlvbikgLyAxMDAwO1xuICAgICAgICBjb25zdCBtcHMgPSBNYXRoLnJvdW5kKHRoaXMubXNncyAvIHNlYyk7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5hc3luY1JlcXVlc3RzID8gXCJhc3luY1JlcXVlc3RzXCIgOiBcIlwiO1xuICAgICAgICBsZXQgbWlubWF4ID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMubWF4KSB7XG4gICAgICAgICAgICBtaW5tYXggPSBgJHt0aGlzLm1pbn0vJHt0aGlzLm1heH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9JHtsYWJlbCA/IFwiIFthc3luY1JlcXVlc3RzXVwiIDogXCJcIn0gJHtodW1hbml6ZU51bWJlcihtcHMpfSBtc2dzL3NlYyAtIFske3NlYy50b0ZpeGVkKDIpfSBzZWNzXSB+ICR7dGhyb3VnaHB1dCh0aGlzLmJ5dGVzLCBzZWMpfSAke21pbm1heH1gO1xuICAgIH1cbiAgICB0b0NzdigpIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7dGhpcy5uYW1lfVwiLCR7bmV3IERhdGUodGhpcy5kYXRlKS50b0lTT1N0cmluZygpfSwke3RoaXMubGFuZ30sJHt0aGlzLnZlcnNpb259LCR7dGhpcy5tc2dzfSwke3RoaXMucGF5bG9hZH0sJHt0aGlzLmJ5dGVzfSwke3RoaXMuZHVyYXRpb259LCR7dGhpcy5hc3luY1JlcXVlc3RzID8gdGhpcy5hc3luY1JlcXVlc3RzIDogZmFsc2V9XFxuYDtcbiAgICB9XG4gICAgc3RhdGljIGhlYWRlcigpIHtcbiAgICAgICAgcmV0dXJuIGBUZXN0LERhdGUsTGFuZyxWZXJzaW9uLENvdW50LE1zZ1BheWxvYWQsQnl0ZXMsTWlsbGlzLEFzeW5jXFxuYDtcbiAgICB9XG59XG5leHBvcnRzLk1ldHJpYyA9IE1ldHJpYztcbmNsYXNzIEJlbmNoIHtcbiAgICBjb25zdHJ1Y3RvcihuYywgb3B0cyA9IHtcbiAgICAgICAgbXNnczogMTAwMDAwLFxuICAgICAgICBzaXplOiAxMjgsXG4gICAgICAgIHN1YmplY3Q6IFwiXCIsXG4gICAgICAgIGFzeW5jUmVxdWVzdHM6IGZhbHNlLFxuICAgICAgICBwdWI6IGZhbHNlLFxuICAgICAgICBzdWI6IGZhbHNlLFxuICAgICAgICByZXE6IGZhbHNlLFxuICAgICAgICByZXA6IGZhbHNlLFxuICAgIH0pIHtcbiAgICAgICAgdGhpcy5uYyA9IG5jO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IG9wdHMuY2FsbGJhY2tzIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLm1zZ3MgPSBvcHRzLm1zZ3MgfHwgMDtcbiAgICAgICAgdGhpcy5zaXplID0gb3B0cy5zaXplIHx8IDA7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IG9wdHMuc3ViamVjdCB8fCBudWlkXzEubnVpZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuYXN5bmNSZXF1ZXN0cyA9IG9wdHMuYXN5bmNSZXF1ZXN0cyB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5wdWIgPSBvcHRzLnB1YiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWIgPSBvcHRzLnN1YiB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXEgPSBvcHRzLnJlcSB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXAgPSBvcHRzLnJlcCB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5wZXJmID0gbmV3IHV0aWxfMS5QZXJmKCk7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IHRoaXMuc2l6ZSA/IG5ldyBVaW50OEFycmF5KHRoaXMuc2l6ZSkgOiB0eXBlc18xLkVtcHR5O1xuICAgICAgICBpZiAoIXRoaXMucHViICYmICF0aGlzLnN1YiAmJiAhdGhpcy5yZXEgJiYgIXRoaXMucmVwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBiZW5jaCBvcHRpb24gc2VsZWN0ZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcnVuKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5uYy5jbG9zZWQoKVxuICAgICAgICAgICAgICAgIC50aGVuKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlXzEuTmF0c0Vycm9yKGBiZW5jaCBjbG9zZWQgd2l0aCBhbiBlcnJvcjogJHtlcnIubWVzc2FnZX1gLCBjb3JlXzEuRXJyb3JDb2RlLlVua25vd24sIGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFja3MpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnJ1bkNhbGxiYWNrcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5ydW5Bc3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc01ldHJpY3MoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb2Nlc3NNZXRyaWNzKCkge1xuICAgICAgICBjb25zdCBuYyA9IHRoaXMubmM7XG4gICAgICAgIGNvbnN0IHsgbGFuZywgdmVyc2lvbiB9ID0gbmMucHJvdG9jb2wudHJhbnNwb3J0O1xuICAgICAgICBpZiAodGhpcy5wdWIgJiYgdGhpcy5zdWIpIHtcbiAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicHVic3ViXCIsIFwicHViU3RhcnRcIiwgXCJzdWJTdG9wXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcSAmJiB0aGlzLnJlcCkge1xuICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJyZXFyZXBcIiwgXCJyZXFTdGFydFwiLCBcInJlcVN0b3BcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVhc3VyZXMgPSB0aGlzLnBlcmYuZ2V0RW50cmllcygpO1xuICAgICAgICBjb25zdCBwdWJzdWIgPSBtZWFzdXJlcy5maW5kKChtKSA9PiBtLm5hbWUgPT09IFwicHVic3ViXCIpO1xuICAgICAgICBjb25zdCByZXFyZXAgPSBtZWFzdXJlcy5maW5kKChtKSA9PiBtLm5hbWUgPT09IFwicmVxcmVwXCIpO1xuICAgICAgICBjb25zdCByZXEgPSBtZWFzdXJlcy5maW5kKChtKSA9PiBtLm5hbWUgPT09IFwicmVxXCIpO1xuICAgICAgICBjb25zdCByZXAgPSBtZWFzdXJlcy5maW5kKChtKSA9PiBtLm5hbWUgPT09IFwicmVwXCIpO1xuICAgICAgICBjb25zdCBwdWIgPSBtZWFzdXJlcy5maW5kKChtKSA9PiBtLm5hbWUgPT09IFwicHViXCIpO1xuICAgICAgICBjb25zdCBzdWIgPSBtZWFzdXJlcy5maW5kKChtKSA9PiBtLm5hbWUgPT09IFwic3ViXCIpO1xuICAgICAgICBjb25zdCBzdGF0cyA9IHRoaXMubmMuc3RhdHMoKTtcbiAgICAgICAgY29uc3QgbWV0cmljcyA9IFtdO1xuICAgICAgICBpZiAocHVic3ViKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGR1cmF0aW9uIH0gPSBwdWJzdWI7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IE1ldHJpYyhuYW1lLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBtLm1zZ3MgPSB0aGlzLm1zZ3MgKiAyO1xuICAgICAgICAgICAgbS5ieXRlcyA9IHN0YXRzLmluQnl0ZXMgKyBzdGF0cy5vdXRCeXRlcztcbiAgICAgICAgICAgIG0ubGFuZyA9IGxhbmc7XG4gICAgICAgICAgICBtLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgbS5wYXlsb2FkID0gdGhpcy5wYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgIG1ldHJpY3MucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxcmVwKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGR1cmF0aW9uIH0gPSByZXFyZXA7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IE1ldHJpYyhuYW1lLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBtLm1zZ3MgPSB0aGlzLm1zZ3MgKiAyO1xuICAgICAgICAgICAgbS5ieXRlcyA9IHN0YXRzLmluQnl0ZXMgKyBzdGF0cy5vdXRCeXRlcztcbiAgICAgICAgICAgIG0ubGFuZyA9IGxhbmc7XG4gICAgICAgICAgICBtLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgbS5wYXlsb2FkID0gdGhpcy5wYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgIG1ldHJpY3MucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHViKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGR1cmF0aW9uIH0gPSBwdWI7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IE1ldHJpYyhuYW1lLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBtLm1zZ3MgPSB0aGlzLm1zZ3M7XG4gICAgICAgICAgICBtLmJ5dGVzID0gc3RhdHMub3V0Qnl0ZXM7XG4gICAgICAgICAgICBtLmxhbmcgPSBsYW5nO1xuICAgICAgICAgICAgbS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIG0ucGF5bG9hZCA9IHRoaXMucGF5bG9hZC5sZW5ndGg7XG4gICAgICAgICAgICBtZXRyaWNzLnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBkdXJhdGlvbiB9ID0gc3ViO1xuICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNZXRyaWMobmFtZSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgbS5tc2dzID0gdGhpcy5tc2dzO1xuICAgICAgICAgICAgbS5ieXRlcyA9IHN0YXRzLmluQnl0ZXM7XG4gICAgICAgICAgICBtLmxhbmcgPSBsYW5nO1xuICAgICAgICAgICAgbS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgIG0ucGF5bG9hZCA9IHRoaXMucGF5bG9hZC5sZW5ndGg7XG4gICAgICAgICAgICBtZXRyaWNzLnB1c2gobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcCkge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBkdXJhdGlvbiB9ID0gcmVwO1xuICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNZXRyaWMobmFtZSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgbS5tc2dzID0gdGhpcy5tc2dzO1xuICAgICAgICAgICAgbS5ieXRlcyA9IHN0YXRzLmluQnl0ZXMgKyBzdGF0cy5vdXRCeXRlcztcbiAgICAgICAgICAgIG0ubGFuZyA9IGxhbmc7XG4gICAgICAgICAgICBtLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgbS5wYXlsb2FkID0gdGhpcy5wYXlsb2FkLmxlbmd0aDtcbiAgICAgICAgICAgIG1ldHJpY3MucHVzaChtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIGR1cmF0aW9uIH0gPSByZXE7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IE1ldHJpYyhuYW1lLCBkdXJhdGlvbik7XG4gICAgICAgICAgICBtLm1zZ3MgPSB0aGlzLm1zZ3M7XG4gICAgICAgICAgICBtLmJ5dGVzID0gc3RhdHMuaW5CeXRlcyArIHN0YXRzLm91dEJ5dGVzO1xuICAgICAgICAgICAgbS5sYW5nID0gbGFuZztcbiAgICAgICAgICAgIG0udmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICBtLnBheWxvYWQgPSB0aGlzLnBheWxvYWQubGVuZ3RoO1xuICAgICAgICAgICAgbWV0cmljcy5wdXNoKG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRyaWNzO1xuICAgIH1cbiAgICBydW5DYWxsYmFja3MoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBqb2JzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5zdWIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gKDAsIHV0aWxfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgICAgICAgICBqb2JzLnB1c2goZCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMubmMuc3Vic2NyaWJlKHRoaXMuc3ViamVjdCwge1xuICAgICAgICAgICAgICAgICAgICBtYXg6IHRoaXMubXNncyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJzdWJTdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSB0aGlzLm1zZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInN1YlN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJzdWJcIiwgXCJzdWJTdGFydFwiLCBcInN1YlN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yZXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gKDAsIHV0aWxfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgICAgICAgICBqb2JzLnB1c2goZCk7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMubmMuc3Vic2NyaWJlKHRoaXMuc3ViamVjdCwge1xuICAgICAgICAgICAgICAgICAgICBtYXg6IHRoaXMubXNncyxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IChfLCBtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtLnJlc3BvbmQodGhpcy5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJyZXBTdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09PSB0aGlzLm1zZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcFN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJyZXBcIiwgXCJyZXBTdGFydFwiLCBcInJlcFN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wdWIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2IgPSAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInB1YlN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubXNnczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5jLnB1Ymxpc2godGhpcy5zdWJqZWN0LCB0aGlzLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMubmMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJwdWJTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInB1YlwiLCBcInB1YlN0YXJ0XCIsIFwicHViU3RvcFwiKTtcbiAgICAgICAgICAgICAgICB9KSkoKTtcbiAgICAgICAgICAgICAgICBqb2JzLnB1c2goam9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJlcSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvYiA9ICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFzeW5jUmVxdWVzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubXNnczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHRoaXMubmMucmVxdWVzdCh0aGlzLnN1YmplY3QsIHRoaXMucGF5bG9hZCwgeyB0aW1lb3V0OiAyMDAwMCB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicmVxXCIsIFwicmVxU3RhcnRcIiwgXCJyZXFTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJyZXFTdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tc2dzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLm5jLnJlcXVlc3QodGhpcy5zdWJqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwicmVxXCIsIFwicmVxU3RhcnRcIiwgXCJyZXFTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpKCk7XG4gICAgICAgICAgICAgICAgam9icy5wdXNoKGpvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChqb2JzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJ1bkFzeW5jKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgam9icyA9IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gdGhpcy5uYy5zdWJzY3JpYmUodGhpcy5zdWJqZWN0LCB7IG1heDogdGhpcy5tc2dzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGpvYiA9ICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIHN1Yl8xID0gX19hc3luY1ZhbHVlcyhzdWIpLCBzdWJfMV8xOyBzdWJfMV8xID0geWllbGQgc3ViXzEubmV4dCgpLCBfYSA9IHN1Yl8xXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IHN1Yl8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcFN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0ucmVzcG9uZCh0aGlzLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBzdWJfMS5yZXR1cm4pKSB5aWVsZCBfYi5jYWxsKHN1Yl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLm5jLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVwU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJyZXBcIiwgXCJyZXBTdGFydFwiLCBcInJlcFN0b3BcIik7XG4gICAgICAgICAgICAgICAgfSkpKCk7XG4gICAgICAgICAgICAgICAgam9icy5wdXNoKGpvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdWIpIHtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWIgPSB0aGlzLm5jLnN1YnNjcmliZSh0aGlzLnN1YmplY3QsIHsgbWF4OiB0aGlzLm1zZ3MgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9iID0gKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9lLCBlXzIsIF9mLCBfZztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9oID0gdHJ1ZSwgc3ViXzIgPSBfX2FzeW5jVmFsdWVzKHN1YiksIHN1Yl8yXzE7IHN1Yl8yXzEgPSB5aWVsZCBzdWJfMi5uZXh0KCksIF9lID0gc3ViXzJfMS5kb25lLCAhX2U7IF9oID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9nID0gc3ViXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9tID0gX2c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInN1YlN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9oICYmICFfZSAmJiAoX2YgPSBzdWJfMi5yZXR1cm4pKSB5aWVsZCBfZi5jYWxsKHN1Yl8yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInN1YlN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tZWFzdXJlKFwic3ViXCIsIFwic3ViU3RhcnRcIiwgXCJzdWJTdG9wXCIpO1xuICAgICAgICAgICAgICAgIH0pKSgpO1xuICAgICAgICAgICAgICAgIGpvYnMucHVzaChqb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucHViKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9iID0gKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1hcmsoXCJwdWJTdGFydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1zZ3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYy5wdWJsaXNoKHRoaXMuc3ViamVjdCwgdGhpcy5wYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLm5jLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicHViU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmLm1lYXN1cmUoXCJwdWJcIiwgXCJwdWJTdGFydFwiLCBcInB1YlN0b3BcIik7XG4gICAgICAgICAgICAgICAgfSkpKCk7XG4gICAgICAgICAgICAgICAgam9icy5wdXNoKGpvYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yZXEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqb2IgPSAoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hc3luY1JlcXVlc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcVN0YXJ0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1zZ3M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaCh0aGlzLm5jLnJlcXVlc3QodGhpcy5zdWJqZWN0LCB0aGlzLnBheWxvYWQsIHsgdGltZW91dDogMjAwMDAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInJlcVwiLCBcInJlcVN0YXJ0XCIsIFwicmVxU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZi5tYXJrKFwicmVxU3RhcnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubXNnczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5uYy5yZXF1ZXN0KHRoaXMuc3ViamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWFyayhcInJlcVN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmYubWVhc3VyZShcInJlcVwiLCBcInJlcVN0YXJ0XCIsIFwicmVxU3RvcFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSgpO1xuICAgICAgICAgICAgICAgIGpvYnMucHVzaChqb2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoam9icyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmVuY2ggPSBCZW5jaDtcbmZ1bmN0aW9uIHRocm91Z2hwdXQoYnl0ZXMsIHNlY29uZHMpIHtcbiAgICByZXR1cm4gYCR7aHVtYW5pemVCeXRlcyhieXRlcyAvIHNlY29uZHMpfS9zZWNgO1xufVxuZXhwb3J0cy50aHJvdWdocHV0ID0gdGhyb3VnaHB1dDtcbmZ1bmN0aW9uIG1zZ1Rocm91Z2hwdXQobXNncywgc2Vjb25kcykge1xuICAgIHJldHVybiBgJHsoTWF0aC5mbG9vcihtc2dzIC8gc2Vjb25kcykpfSBtc2dzL3NlY2A7XG59XG5leHBvcnRzLm1zZ1Rocm91Z2hwdXQgPSBtc2dUaHJvdWdocHV0O1xuZnVuY3Rpb24gaHVtYW5pemVCeXRlcyhieXRlcywgc2kgPSBmYWxzZSkge1xuICAgIGNvbnN0IGJhc2UgPSBzaSA/IDEwMDAgOiAxMDI0O1xuICAgIGNvbnN0IHByZSA9IHNpXG4gICAgICAgID8gW1wia1wiLCBcIk1cIiwgXCJHXCIsIFwiVFwiLCBcIlBcIiwgXCJFXCJdXG4gICAgICAgIDogW1wiS1wiLCBcIk1cIiwgXCJHXCIsIFwiVFwiLCBcIlBcIiwgXCJFXCJdO1xuICAgIGNvbnN0IHBvc3QgPSBzaSA/IFwiaUJcIiA6IFwiQlwiO1xuICAgIGlmIChieXRlcyA8IGJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGAke2J5dGVzLnRvRml4ZWQoMil9ICR7cG9zdH1gO1xuICAgIH1cbiAgICBjb25zdCBleHAgPSBwYXJzZUludChNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZyhiYXNlKSArIFwiXCIpO1xuICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoKGV4cCAtIDEpICsgXCJcIik7XG4gICAgcmV0dXJuIGAkeyhieXRlcyAvIE1hdGgucG93KGJhc2UsIGV4cCkpLnRvRml4ZWQoMil9ICR7cHJlW2luZGV4XX0ke3Bvc3R9YDtcbn1cbmV4cG9ydHMuaHVtYW5pemVCeXRlcyA9IGh1bWFuaXplQnl0ZXM7XG5mdW5jdGlvbiBodW1hbml6ZU51bWJlcihuKSB7XG4gICAgcmV0dXJuIG4udG9TdHJpbmcoKS5yZXBsYWNlKC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCBcIixcIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iZW5jaC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/bench.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/codec.js":
/*!*********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/codec.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020-2022 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JSONCodec = exports.StringCodec = void 0;\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\n/**\n * Returns a {@link Codec} for encoding strings to a message payload\n * and decoding message payloads into strings.\n * @constructor\n */\nfunction StringCodec() {\n    return {\n        encode(d) {\n            return encoders_1.TE.encode(d);\n        },\n        decode(a) {\n            return encoders_1.TD.decode(a);\n        },\n    };\n}\nexports.StringCodec = StringCodec;\n/**\n * Returns a {@link Codec}  for encoding JavaScript object to JSON and\n * serialize them to an Uint8Array, and conversely, from an\n * Uint8Array to JSON to a JavaScript Object.\n * @param reviver\n * @constructor\n */\nfunction JSONCodec(reviver) {\n    return {\n        encode(d) {\n            try {\n                if (d === undefined) {\n                    // @ts-ignore: json will not handle undefined\n                    d = null;\n                }\n                return encoders_1.TE.encode(JSON.stringify(d));\n            }\n            catch (err) {\n                throw core_1.NatsError.errorForCode(core_1.ErrorCode.BadJson, err);\n            }\n        },\n        decode(a) {\n            try {\n                return JSON.parse(encoders_1.TD.decode(a), reviver);\n            }\n            catch (err) {\n                throw core_1.NatsError.errorForCode(core_1.ErrorCode.BadJson, err);\n            }\n        },\n    };\n}\nexports.JSONCodec = JSONCodec;\n//# sourceMappingURL=codec.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9jb2RlYy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCLEdBQUcsbUJBQW1CO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBUTtBQUMvQjtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L2NvZGVjLmpzPzA0MDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5KU09OQ29kZWMgPSBleHBvcnRzLlN0cmluZ0NvZGVjID0gdm9pZCAwO1xuY29uc3QgZW5jb2RlcnNfMSA9IHJlcXVpcmUoXCIuL2VuY29kZXJzXCIpO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbi8qKlxuICogUmV0dXJucyBhIHtAbGluayBDb2RlY30gZm9yIGVuY29kaW5nIHN0cmluZ3MgdG8gYSBtZXNzYWdlIHBheWxvYWRcbiAqIGFuZCBkZWNvZGluZyBtZXNzYWdlIHBheWxvYWRzIGludG8gc3RyaW5ncy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdHJpbmdDb2RlYygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZCkge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXJzXzEuVEUuZW5jb2RlKGQpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXJzXzEuVEQuZGVjb2RlKGEpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLlN0cmluZ0NvZGVjID0gU3RyaW5nQ29kZWM7XG4vKipcbiAqIFJldHVybnMgYSB7QGxpbmsgQ29kZWN9ICBmb3IgZW5jb2RpbmcgSmF2YVNjcmlwdCBvYmplY3QgdG8gSlNPTiBhbmRcbiAqIHNlcmlhbGl6ZSB0aGVtIHRvIGFuIFVpbnQ4QXJyYXksIGFuZCBjb252ZXJzZWx5LCBmcm9tIGFuXG4gKiBVaW50OEFycmF5IHRvIEpTT04gdG8gYSBKYXZhU2NyaXB0IE9iamVjdC5cbiAqIEBwYXJhbSByZXZpdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSlNPTkNvZGVjKHJldml2ZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGpzb24gd2lsbCBub3QgaGFuZGxlIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZXJzXzEuVEUuZW5jb2RlKEpTT04uc3RyaW5naWZ5KGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb3JlXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLkJhZEpzb24sIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShhKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGVuY29kZXJzXzEuVEQuZGVjb2RlKGEpLCByZXZpdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBjb3JlXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLkJhZEpzb24sIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuSlNPTkNvZGVjID0gSlNPTkNvZGVjO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/codec.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/core.js":
/*!********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/core.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServiceVerb = exports.DEFAULT_HOST = exports.DEFAULT_PORT = exports.createInbox = exports.ServiceError = exports.ServiceErrorCodeHeader = exports.ServiceErrorHeader = exports.ServiceResponseType = exports.syncIterator = exports.RequestStrategy = exports.Match = exports.NatsError = exports.Messages = exports.isNatsError = exports.ErrorCode = exports.DebugEvents = exports.Events = void 0;\nconst nuid_1 = __webpack_require__(/*! ./nuid */ \"(rsc)/./node_modules/nats/lib/nats-base-client/nuid.js\");\n/**\n * Events reported by the {@link NatsConnection#status} iterator.\n */\nvar Events;\n(function (Events) {\n    /** Client disconnected */\n    Events[\"Disconnect\"] = \"disconnect\";\n    /** Client reconnected */\n    Events[\"Reconnect\"] = \"reconnect\";\n    /** Client received a cluster update */\n    Events[\"Update\"] = \"update\";\n    /** Client received a signal telling it that the server is transitioning to Lame Duck Mode */\n    Events[\"LDM\"] = \"ldm\";\n    /** Client received an async error from the server */\n    Events[\"Error\"] = \"error\";\n})(Events || (exports.Events = Events = {}));\n/**\n * Other events that can be reported by the {@link NatsConnection#status} iterator.\n * These can usually be safely ignored, as higher-order functionality of the client\n * will handle them.\n */\nvar DebugEvents;\n(function (DebugEvents) {\n    DebugEvents[\"Reconnecting\"] = \"reconnecting\";\n    DebugEvents[\"PingTimer\"] = \"pingTimer\";\n    DebugEvents[\"StaleConnection\"] = \"staleConnection\";\n    DebugEvents[\"ClientInitiatedReconnect\"] = \"client initiated reconnect\";\n})(DebugEvents || (exports.DebugEvents = DebugEvents = {}));\nvar ErrorCode;\n(function (ErrorCode) {\n    // emitted by the client\n    ErrorCode[\"ApiError\"] = \"BAD API\";\n    ErrorCode[\"BadAuthentication\"] = \"BAD_AUTHENTICATION\";\n    ErrorCode[\"BadCreds\"] = \"BAD_CREDS\";\n    ErrorCode[\"BadHeader\"] = \"BAD_HEADER\";\n    ErrorCode[\"BadJson\"] = \"BAD_JSON\";\n    ErrorCode[\"BadPayload\"] = \"BAD_PAYLOAD\";\n    ErrorCode[\"BadSubject\"] = \"BAD_SUBJECT\";\n    ErrorCode[\"Cancelled\"] = \"CANCELLED\";\n    ErrorCode[\"ConnectionClosed\"] = \"CONNECTION_CLOSED\";\n    ErrorCode[\"ConnectionDraining\"] = \"CONNECTION_DRAINING\";\n    ErrorCode[\"ConnectionRefused\"] = \"CONNECTION_REFUSED\";\n    ErrorCode[\"ConnectionTimeout\"] = \"CONNECTION_TIMEOUT\";\n    ErrorCode[\"Disconnect\"] = \"DISCONNECT\";\n    ErrorCode[\"InvalidOption\"] = \"INVALID_OPTION\";\n    ErrorCode[\"InvalidPayload\"] = \"INVALID_PAYLOAD\";\n    ErrorCode[\"MaxPayloadExceeded\"] = \"MAX_PAYLOAD_EXCEEDED\";\n    ErrorCode[\"NoResponders\"] = \"503\";\n    ErrorCode[\"NotFunction\"] = \"NOT_FUNC\";\n    ErrorCode[\"RequestError\"] = \"REQUEST_ERROR\";\n    ErrorCode[\"ServerOptionNotAvailable\"] = \"SERVER_OPT_NA\";\n    ErrorCode[\"SubClosed\"] = \"SUB_CLOSED\";\n    ErrorCode[\"SubDraining\"] = \"SUB_DRAINING\";\n    ErrorCode[\"Timeout\"] = \"TIMEOUT\";\n    ErrorCode[\"Tls\"] = \"TLS\";\n    ErrorCode[\"Unknown\"] = \"UNKNOWN_ERROR\";\n    ErrorCode[\"WssRequired\"] = \"WSS_REQUIRED\";\n    // jetstream\n    ErrorCode[\"JetStreamInvalidAck\"] = \"JESTREAM_INVALID_ACK\";\n    ErrorCode[\"JetStream404NoMessages\"] = \"404\";\n    ErrorCode[\"JetStream408RequestTimeout\"] = \"408\";\n    //@deprecated: use JetStream409\n    ErrorCode[\"JetStream409MaxAckPendingExceeded\"] = \"409\";\n    ErrorCode[\"JetStream409\"] = \"409\";\n    ErrorCode[\"JetStreamNotEnabled\"] = \"503\";\n    ErrorCode[\"JetStreamIdleHeartBeat\"] = \"IDLE_HEARTBEAT\";\n    // emitted by the server\n    ErrorCode[\"AuthorizationViolation\"] = \"AUTHORIZATION_VIOLATION\";\n    ErrorCode[\"AuthenticationExpired\"] = \"AUTHENTICATION_EXPIRED\";\n    ErrorCode[\"ProtocolError\"] = \"NATS_PROTOCOL_ERR\";\n    ErrorCode[\"PermissionsViolation\"] = \"PERMISSIONS_VIOLATION\";\n    ErrorCode[\"AuthenticationTimeout\"] = \"AUTHENTICATION_TIMEOUT\";\n})(ErrorCode || (exports.ErrorCode = ErrorCode = {}));\nfunction isNatsError(err) {\n    return typeof err.code === \"string\";\n}\nexports.isNatsError = isNatsError;\nclass Messages {\n    constructor() {\n        this.messages = new Map();\n        this.messages.set(ErrorCode.InvalidPayload, \"Invalid payload type - payloads can be 'binary', 'string', or 'json'\");\n        this.messages.set(ErrorCode.BadJson, \"Bad JSON\");\n        this.messages.set(ErrorCode.WssRequired, \"TLS is required, therefore a secure websocket connection is also required\");\n    }\n    static getMessage(s) {\n        return messages.getMessage(s);\n    }\n    getMessage(s) {\n        return this.messages.get(s) || s;\n    }\n}\nexports.Messages = Messages;\n// safari doesn't support static class members\nconst messages = new Messages();\nclass NatsError extends Error {\n    /**\n     * @param {String} message\n     * @param {String} code\n     * @param {Error} [chainedError]\n     * @constructor\n     *\n     * @api private\n     */\n    constructor(message, code, chainedError) {\n        super(message);\n        this.name = \"NatsError\";\n        this.message = message;\n        this.code = code;\n        this.chainedError = chainedError;\n    }\n    static errorForCode(code, chainedError) {\n        const m = Messages.getMessage(code);\n        return new NatsError(m, code, chainedError);\n    }\n    isAuthError() {\n        return this.code === ErrorCode.AuthenticationExpired ||\n            this.code === ErrorCode.AuthorizationViolation;\n    }\n    isAuthTimeout() {\n        return this.code === ErrorCode.AuthenticationTimeout;\n    }\n    isPermissionError() {\n        return this.code === ErrorCode.PermissionsViolation;\n    }\n    isProtocolError() {\n        return this.code === ErrorCode.ProtocolError;\n    }\n    isJetStreamError() {\n        return this.api_error !== undefined;\n    }\n    jsError() {\n        return this.api_error ? this.api_error : null;\n    }\n}\nexports.NatsError = NatsError;\nvar Match;\n(function (Match) {\n    // Exact option is case sensitive\n    Match[Match[\"Exact\"] = 0] = \"Exact\";\n    // Case sensitive, but key is transformed to Canonical MIME representation\n    Match[Match[\"CanonicalMIME\"] = 1] = \"CanonicalMIME\";\n    // Case insensitive matches\n    Match[Match[\"IgnoreCase\"] = 2] = \"IgnoreCase\";\n})(Match || (exports.Match = Match = {}));\nvar RequestStrategy;\n(function (RequestStrategy) {\n    RequestStrategy[\"Timer\"] = \"timer\";\n    RequestStrategy[\"Count\"] = \"count\";\n    RequestStrategy[\"JitterTimer\"] = \"jitterTimer\";\n    RequestStrategy[\"SentinelMsg\"] = \"sentinelMsg\";\n})(RequestStrategy || (exports.RequestStrategy = RequestStrategy = {}));\n/**\n * syncIterator is a utility function that allows an AsyncIterator to be triggered\n * by calling next() - the utility will yield null if the underlying iterator is closed.\n * Note it is possibly an error to call use this function on an AsyncIterable that has\n * already been started (Symbol.asyncIterator() has been called) from a looping construct.\n */\nfunction syncIterator(src) {\n    const iter = src[Symbol.asyncIterator]();\n    return {\n        next() {\n            return __awaiter(this, void 0, void 0, function* () {\n                const m = yield iter.next();\n                if (m.done) {\n                    return Promise.resolve(null);\n                }\n                return Promise.resolve(m.value);\n            });\n        },\n    };\n}\nexports.syncIterator = syncIterator;\nvar ServiceResponseType;\n(function (ServiceResponseType) {\n    ServiceResponseType[\"STATS\"] = \"io.nats.micro.v1.stats_response\";\n    ServiceResponseType[\"INFO\"] = \"io.nats.micro.v1.info_response\";\n    ServiceResponseType[\"PING\"] = \"io.nats.micro.v1.ping_response\";\n})(ServiceResponseType || (exports.ServiceResponseType = ServiceResponseType = {}));\nexports.ServiceErrorHeader = \"Nats-Service-Error\";\nexports.ServiceErrorCodeHeader = \"Nats-Service-Error-Code\";\nclass ServiceError extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n    }\n    static isServiceError(msg) {\n        return ServiceError.toServiceError(msg) !== null;\n    }\n    static toServiceError(msg) {\n        var _a, _b;\n        const scode = ((_a = msg === null || msg === void 0 ? void 0 : msg.headers) === null || _a === void 0 ? void 0 : _a.get(exports.ServiceErrorCodeHeader)) || \"\";\n        if (scode !== \"\") {\n            const code = parseInt(scode) || 400;\n            const description = ((_b = msg === null || msg === void 0 ? void 0 : msg.headers) === null || _b === void 0 ? void 0 : _b.get(exports.ServiceErrorHeader)) || \"\";\n            return new ServiceError(code, description.length ? description : scode);\n        }\n        return null;\n    }\n}\nexports.ServiceError = ServiceError;\nfunction createInbox(prefix = \"\") {\n    prefix = prefix || \"_INBOX\";\n    if (typeof prefix !== \"string\") {\n        throw (new Error(\"prefix must be a string\"));\n    }\n    prefix.split(\".\")\n        .forEach((v) => {\n        if (v === \"*\" || v === \">\") {\n            throw new Error(`inbox prefixes cannot have wildcards '${prefix}'`);\n        }\n    });\n    return `${prefix}.${nuid_1.nuid.next()}`;\n}\nexports.createInbox = createInbox;\nexports.DEFAULT_PORT = 4222;\nexports.DEFAULT_HOST = \"127.0.0.1\";\nvar ServiceVerb;\n(function (ServiceVerb) {\n    ServiceVerb[\"PING\"] = \"PING\";\n    ServiceVerb[\"STATS\"] = \"STATS\";\n    ServiceVerb[\"INFO\"] = \"INFO\";\n})(ServiceVerb || (exports.ServiceVerb = ServiceVerb = {}));\n//# sourceMappingURL=core.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcsOEJBQThCLEdBQUcsMEJBQTBCLEdBQUcsMkJBQTJCLEdBQUcsb0JBQW9CLEdBQUcsdUJBQXVCLEdBQUcsYUFBYSxHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLG1CQUFtQixHQUFHLGNBQWM7QUFDblksZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CO0FBQ0EsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYSxjQUFjLGNBQWM7QUFDMUM7QUFDQSw2Q0FBNkMsNkJBQTZCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCLG1CQUFtQixtQkFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCLGlCQUFpQixpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFlBQVksYUFBYSxhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCLHVCQUF1Qix1QkFBdUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCLDJCQUEyQiwyQkFBMkI7QUFDakYsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE9BQU87QUFDNUU7QUFDQSxLQUFLO0FBQ0wsY0FBYyxPQUFPLEdBQUcsbUJBQW1CO0FBQzNDO0FBQ0EsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCLG1CQUFtQixtQkFBbUI7QUFDekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L2NvcmUuanM/ZjU3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMyBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZpY2VWZXJiID0gZXhwb3J0cy5ERUZBVUxUX0hPU1QgPSBleHBvcnRzLkRFRkFVTFRfUE9SVCA9IGV4cG9ydHMuY3JlYXRlSW5ib3ggPSBleHBvcnRzLlNlcnZpY2VFcnJvciA9IGV4cG9ydHMuU2VydmljZUVycm9yQ29kZUhlYWRlciA9IGV4cG9ydHMuU2VydmljZUVycm9ySGVhZGVyID0gZXhwb3J0cy5TZXJ2aWNlUmVzcG9uc2VUeXBlID0gZXhwb3J0cy5zeW5jSXRlcmF0b3IgPSBleHBvcnRzLlJlcXVlc3RTdHJhdGVneSA9IGV4cG9ydHMuTWF0Y2ggPSBleHBvcnRzLk5hdHNFcnJvciA9IGV4cG9ydHMuTWVzc2FnZXMgPSBleHBvcnRzLmlzTmF0c0Vycm9yID0gZXhwb3J0cy5FcnJvckNvZGUgPSBleHBvcnRzLkRlYnVnRXZlbnRzID0gZXhwb3J0cy5FdmVudHMgPSB2b2lkIDA7XG5jb25zdCBudWlkXzEgPSByZXF1aXJlKFwiLi9udWlkXCIpO1xuLyoqXG4gKiBFdmVudHMgcmVwb3J0ZWQgYnkgdGhlIHtAbGluayBOYXRzQ29ubmVjdGlvbiNzdGF0dXN9IGl0ZXJhdG9yLlxuICovXG52YXIgRXZlbnRzO1xuKGZ1bmN0aW9uIChFdmVudHMpIHtcbiAgICAvKiogQ2xpZW50IGRpc2Nvbm5lY3RlZCAqL1xuICAgIEV2ZW50c1tcIkRpc2Nvbm5lY3RcIl0gPSBcImRpc2Nvbm5lY3RcIjtcbiAgICAvKiogQ2xpZW50IHJlY29ubmVjdGVkICovXG4gICAgRXZlbnRzW1wiUmVjb25uZWN0XCJdID0gXCJyZWNvbm5lY3RcIjtcbiAgICAvKiogQ2xpZW50IHJlY2VpdmVkIGEgY2x1c3RlciB1cGRhdGUgKi9cbiAgICBFdmVudHNbXCJVcGRhdGVcIl0gPSBcInVwZGF0ZVwiO1xuICAgIC8qKiBDbGllbnQgcmVjZWl2ZWQgYSBzaWduYWwgdGVsbGluZyBpdCB0aGF0IHRoZSBzZXJ2ZXIgaXMgdHJhbnNpdGlvbmluZyB0byBMYW1lIER1Y2sgTW9kZSAqL1xuICAgIEV2ZW50c1tcIkxETVwiXSA9IFwibGRtXCI7XG4gICAgLyoqIENsaWVudCByZWNlaXZlZCBhbiBhc3luYyBlcnJvciBmcm9tIHRoZSBzZXJ2ZXIgKi9cbiAgICBFdmVudHNbXCJFcnJvclwiXSA9IFwiZXJyb3JcIjtcbn0pKEV2ZW50cyB8fCAoZXhwb3J0cy5FdmVudHMgPSBFdmVudHMgPSB7fSkpO1xuLyoqXG4gKiBPdGhlciBldmVudHMgdGhhdCBjYW4gYmUgcmVwb3J0ZWQgYnkgdGhlIHtAbGluayBOYXRzQ29ubmVjdGlvbiNzdGF0dXN9IGl0ZXJhdG9yLlxuICogVGhlc2UgY2FuIHVzdWFsbHkgYmUgc2FmZWx5IGlnbm9yZWQsIGFzIGhpZ2hlci1vcmRlciBmdW5jdGlvbmFsaXR5IG9mIHRoZSBjbGllbnRcbiAqIHdpbGwgaGFuZGxlIHRoZW0uXG4gKi9cbnZhciBEZWJ1Z0V2ZW50cztcbihmdW5jdGlvbiAoRGVidWdFdmVudHMpIHtcbiAgICBEZWJ1Z0V2ZW50c1tcIlJlY29ubmVjdGluZ1wiXSA9IFwicmVjb25uZWN0aW5nXCI7XG4gICAgRGVidWdFdmVudHNbXCJQaW5nVGltZXJcIl0gPSBcInBpbmdUaW1lclwiO1xuICAgIERlYnVnRXZlbnRzW1wiU3RhbGVDb25uZWN0aW9uXCJdID0gXCJzdGFsZUNvbm5lY3Rpb25cIjtcbiAgICBEZWJ1Z0V2ZW50c1tcIkNsaWVudEluaXRpYXRlZFJlY29ubmVjdFwiXSA9IFwiY2xpZW50IGluaXRpYXRlZCByZWNvbm5lY3RcIjtcbn0pKERlYnVnRXZlbnRzIHx8IChleHBvcnRzLkRlYnVnRXZlbnRzID0gRGVidWdFdmVudHMgPSB7fSkpO1xudmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgLy8gZW1pdHRlZCBieSB0aGUgY2xpZW50XG4gICAgRXJyb3JDb2RlW1wiQXBpRXJyb3JcIl0gPSBcIkJBRCBBUElcIjtcbiAgICBFcnJvckNvZGVbXCJCYWRBdXRoZW50aWNhdGlvblwiXSA9IFwiQkFEX0FVVEhFTlRJQ0FUSU9OXCI7XG4gICAgRXJyb3JDb2RlW1wiQmFkQ3JlZHNcIl0gPSBcIkJBRF9DUkVEU1wiO1xuICAgIEVycm9yQ29kZVtcIkJhZEhlYWRlclwiXSA9IFwiQkFEX0hFQURFUlwiO1xuICAgIEVycm9yQ29kZVtcIkJhZEpzb25cIl0gPSBcIkJBRF9KU09OXCI7XG4gICAgRXJyb3JDb2RlW1wiQmFkUGF5bG9hZFwiXSA9IFwiQkFEX1BBWUxPQURcIjtcbiAgICBFcnJvckNvZGVbXCJCYWRTdWJqZWN0XCJdID0gXCJCQURfU1VCSkVDVFwiO1xuICAgIEVycm9yQ29kZVtcIkNhbmNlbGxlZFwiXSA9IFwiQ0FOQ0VMTEVEXCI7XG4gICAgRXJyb3JDb2RlW1wiQ29ubmVjdGlvbkNsb3NlZFwiXSA9IFwiQ09OTkVDVElPTl9DTE9TRURcIjtcbiAgICBFcnJvckNvZGVbXCJDb25uZWN0aW9uRHJhaW5pbmdcIl0gPSBcIkNPTk5FQ1RJT05fRFJBSU5JTkdcIjtcbiAgICBFcnJvckNvZGVbXCJDb25uZWN0aW9uUmVmdXNlZFwiXSA9IFwiQ09OTkVDVElPTl9SRUZVU0VEXCI7XG4gICAgRXJyb3JDb2RlW1wiQ29ubmVjdGlvblRpbWVvdXRcIl0gPSBcIkNPTk5FQ1RJT05fVElNRU9VVFwiO1xuICAgIEVycm9yQ29kZVtcIkRpc2Nvbm5lY3RcIl0gPSBcIkRJU0NPTk5FQ1RcIjtcbiAgICBFcnJvckNvZGVbXCJJbnZhbGlkT3B0aW9uXCJdID0gXCJJTlZBTElEX09QVElPTlwiO1xuICAgIEVycm9yQ29kZVtcIkludmFsaWRQYXlsb2FkXCJdID0gXCJJTlZBTElEX1BBWUxPQURcIjtcbiAgICBFcnJvckNvZGVbXCJNYXhQYXlsb2FkRXhjZWVkZWRcIl0gPSBcIk1BWF9QQVlMT0FEX0VYQ0VFREVEXCI7XG4gICAgRXJyb3JDb2RlW1wiTm9SZXNwb25kZXJzXCJdID0gXCI1MDNcIjtcbiAgICBFcnJvckNvZGVbXCJOb3RGdW5jdGlvblwiXSA9IFwiTk9UX0ZVTkNcIjtcbiAgICBFcnJvckNvZGVbXCJSZXF1ZXN0RXJyb3JcIl0gPSBcIlJFUVVFU1RfRVJST1JcIjtcbiAgICBFcnJvckNvZGVbXCJTZXJ2ZXJPcHRpb25Ob3RBdmFpbGFibGVcIl0gPSBcIlNFUlZFUl9PUFRfTkFcIjtcbiAgICBFcnJvckNvZGVbXCJTdWJDbG9zZWRcIl0gPSBcIlNVQl9DTE9TRURcIjtcbiAgICBFcnJvckNvZGVbXCJTdWJEcmFpbmluZ1wiXSA9IFwiU1VCX0RSQUlOSU5HXCI7XG4gICAgRXJyb3JDb2RlW1wiVGltZW91dFwiXSA9IFwiVElNRU9VVFwiO1xuICAgIEVycm9yQ29kZVtcIlRsc1wiXSA9IFwiVExTXCI7XG4gICAgRXJyb3JDb2RlW1wiVW5rbm93blwiXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuICAgIEVycm9yQ29kZVtcIldzc1JlcXVpcmVkXCJdID0gXCJXU1NfUkVRVUlSRURcIjtcbiAgICAvLyBqZXRzdHJlYW1cbiAgICBFcnJvckNvZGVbXCJKZXRTdHJlYW1JbnZhbGlkQWNrXCJdID0gXCJKRVNUUkVBTV9JTlZBTElEX0FDS1wiO1xuICAgIEVycm9yQ29kZVtcIkpldFN0cmVhbTQwNE5vTWVzc2FnZXNcIl0gPSBcIjQwNFwiO1xuICAgIEVycm9yQ29kZVtcIkpldFN0cmVhbTQwOFJlcXVlc3RUaW1lb3V0XCJdID0gXCI0MDhcIjtcbiAgICAvL0BkZXByZWNhdGVkOiB1c2UgSmV0U3RyZWFtNDA5XG4gICAgRXJyb3JDb2RlW1wiSmV0U3RyZWFtNDA5TWF4QWNrUGVuZGluZ0V4Y2VlZGVkXCJdID0gXCI0MDlcIjtcbiAgICBFcnJvckNvZGVbXCJKZXRTdHJlYW00MDlcIl0gPSBcIjQwOVwiO1xuICAgIEVycm9yQ29kZVtcIkpldFN0cmVhbU5vdEVuYWJsZWRcIl0gPSBcIjUwM1wiO1xuICAgIEVycm9yQ29kZVtcIkpldFN0cmVhbUlkbGVIZWFydEJlYXRcIl0gPSBcIklETEVfSEVBUlRCRUFUXCI7XG4gICAgLy8gZW1pdHRlZCBieSB0aGUgc2VydmVyXG4gICAgRXJyb3JDb2RlW1wiQXV0aG9yaXphdGlvblZpb2xhdGlvblwiXSA9IFwiQVVUSE9SSVpBVElPTl9WSU9MQVRJT05cIjtcbiAgICBFcnJvckNvZGVbXCJBdXRoZW50aWNhdGlvbkV4cGlyZWRcIl0gPSBcIkFVVEhFTlRJQ0FUSU9OX0VYUElSRURcIjtcbiAgICBFcnJvckNvZGVbXCJQcm90b2NvbEVycm9yXCJdID0gXCJOQVRTX1BST1RPQ09MX0VSUlwiO1xuICAgIEVycm9yQ29kZVtcIlBlcm1pc3Npb25zVmlvbGF0aW9uXCJdID0gXCJQRVJNSVNTSU9OU19WSU9MQVRJT05cIjtcbiAgICBFcnJvckNvZGVbXCJBdXRoZW50aWNhdGlvblRpbWVvdXRcIl0gPSBcIkFVVEhFTlRJQ0FUSU9OX1RJTUVPVVRcIjtcbn0pKEVycm9yQ29kZSB8fCAoZXhwb3J0cy5FcnJvckNvZGUgPSBFcnJvckNvZGUgPSB7fSkpO1xuZnVuY3Rpb24gaXNOYXRzRXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnIuY29kZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmV4cG9ydHMuaXNOYXRzRXJyb3IgPSBpc05hdHNFcnJvcjtcbmNsYXNzIE1lc3NhZ2VzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5zZXQoRXJyb3JDb2RlLkludmFsaWRQYXlsb2FkLCBcIkludmFsaWQgcGF5bG9hZCB0eXBlIC0gcGF5bG9hZHMgY2FuIGJlICdiaW5hcnknLCAnc3RyaW5nJywgb3IgJ2pzb24nXCIpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnNldChFcnJvckNvZGUuQmFkSnNvbiwgXCJCYWQgSlNPTlwiKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5zZXQoRXJyb3JDb2RlLldzc1JlcXVpcmVkLCBcIlRMUyBpcyByZXF1aXJlZCwgdGhlcmVmb3JlIGEgc2VjdXJlIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzIGFsc28gcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRNZXNzYWdlKHMpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzLmdldE1lc3NhZ2Uocyk7XG4gICAgfVxuICAgIGdldE1lc3NhZ2Uocykge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlcy5nZXQocykgfHwgcztcbiAgICB9XG59XG5leHBvcnRzLk1lc3NhZ2VzID0gTWVzc2FnZXM7XG4vLyBzYWZhcmkgZG9lc24ndCBzdXBwb3J0IHN0YXRpYyBjbGFzcyBtZW1iZXJzXG5jb25zdCBtZXNzYWdlcyA9IG5ldyBNZXNzYWdlcygpO1xuY2xhc3MgTmF0c0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGVcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBbY2hhaW5lZEVycm9yXVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgY2hhaW5lZEVycm9yKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIk5hdHNFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLmNoYWluZWRFcnJvciA9IGNoYWluZWRFcnJvcjtcbiAgICB9XG4gICAgc3RhdGljIGVycm9yRm9yQ29kZShjb2RlLCBjaGFpbmVkRXJyb3IpIHtcbiAgICAgICAgY29uc3QgbSA9IE1lc3NhZ2VzLmdldE1lc3NhZ2UoY29kZSk7XG4gICAgICAgIHJldHVybiBuZXcgTmF0c0Vycm9yKG0sIGNvZGUsIGNoYWluZWRFcnJvcik7XG4gICAgfVxuICAgIGlzQXV0aEVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlID09PSBFcnJvckNvZGUuQXV0aGVudGljYXRpb25FeHBpcmVkIHx8XG4gICAgICAgICAgICB0aGlzLmNvZGUgPT09IEVycm9yQ29kZS5BdXRob3JpemF0aW9uVmlvbGF0aW9uO1xuICAgIH1cbiAgICBpc0F1dGhUaW1lb3V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlID09PSBFcnJvckNvZGUuQXV0aGVudGljYXRpb25UaW1lb3V0O1xuICAgIH1cbiAgICBpc1Blcm1pc3Npb25FcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZSA9PT0gRXJyb3JDb2RlLlBlcm1pc3Npb25zVmlvbGF0aW9uO1xuICAgIH1cbiAgICBpc1Byb3RvY29sRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGUgPT09IEVycm9yQ29kZS5Qcm90b2NvbEVycm9yO1xuICAgIH1cbiAgICBpc0pldFN0cmVhbUVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcGlfZXJyb3IgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAganNFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpX2Vycm9yID8gdGhpcy5hcGlfZXJyb3IgOiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTmF0c0Vycm9yID0gTmF0c0Vycm9yO1xudmFyIE1hdGNoO1xuKGZ1bmN0aW9uIChNYXRjaCkge1xuICAgIC8vIEV4YWN0IG9wdGlvbiBpcyBjYXNlIHNlbnNpdGl2ZVxuICAgIE1hdGNoW01hdGNoW1wiRXhhY3RcIl0gPSAwXSA9IFwiRXhhY3RcIjtcbiAgICAvLyBDYXNlIHNlbnNpdGl2ZSwgYnV0IGtleSBpcyB0cmFuc2Zvcm1lZCB0byBDYW5vbmljYWwgTUlNRSByZXByZXNlbnRhdGlvblxuICAgIE1hdGNoW01hdGNoW1wiQ2Fub25pY2FsTUlNRVwiXSA9IDFdID0gXCJDYW5vbmljYWxNSU1FXCI7XG4gICAgLy8gQ2FzZSBpbnNlbnNpdGl2ZSBtYXRjaGVzXG4gICAgTWF0Y2hbTWF0Y2hbXCJJZ25vcmVDYXNlXCJdID0gMl0gPSBcIklnbm9yZUNhc2VcIjtcbn0pKE1hdGNoIHx8IChleHBvcnRzLk1hdGNoID0gTWF0Y2ggPSB7fSkpO1xudmFyIFJlcXVlc3RTdHJhdGVneTtcbihmdW5jdGlvbiAoUmVxdWVzdFN0cmF0ZWd5KSB7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiVGltZXJcIl0gPSBcInRpbWVyXCI7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiQ291bnRcIl0gPSBcImNvdW50XCI7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiSml0dGVyVGltZXJcIl0gPSBcImppdHRlclRpbWVyXCI7XG4gICAgUmVxdWVzdFN0cmF0ZWd5W1wiU2VudGluZWxNc2dcIl0gPSBcInNlbnRpbmVsTXNnXCI7XG59KShSZXF1ZXN0U3RyYXRlZ3kgfHwgKGV4cG9ydHMuUmVxdWVzdFN0cmF0ZWd5ID0gUmVxdWVzdFN0cmF0ZWd5ID0ge30pKTtcbi8qKlxuICogc3luY0l0ZXJhdG9yIGlzIGEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IGFsbG93cyBhbiBBc3luY0l0ZXJhdG9yIHRvIGJlIHRyaWdnZXJlZFxuICogYnkgY2FsbGluZyBuZXh0KCkgLSB0aGUgdXRpbGl0eSB3aWxsIHlpZWxkIG51bGwgaWYgdGhlIHVuZGVybHlpbmcgaXRlcmF0b3IgaXMgY2xvc2VkLlxuICogTm90ZSBpdCBpcyBwb3NzaWJseSBhbiBlcnJvciB0byBjYWxsIHVzZSB0aGlzIGZ1bmN0aW9uIG9uIGFuIEFzeW5jSXRlcmFibGUgdGhhdCBoYXNcbiAqIGFscmVhZHkgYmVlbiBzdGFydGVkIChTeW1ib2wuYXN5bmNJdGVyYXRvcigpIGhhcyBiZWVuIGNhbGxlZCkgZnJvbSBhIGxvb3BpbmcgY29uc3RydWN0LlxuICovXG5mdW5jdGlvbiBzeW5jSXRlcmF0b3Ioc3JjKSB7XG4gICAgY29uc3QgaXRlciA9IHNyY1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0geWllbGQgaXRlci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG0uZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG0udmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydHMuc3luY0l0ZXJhdG9yID0gc3luY0l0ZXJhdG9yO1xudmFyIFNlcnZpY2VSZXNwb25zZVR5cGU7XG4oZnVuY3Rpb24gKFNlcnZpY2VSZXNwb25zZVR5cGUpIHtcbiAgICBTZXJ2aWNlUmVzcG9uc2VUeXBlW1wiU1RBVFNcIl0gPSBcImlvLm5hdHMubWljcm8udjEuc3RhdHNfcmVzcG9uc2VcIjtcbiAgICBTZXJ2aWNlUmVzcG9uc2VUeXBlW1wiSU5GT1wiXSA9IFwiaW8ubmF0cy5taWNyby52MS5pbmZvX3Jlc3BvbnNlXCI7XG4gICAgU2VydmljZVJlc3BvbnNlVHlwZVtcIlBJTkdcIl0gPSBcImlvLm5hdHMubWljcm8udjEucGluZ19yZXNwb25zZVwiO1xufSkoU2VydmljZVJlc3BvbnNlVHlwZSB8fCAoZXhwb3J0cy5TZXJ2aWNlUmVzcG9uc2VUeXBlID0gU2VydmljZVJlc3BvbnNlVHlwZSA9IHt9KSk7XG5leHBvcnRzLlNlcnZpY2VFcnJvckhlYWRlciA9IFwiTmF0cy1TZXJ2aWNlLUVycm9yXCI7XG5leHBvcnRzLlNlcnZpY2VFcnJvckNvZGVIZWFkZXIgPSBcIk5hdHMtU2VydmljZS1FcnJvci1Db2RlXCI7XG5jbGFzcyBTZXJ2aWNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgc3RhdGljIGlzU2VydmljZUVycm9yKG1zZykge1xuICAgICAgICByZXR1cm4gU2VydmljZUVycm9yLnRvU2VydmljZUVycm9yKG1zZykgIT09IG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyB0b1NlcnZpY2VFcnJvcihtc2cpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgc2NvZGUgPSAoKF9hID0gbXNnID09PSBudWxsIHx8IG1zZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXNnLmhlYWRlcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoZXhwb3J0cy5TZXJ2aWNlRXJyb3JDb2RlSGVhZGVyKSkgfHwgXCJcIjtcbiAgICAgICAgaWYgKHNjb2RlICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gcGFyc2VJbnQoc2NvZGUpIHx8IDQwMDtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gKChfYiA9IG1zZyA9PT0gbnVsbCB8fCBtc2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1zZy5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KGV4cG9ydHMuU2VydmljZUVycm9ySGVhZGVyKSkgfHwgXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VydmljZUVycm9yKGNvZGUsIGRlc2NyaXB0aW9uLmxlbmd0aCA/IGRlc2NyaXB0aW9uIDogc2NvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmljZUVycm9yID0gU2VydmljZUVycm9yO1xuZnVuY3Rpb24gY3JlYXRlSW5ib3gocHJlZml4ID0gXCJcIikge1xuICAgIHByZWZpeCA9IHByZWZpeCB8fCBcIl9JTkJPWFwiO1xuICAgIGlmICh0eXBlb2YgcHJlZml4ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IChuZXcgRXJyb3IoXCJwcmVmaXggbXVzdCBiZSBhIHN0cmluZ1wiKSk7XG4gICAgfVxuICAgIHByZWZpeC5zcGxpdChcIi5cIilcbiAgICAgICAgLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgaWYgKHYgPT09IFwiKlwiIHx8IHYgPT09IFwiPlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGluYm94IHByZWZpeGVzIGNhbm5vdCBoYXZlIHdpbGRjYXJkcyAnJHtwcmVmaXh9J2ApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGAke3ByZWZpeH0uJHtudWlkXzEubnVpZC5uZXh0KCl9YDtcbn1cbmV4cG9ydHMuY3JlYXRlSW5ib3ggPSBjcmVhdGVJbmJveDtcbmV4cG9ydHMuREVGQVVMVF9QT1JUID0gNDIyMjtcbmV4cG9ydHMuREVGQVVMVF9IT1NUID0gXCIxMjcuMC4wLjFcIjtcbnZhciBTZXJ2aWNlVmVyYjtcbihmdW5jdGlvbiAoU2VydmljZVZlcmIpIHtcbiAgICBTZXJ2aWNlVmVyYltcIlBJTkdcIl0gPSBcIlBJTkdcIjtcbiAgICBTZXJ2aWNlVmVyYltcIlNUQVRTXCJdID0gXCJTVEFUU1wiO1xuICAgIFNlcnZpY2VWZXJiW1wiSU5GT1wiXSA9IFwiSU5GT1wiO1xufSkoU2VydmljZVZlcmIgfHwgKGV4cG9ydHMuU2VydmljZVZlcmIgPSBTZXJ2aWNlVmVyYiA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3JlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/databuffer.js":
/*!**************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/databuffer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2018-2021 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DataBuffer = void 0;\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nclass DataBuffer {\n    constructor() {\n        this.buffers = [];\n        this.byteLength = 0;\n    }\n    static concat(...bufs) {\n        let max = 0;\n        for (let i = 0; i < bufs.length; i++) {\n            max += bufs[i].length;\n        }\n        const out = new Uint8Array(max);\n        let index = 0;\n        for (let i = 0; i < bufs.length; i++) {\n            out.set(bufs[i], index);\n            index += bufs[i].length;\n        }\n        return out;\n    }\n    static fromAscii(m) {\n        if (!m) {\n            m = \"\";\n        }\n        return encoders_1.TE.encode(m);\n    }\n    static toAscii(a) {\n        return encoders_1.TD.decode(a);\n    }\n    reset() {\n        this.buffers.length = 0;\n        this.byteLength = 0;\n    }\n    pack() {\n        if (this.buffers.length > 1) {\n            const v = new Uint8Array(this.byteLength);\n            let index = 0;\n            for (let i = 0; i < this.buffers.length; i++) {\n                v.set(this.buffers[i], index);\n                index += this.buffers[i].length;\n            }\n            this.buffers.length = 0;\n            this.buffers.push(v);\n        }\n    }\n    shift() {\n        if (this.buffers.length) {\n            const a = this.buffers.shift();\n            if (a) {\n                this.byteLength -= a.length;\n                return a;\n            }\n        }\n        return new Uint8Array(0);\n    }\n    drain(n) {\n        if (this.buffers.length) {\n            this.pack();\n            const v = this.buffers.pop();\n            if (v) {\n                const max = this.byteLength;\n                if (n === undefined || n > max) {\n                    n = max;\n                }\n                const d = v.subarray(0, n);\n                if (max > n) {\n                    this.buffers.push(v.subarray(n));\n                }\n                this.byteLength = max - n;\n                return d;\n            }\n        }\n        return new Uint8Array(0);\n    }\n    fill(a, ...bufs) {\n        if (a) {\n            this.buffers.push(a);\n            this.byteLength += a.length;\n        }\n        for (let i = 0; i < bufs.length; i++) {\n            if (bufs[i] && bufs[i].length) {\n                this.buffers.push(bufs[i]);\n                this.byteLength += bufs[i].length;\n            }\n        }\n    }\n    peek() {\n        if (this.buffers.length) {\n            this.pack();\n            return this.buffers[0];\n        }\n        return new Uint8Array(0);\n    }\n    size() {\n        return this.byteLength;\n    }\n    length() {\n        return this.buffers.length;\n    }\n}\nexports.DataBuffer = DataBuffer;\n//# sourceMappingURL=databuffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9kYXRhYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsbUJBQW1CLG1CQUFPLENBQUMsOEVBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5QkFBeUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL25hdHMtYmFzZS1jbGllbnQvZGF0YWJ1ZmZlci5qcz9jNjg5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE4LTIwMjEgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YUJ1ZmZlciA9IHZvaWQgMDtcbmNvbnN0IGVuY29kZXJzXzEgPSByZXF1aXJlKFwiLi9lbmNvZGVyc1wiKTtcbmNsYXNzIERhdGFCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgc3RhdGljIGNvbmNhdCguLi5idWZzKSB7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1heCArPSBidWZzW2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShtYXgpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmc1tpXSwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gYnVmc1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Bc2NpaShtKSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgbSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZXJzXzEuVEUuZW5jb2RlKG0pO1xuICAgIH1cbiAgICBzdGF0aWMgdG9Bc2NpaShhKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVyc18xLlRELmRlY29kZShhKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSAwO1xuICAgIH1cbiAgICBwYWNrKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBuZXcgVWludDhBcnJheSh0aGlzLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdi5zZXQodGhpcy5idWZmZXJzW2ldLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gdGhpcy5idWZmZXJzW2ldLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJzLnB1c2godik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hpZnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcy5idWZmZXJzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCAtPSBhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIGRyYWluKG4pIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucGFjaygpO1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuYnVmZmVycy5wb3AoKTtcbiAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSB1bmRlZmluZWQgfHwgbiA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBuID0gbWF4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkID0gdi5zdWJhcnJheSgwLCBuKTtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID4gbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaCh2LnN1YmFycmF5KG4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gbWF4IC0gbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgfVxuICAgIGZpbGwoYSwgLi4uYnVmcykge1xuICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYSk7XG4gICAgICAgICAgICB0aGlzLmJ5dGVMZW5ndGggKz0gYS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYnVmc1tpXSAmJiBidWZzW2ldLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZnNbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZUxlbmd0aCArPSBidWZzW2ldLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wYWNrKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzLmxlbmd0aDtcbiAgICB9XG59XG5leHBvcnRzLkRhdGFCdWZmZXIgPSBEYXRhQnVmZmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YWJ1ZmZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/databuffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/denobuffer.js":
/*!**************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/denobuffer.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// Copyright 2018-2021 the Deno authors. All rights reserved. MIT license.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.writeAll = exports.readAll = exports.DenoBuffer = exports.append = exports.concat = exports.MAX_SIZE = exports.assert = exports.AssertionError = void 0;\n// This code has been ported almost directly from Go's src/bytes/buffer.go\n// Copyright 2009 The Go Authors. All rights reserved. BSD license.\n// https://github.com/golang/go/blob/master/LICENSE\n// This code removes all Deno specific functionality to enable its use\n// in a browser environment\n//@internal\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nclass AssertionError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = \"AssertionError\";\n    }\n}\nexports.AssertionError = AssertionError;\n// @internal\nfunction assert(cond, msg = \"Assertion failed.\") {\n    if (!cond) {\n        throw new AssertionError(msg);\n    }\n}\nexports.assert = assert;\n// MIN_READ is the minimum ArrayBuffer size passed to a read call by\n// buffer.ReadFrom. As long as the Buffer has at least MIN_READ bytes beyond\n// what is required to hold the contents of r, readFrom() will not grow the\n// underlying buffer.\nconst MIN_READ = 32 * 1024;\nexports.MAX_SIZE = Math.pow(2, 32) - 2;\n// `off` is the offset into `dst` where it will at which to begin writing values\n// from `src`.\n// Returns the number of bytes copied.\nfunction copy(src, dst, off = 0) {\n    const r = dst.byteLength - off;\n    if (src.byteLength > r) {\n        src = src.subarray(0, r);\n    }\n    dst.set(src, off);\n    return src.byteLength;\n}\nfunction concat(origin, b) {\n    if (origin === undefined && b === undefined) {\n        return new Uint8Array(0);\n    }\n    if (origin === undefined) {\n        return b;\n    }\n    if (b === undefined) {\n        return origin;\n    }\n    const output = new Uint8Array(origin.length + b.length);\n    output.set(origin, 0);\n    output.set(b, origin.length);\n    return output;\n}\nexports.concat = concat;\nfunction append(origin, b) {\n    return concat(origin, Uint8Array.of(b));\n}\nexports.append = append;\nclass DenoBuffer {\n    constructor(ab) {\n        this._off = 0;\n        if (ab == null) {\n            this._buf = new Uint8Array(0);\n            return;\n        }\n        this._buf = new Uint8Array(ab);\n    }\n    bytes(options = { copy: true }) {\n        if (options.copy === false)\n            return this._buf.subarray(this._off);\n        return this._buf.slice(this._off);\n    }\n    empty() {\n        return this._buf.byteLength <= this._off;\n    }\n    get length() {\n        return this._buf.byteLength - this._off;\n    }\n    get capacity() {\n        return this._buf.buffer.byteLength;\n    }\n    truncate(n) {\n        if (n === 0) {\n            this.reset();\n            return;\n        }\n        if (n < 0 || n > this.length) {\n            throw Error(\"bytes.Buffer: truncation out of range\");\n        }\n        this._reslice(this._off + n);\n    }\n    reset() {\n        this._reslice(0);\n        this._off = 0;\n    }\n    _tryGrowByReslice(n) {\n        const l = this._buf.byteLength;\n        if (n <= this.capacity - l) {\n            this._reslice(l + n);\n            return l;\n        }\n        return -1;\n    }\n    _reslice(len) {\n        assert(len <= this._buf.buffer.byteLength);\n        this._buf = new Uint8Array(this._buf.buffer, 0, len);\n    }\n    readByte() {\n        const a = new Uint8Array(1);\n        if (this.read(a)) {\n            return a[0];\n        }\n        return null;\n    }\n    read(p) {\n        if (this.empty()) {\n            // Buffer is empty, reset to recover space.\n            this.reset();\n            if (p.byteLength === 0) {\n                // this edge case is tested in 'bufferReadEmptyAtEOF' test\n                return 0;\n            }\n            return null;\n        }\n        const nread = copy(this._buf.subarray(this._off), p);\n        this._off += nread;\n        return nread;\n    }\n    writeByte(n) {\n        return this.write(Uint8Array.of(n));\n    }\n    writeString(s) {\n        return this.write(encoders_1.TE.encode(s));\n    }\n    write(p) {\n        const m = this._grow(p.byteLength);\n        return copy(p, this._buf, m);\n    }\n    _grow(n) {\n        const m = this.length;\n        // If buffer is empty, reset to recover space.\n        if (m === 0 && this._off !== 0) {\n            this.reset();\n        }\n        // Fast: Try to _grow by means of a _reslice.\n        const i = this._tryGrowByReslice(n);\n        if (i >= 0) {\n            return i;\n        }\n        const c = this.capacity;\n        if (n <= Math.floor(c / 2) - m) {\n            // We can slide things down instead of allocating a new\n            // ArrayBuffer. We only need m+n <= c to slide, but\n            // we instead let capacity get twice as large so we\n            // don't spend all our time copying.\n            copy(this._buf.subarray(this._off), this._buf);\n        }\n        else if (c + n > exports.MAX_SIZE) {\n            throw new Error(\"The buffer cannot be grown beyond the maximum size.\");\n        }\n        else {\n            // Not enough space anywhere, we need to allocate.\n            const buf = new Uint8Array(Math.min(2 * c + n, exports.MAX_SIZE));\n            copy(this._buf.subarray(this._off), buf);\n            this._buf = buf;\n        }\n        // Restore this.off and len(this._buf).\n        this._off = 0;\n        this._reslice(Math.min(m + n, exports.MAX_SIZE));\n        return m;\n    }\n    grow(n) {\n        if (n < 0) {\n            throw Error(\"Buffer._grow: negative count\");\n        }\n        const m = this._grow(n);\n        this._reslice(m);\n    }\n    readFrom(r) {\n        let n = 0;\n        const tmp = new Uint8Array(MIN_READ);\n        while (true) {\n            const shouldGrow = this.capacity - this.length < MIN_READ;\n            // read into tmp buffer if there's not enough room\n            // otherwise read directly into the internal buffer\n            const buf = shouldGrow\n                ? tmp\n                : new Uint8Array(this._buf.buffer, this.length);\n            const nread = r.read(buf);\n            if (nread === null) {\n                return n;\n            }\n            // write will grow if needed\n            if (shouldGrow)\n                this.write(buf.subarray(0, nread));\n            else\n                this._reslice(this.length + nread);\n            n += nread;\n        }\n    }\n}\nexports.DenoBuffer = DenoBuffer;\nfunction readAll(r) {\n    const buf = new DenoBuffer();\n    buf.readFrom(r);\n    return buf.bytes();\n}\nexports.readAll = readAll;\nfunction writeAll(w, arr) {\n    let nwritten = 0;\n    while (nwritten < arr.length) {\n        nwritten += w.write(arr.subarray(nwritten));\n    }\n}\nexports.writeAll = writeAll;\n//# sourceMappingURL=denobuffer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9kZW5vYnVmZmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYyxHQUFHLHNCQUFzQjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L2Rlbm9idWZmZXIuanM/NzYyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8vIENvcHlyaWdodCAyMDE4LTIwMjEgdGhlIERlbm8gYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIGxpY2Vuc2UuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndyaXRlQWxsID0gZXhwb3J0cy5yZWFkQWxsID0gZXhwb3J0cy5EZW5vQnVmZmVyID0gZXhwb3J0cy5hcHBlbmQgPSBleHBvcnRzLmNvbmNhdCA9IGV4cG9ydHMuTUFYX1NJWkUgPSBleHBvcnRzLmFzc2VydCA9IGV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSB2b2lkIDA7XG4vLyBUaGlzIGNvZGUgaGFzIGJlZW4gcG9ydGVkIGFsbW9zdCBkaXJlY3RseSBmcm9tIEdvJ3Mgc3JjL2J5dGVzL2J1ZmZlci5nb1xuLy8gQ29weXJpZ2h0IDIwMDkgVGhlIEdvIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEJTRCBsaWNlbnNlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9ibG9iL21hc3Rlci9MSUNFTlNFXG4vLyBUaGlzIGNvZGUgcmVtb3ZlcyBhbGwgRGVubyBzcGVjaWZpYyBmdW5jdGlvbmFsaXR5IHRvIGVuYWJsZSBpdHMgdXNlXG4vLyBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnRcbi8vQGludGVybmFsXG5jb25zdCBlbmNvZGVyc18xID0gcmVxdWlyZShcIi4vZW5jb2RlcnNcIik7XG5jbGFzcyBBc3NlcnRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJBc3NlcnRpb25FcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydHMuQXNzZXJ0aW9uRXJyb3IgPSBBc3NlcnRpb25FcnJvcjtcbi8vIEBpbnRlcm5hbFxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZyA9IFwiQXNzZXJ0aW9uIGZhaWxlZC5cIikge1xuICAgIGlmICghY29uZCkge1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRXJyb3IobXNnKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbi8vIE1JTl9SRUFEIGlzIHRoZSBtaW5pbXVtIEFycmF5QnVmZmVyIHNpemUgcGFzc2VkIHRvIGEgcmVhZCBjYWxsIGJ5XG4vLyBidWZmZXIuUmVhZEZyb20uIEFzIGxvbmcgYXMgdGhlIEJ1ZmZlciBoYXMgYXQgbGVhc3QgTUlOX1JFQUQgYnl0ZXMgYmV5b25kXG4vLyB3aGF0IGlzIHJlcXVpcmVkIHRvIGhvbGQgdGhlIGNvbnRlbnRzIG9mIHIsIHJlYWRGcm9tKCkgd2lsbCBub3QgZ3JvdyB0aGVcbi8vIHVuZGVybHlpbmcgYnVmZmVyLlxuY29uc3QgTUlOX1JFQUQgPSAzMiAqIDEwMjQ7XG5leHBvcnRzLk1BWF9TSVpFID0gTWF0aC5wb3coMiwgMzIpIC0gMjtcbi8vIGBvZmZgIGlzIHRoZSBvZmZzZXQgaW50byBgZHN0YCB3aGVyZSBpdCB3aWxsIGF0IHdoaWNoIHRvIGJlZ2luIHdyaXRpbmcgdmFsdWVzXG4vLyBmcm9tIGBzcmNgLlxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGJ5dGVzIGNvcGllZC5cbmZ1bmN0aW9uIGNvcHkoc3JjLCBkc3QsIG9mZiA9IDApIHtcbiAgICBjb25zdCByID0gZHN0LmJ5dGVMZW5ndGggLSBvZmY7XG4gICAgaWYgKHNyYy5ieXRlTGVuZ3RoID4gcikge1xuICAgICAgICBzcmMgPSBzcmMuc3ViYXJyYXkoMCwgcik7XG4gICAgfVxuICAgIGRzdC5zZXQoc3JjLCBvZmYpO1xuICAgIHJldHVybiBzcmMuYnl0ZUxlbmd0aDtcbn1cbmZ1bmN0aW9uIGNvbmNhdChvcmlnaW4sIGIpIHtcbiAgICBpZiAob3JpZ2luID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgaWYgKG9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cbiAgICBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW47XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KG9yaWdpbi5sZW5ndGggKyBiLmxlbmd0aCk7XG4gICAgb3V0cHV0LnNldChvcmlnaW4sIDApO1xuICAgIG91dHB1dC5zZXQoYiwgb3JpZ2luLmxlbmd0aCk7XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbmV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuZnVuY3Rpb24gYXBwZW5kKG9yaWdpbiwgYikge1xuICAgIHJldHVybiBjb25jYXQob3JpZ2luLCBVaW50OEFycmF5Lm9mKGIpKTtcbn1cbmV4cG9ydHMuYXBwZW5kID0gYXBwZW5kO1xuY2xhc3MgRGVub0J1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoYWIpIHtcbiAgICAgICAgdGhpcy5fb2ZmID0gMDtcbiAgICAgICAgaWYgKGFiID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZiA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZiA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICB9XG4gICAgYnl0ZXMob3B0aW9ucyA9IHsgY29weTogdHJ1ZSB9KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcHkgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J1Zi5zdWJhcnJheSh0aGlzLl9vZmYpO1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmLnNsaWNlKHRoaXMuX29mZik7XG4gICAgfVxuICAgIGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmLmJ5dGVMZW5ndGggPD0gdGhpcy5fb2ZmO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmLmJ5dGVMZW5ndGggLSB0aGlzLl9vZmY7XG4gICAgfVxuICAgIGdldCBjYXBhY2l0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1Zi5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgdHJ1bmNhdGUobikge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuIDwgMCB8fCBuID4gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiYnl0ZXMuQnVmZmVyOiB0cnVuY2F0aW9uIG91dCBvZiByYW5nZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNsaWNlKHRoaXMuX29mZiArIG4pO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fcmVzbGljZSgwKTtcbiAgICAgICAgdGhpcy5fb2ZmID0gMDtcbiAgICB9XG4gICAgX3RyeUdyb3dCeVJlc2xpY2Uobikge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5fYnVmLmJ5dGVMZW5ndGg7XG4gICAgICAgIGlmIChuIDw9IHRoaXMuY2FwYWNpdHkgLSBsKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNsaWNlKGwgKyBuKTtcbiAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgX3Jlc2xpY2UobGVuKSB7XG4gICAgICAgIGFzc2VydChsZW4gPD0gdGhpcy5fYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fYnVmLmJ1ZmZlciwgMCwgbGVuKTtcbiAgICB9XG4gICAgcmVhZEJ5dGUoKSB7XG4gICAgICAgIGNvbnN0IGEgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgICAgaWYgKHRoaXMucmVhZChhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlYWQocCkge1xuICAgICAgICBpZiAodGhpcy5lbXB0eSgpKSB7XG4gICAgICAgICAgICAvLyBCdWZmZXIgaXMgZW1wdHksIHJlc2V0IHRvIHJlY292ZXIgc3BhY2UuXG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICBpZiAocC5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBlZGdlIGNhc2UgaXMgdGVzdGVkIGluICdidWZmZXJSZWFkRW1wdHlBdEVPRicgdGVzdFxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbnJlYWQgPSBjb3B5KHRoaXMuX2J1Zi5zdWJhcnJheSh0aGlzLl9vZmYpLCBwKTtcbiAgICAgICAgdGhpcy5fb2ZmICs9IG5yZWFkO1xuICAgICAgICByZXR1cm4gbnJlYWQ7XG4gICAgfVxuICAgIHdyaXRlQnl0ZShuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlKFVpbnQ4QXJyYXkub2YobikpO1xuICAgIH1cbiAgICB3cml0ZVN0cmluZyhzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlKGVuY29kZXJzXzEuVEUuZW5jb2RlKHMpKTtcbiAgICB9XG4gICAgd3JpdGUocCkge1xuICAgICAgICBjb25zdCBtID0gdGhpcy5fZ3JvdyhwLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gY29weShwLCB0aGlzLl9idWYsIG0pO1xuICAgIH1cbiAgICBfZ3JvdyhuKSB7XG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgLy8gSWYgYnVmZmVyIGlzIGVtcHR5LCByZXNldCB0byByZWNvdmVyIHNwYWNlLlxuICAgICAgICBpZiAobSA9PT0gMCAmJiB0aGlzLl9vZmYgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYXN0OiBUcnkgdG8gX2dyb3cgYnkgbWVhbnMgb2YgYSBfcmVzbGljZS5cbiAgICAgICAgY29uc3QgaSA9IHRoaXMuX3RyeUdyb3dCeVJlc2xpY2Uobik7XG4gICAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmNhcGFjaXR5O1xuICAgICAgICBpZiAobiA8PSBNYXRoLmZsb29yKGMgLyAyKSAtIG0pIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBzbGlkZSB0aGluZ3MgZG93biBpbnN0ZWFkIG9mIGFsbG9jYXRpbmcgYSBuZXdcbiAgICAgICAgICAgIC8vIEFycmF5QnVmZmVyLiBXZSBvbmx5IG5lZWQgbStuIDw9IGMgdG8gc2xpZGUsIGJ1dFxuICAgICAgICAgICAgLy8gd2UgaW5zdGVhZCBsZXQgY2FwYWNpdHkgZ2V0IHR3aWNlIGFzIGxhcmdlIHNvIHdlXG4gICAgICAgICAgICAvLyBkb24ndCBzcGVuZCBhbGwgb3VyIHRpbWUgY29weWluZy5cbiAgICAgICAgICAgIGNvcHkodGhpcy5fYnVmLnN1YmFycmF5KHRoaXMuX29mZiksIHRoaXMuX2J1Zik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyArIG4gPiBleHBvcnRzLk1BWF9TSVpFKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYnVmZmVyIGNhbm5vdCBiZSBncm93biBiZXlvbmQgdGhlIG1heGltdW0gc2l6ZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3QgZW5vdWdoIHNwYWNlIGFueXdoZXJlLCB3ZSBuZWVkIHRvIGFsbG9jYXRlLlxuICAgICAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5taW4oMiAqIGMgKyBuLCBleHBvcnRzLk1BWF9TSVpFKSk7XG4gICAgICAgICAgICBjb3B5KHRoaXMuX2J1Zi5zdWJhcnJheSh0aGlzLl9vZmYpLCBidWYpO1xuICAgICAgICAgICAgdGhpcy5fYnVmID0gYnVmO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3RvcmUgdGhpcy5vZmYgYW5kIGxlbih0aGlzLl9idWYpLlxuICAgICAgICB0aGlzLl9vZmYgPSAwO1xuICAgICAgICB0aGlzLl9yZXNsaWNlKE1hdGgubWluKG0gKyBuLCBleHBvcnRzLk1BWF9TSVpFKSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICBncm93KG4pIHtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJ1ZmZlci5fZ3JvdzogbmVnYXRpdmUgY291bnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX2dyb3cobik7XG4gICAgICAgIHRoaXMuX3Jlc2xpY2UobSk7XG4gICAgfVxuICAgIHJlYWRGcm9tKHIpIHtcbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBjb25zdCB0bXAgPSBuZXcgVWludDhBcnJheShNSU5fUkVBRCk7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRHcm93ID0gdGhpcy5jYXBhY2l0eSAtIHRoaXMubGVuZ3RoIDwgTUlOX1JFQUQ7XG4gICAgICAgICAgICAvLyByZWFkIGludG8gdG1wIGJ1ZmZlciBpZiB0aGVyZSdzIG5vdCBlbm91Z2ggcm9vbVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHJlYWQgZGlyZWN0bHkgaW50byB0aGUgaW50ZXJuYWwgYnVmZmVyXG4gICAgICAgICAgICBjb25zdCBidWYgPSBzaG91bGRHcm93XG4gICAgICAgICAgICAgICAgPyB0bXBcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHRoaXMuX2J1Zi5idWZmZXIsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IG5yZWFkID0gci5yZWFkKGJ1Zik7XG4gICAgICAgICAgICBpZiAobnJlYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdyaXRlIHdpbGwgZ3JvdyBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChzaG91bGRHcm93KVxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGUoYnVmLnN1YmFycmF5KDAsIG5yZWFkKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzbGljZSh0aGlzLmxlbmd0aCArIG5yZWFkKTtcbiAgICAgICAgICAgIG4gKz0gbnJlYWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkRlbm9CdWZmZXIgPSBEZW5vQnVmZmVyO1xuZnVuY3Rpb24gcmVhZEFsbChyKSB7XG4gICAgY29uc3QgYnVmID0gbmV3IERlbm9CdWZmZXIoKTtcbiAgICBidWYucmVhZEZyb20ocik7XG4gICAgcmV0dXJuIGJ1Zi5ieXRlcygpO1xufVxuZXhwb3J0cy5yZWFkQWxsID0gcmVhZEFsbDtcbmZ1bmN0aW9uIHdyaXRlQWxsKHcsIGFycikge1xuICAgIGxldCBud3JpdHRlbiA9IDA7XG4gICAgd2hpbGUgKG53cml0dGVuIDwgYXJyLmxlbmd0aCkge1xuICAgICAgICBud3JpdHRlbiArPSB3LndyaXRlKGFyci5zdWJhcnJheShud3JpdHRlbikpO1xuICAgIH1cbn1cbmV4cG9ydHMud3JpdGVBbGwgPSB3cml0ZUFsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlbm9idWZmZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/denobuffer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js":
/*!************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/encoders.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = exports.encode = exports.TD = exports.TE = exports.Empty = void 0;\n/*\n * Copyright 2020 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexports.Empty = new Uint8Array(0);\nexports.TE = new TextEncoder();\nexports.TD = new TextDecoder();\nfunction concat(...bufs) {\n    let max = 0;\n    for (let i = 0; i < bufs.length; i++) {\n        max += bufs[i].length;\n    }\n    const out = new Uint8Array(max);\n    let index = 0;\n    for (let i = 0; i < bufs.length; i++) {\n        out.set(bufs[i], index);\n        index += bufs[i].length;\n    }\n    return out;\n}\nfunction encode(...a) {\n    const bufs = [];\n    for (let i = 0; i < a.length; i++) {\n        bufs.push(exports.TE.encode(a[i]));\n    }\n    if (bufs.length === 0) {\n        return exports.Empty;\n    }\n    if (bufs.length === 1) {\n        return bufs[0];\n    }\n    return concat(...bufs);\n}\nexports.encode = encode;\nfunction decode(a) {\n    if (!a || a.length === 0) {\n        return \"\";\n    }\n    return exports.TD.decode(a);\n}\nexports.decode = decode;\n//# sourceMappingURL=encoders.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9lbmNvZGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLFVBQVUsR0FBRyxVQUFVLEdBQUcsYUFBYTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVixVQUFVO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9lbmNvZGVycy5qcz9jYTE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuVEQgPSBleHBvcnRzLlRFID0gZXhwb3J0cy5FbXB0eSA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0cy5FbXB0eSA9IG5ldyBVaW50OEFycmF5KDApO1xuZXhwb3J0cy5URSA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZXhwb3J0cy5URCA9IG5ldyBUZXh0RGVjb2RlcigpO1xuZnVuY3Rpb24gY29uY2F0KC4uLmJ1ZnMpIHtcbiAgICBsZXQgbWF4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWF4ICs9IGJ1ZnNbaV0ubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheShtYXgpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG91dC5zZXQoYnVmc1tpXSwgaW5kZXgpO1xuICAgICAgICBpbmRleCArPSBidWZzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uIGVuY29kZSguLi5hKSB7XG4gICAgY29uc3QgYnVmcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWZzLnB1c2goZXhwb3J0cy5URS5lbmNvZGUoYVtpXSkpO1xuICAgIH1cbiAgICBpZiAoYnVmcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuRW1wdHk7XG4gICAgfVxuICAgIGlmIChidWZzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYnVmc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdCguLi5idWZzKTtcbn1cbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZnVuY3Rpb24gZGVjb2RlKGEpIHtcbiAgICBpZiAoIWEgfHwgYS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLlRELmRlY29kZShhKTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5jb2RlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/headers.js":
/*!***********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/headers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsgHdrsImpl = exports.headers = exports.canonicalMIMEHeaderKey = void 0;\n// Heavily inspired by Golang's https://golang.org/src/net/http/header.go\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\n// https://www.ietf.org/rfc/rfc822.txt\n// 3.1.2.  STRUCTURE OF HEADER FIELDS\n//\n// Once a field has been unfolded, it may be viewed as being com-\n// posed of a field-name followed by a colon (\":\"), followed by a\n// field-body, and  terminated  by  a  carriage-return/line-feed.\n// The  field-name must be composed of printable ASCII characters\n// (i.e., characters that  have  values  between  33.  and  126.,\n// decimal, except colon).  The field-body may be composed of any\n// ASCII characters, except CR or LF.  (While CR and/or LF may be\n// present  in the actual text, they are removed by the action of\n// unfolding the field.)\nfunction canonicalMIMEHeaderKey(k) {\n    const a = 97;\n    const A = 65;\n    const Z = 90;\n    const z = 122;\n    const dash = 45;\n    const colon = 58;\n    const start = 33;\n    const end = 126;\n    const toLower = a - A;\n    let upper = true;\n    const buf = new Array(k.length);\n    for (let i = 0; i < k.length; i++) {\n        let c = k.charCodeAt(i);\n        if (c === colon || c < start || c > end) {\n            throw new core_1.NatsError(`'${k[i]}' is not a valid character for a header key`, core_1.ErrorCode.BadHeader);\n        }\n        if (upper && a <= c && c <= z) {\n            c -= toLower;\n        }\n        else if (!upper && A <= c && c <= Z) {\n            c += toLower;\n        }\n        buf[i] = c;\n        upper = c == dash;\n    }\n    return String.fromCharCode(...buf);\n}\nexports.canonicalMIMEHeaderKey = canonicalMIMEHeaderKey;\nfunction headers(code = 0, description = \"\") {\n    if ((code === 0 && description !== \"\") || (code > 0 && description === \"\")) {\n        throw new Error(\"setting status requires both code and description\");\n    }\n    return new MsgHdrsImpl(code, description);\n}\nexports.headers = headers;\nconst HEADER = \"NATS/1.0\";\nclass MsgHdrsImpl {\n    constructor(code = 0, description = \"\") {\n        this._code = code;\n        this._description = description;\n        this.headers = new Map();\n    }\n    [Symbol.iterator]() {\n        return this.headers.entries();\n    }\n    size() {\n        return this.headers.size;\n    }\n    equals(mh) {\n        if (mh && this.headers.size === mh.headers.size &&\n            this._code === mh._code) {\n            for (const [k, v] of this.headers) {\n                const a = mh.values(k);\n                if (v.length !== a.length) {\n                    return false;\n                }\n                const vv = [...v].sort();\n                const aa = [...a].sort();\n                for (let i = 0; i < vv.length; i++) {\n                    if (vv[i] !== aa[i]) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    static decode(a) {\n        const mh = new MsgHdrsImpl();\n        const s = encoders_1.TD.decode(a);\n        const lines = s.split(\"\\r\\n\");\n        const h = lines[0];\n        if (h !== HEADER) {\n            // malformed headers could add extra space without adding a code or description\n            let str = h.replace(HEADER, \"\").trim();\n            if (str.length > 0) {\n                mh._code = parseInt(str, 10);\n                if (isNaN(mh._code)) {\n                    mh._code = 0;\n                }\n                const scode = mh._code.toString();\n                str = str.replace(scode, \"\");\n                mh._description = str.trim();\n            }\n        }\n        if (lines.length >= 1) {\n            lines.slice(1).map((s) => {\n                if (s) {\n                    const idx = s.indexOf(\":\");\n                    if (idx > -1) {\n                        const k = s.slice(0, idx);\n                        const v = s.slice(idx + 1).trim();\n                        mh.append(k, v);\n                    }\n                }\n            });\n        }\n        return mh;\n    }\n    toString() {\n        if (this.headers.size === 0 && this._code === 0) {\n            return \"\";\n        }\n        let s = HEADER;\n        if (this._code > 0 && this._description !== \"\") {\n            s += ` ${this._code} ${this._description}`;\n        }\n        for (const [k, v] of this.headers) {\n            for (let i = 0; i < v.length; i++) {\n                s = `${s}\\r\\n${k}: ${v[i]}`;\n            }\n        }\n        return `${s}\\r\\n\\r\\n`;\n    }\n    encode() {\n        return encoders_1.TE.encode(this.toString());\n    }\n    static validHeaderValue(k) {\n        const inv = /[\\r\\n]/;\n        if (inv.test(k)) {\n            throw new core_1.NatsError(\"invalid header value - \\\\r and \\\\n are not allowed.\", core_1.ErrorCode.BadHeader);\n        }\n        return k.trim();\n    }\n    keys() {\n        const keys = [];\n        for (const sk of this.headers.keys()) {\n            keys.push(sk);\n        }\n        return keys;\n    }\n    findKeys(k, match = core_1.Match.Exact) {\n        const keys = this.keys();\n        switch (match) {\n            case core_1.Match.Exact:\n                return keys.filter((v) => {\n                    return v === k;\n                });\n            case core_1.Match.CanonicalMIME:\n                k = canonicalMIMEHeaderKey(k);\n                return keys.filter((v) => {\n                    return v === k;\n                });\n            default: {\n                const lci = k.toLowerCase();\n                return keys.filter((v) => {\n                    return lci === v.toLowerCase();\n                });\n            }\n        }\n    }\n    get(k, match = core_1.Match.Exact) {\n        const keys = this.findKeys(k, match);\n        if (keys.length) {\n            const v = this.headers.get(keys[0]);\n            if (v) {\n                return Array.isArray(v) ? v[0] : v;\n            }\n        }\n        return \"\";\n    }\n    last(k, match = core_1.Match.Exact) {\n        const keys = this.findKeys(k, match);\n        if (keys.length) {\n            const v = this.headers.get(keys[0]);\n            if (v) {\n                return Array.isArray(v) ? v[v.length - 1] : v;\n            }\n        }\n        return \"\";\n    }\n    has(k, match = core_1.Match.Exact) {\n        return this.findKeys(k, match).length > 0;\n    }\n    set(k, v, match = core_1.Match.Exact) {\n        this.delete(k, match);\n        this.append(k, v, match);\n    }\n    append(k, v, match = core_1.Match.Exact) {\n        // validate the key\n        const ck = canonicalMIMEHeaderKey(k);\n        if (match === core_1.Match.CanonicalMIME) {\n            k = ck;\n        }\n        // if we get non-sensical ignores/etc, we should try\n        // to do the right thing and use the first key that matches\n        const keys = this.findKeys(k, match);\n        k = keys.length > 0 ? keys[0] : k;\n        const value = MsgHdrsImpl.validHeaderValue(v);\n        let a = this.headers.get(k);\n        if (!a) {\n            a = [];\n            this.headers.set(k, a);\n        }\n        a.push(value);\n    }\n    values(k, match = core_1.Match.Exact) {\n        const buf = [];\n        const keys = this.findKeys(k, match);\n        keys.forEach((v) => {\n            const values = this.headers.get(v);\n            if (values) {\n                buf.push(...values);\n            }\n        });\n        return buf;\n    }\n    delete(k, match = core_1.Match.Exact) {\n        const keys = this.findKeys(k, match);\n        keys.forEach((v) => {\n            this.headers.delete(v);\n        });\n    }\n    get hasError() {\n        return this._code >= 300;\n    }\n    get status() {\n        return `${this._code} ${this._description}`.trim();\n    }\n    toRecord() {\n        const data = {};\n        this.keys().forEach((v) => {\n            data[v] = this.values(v);\n        });\n        return data;\n    }\n    get code() {\n        return this._code;\n    }\n    get description() {\n        return this._description;\n    }\n    static fromRecord(r) {\n        const h = new MsgHdrsImpl();\n        for (const k in r) {\n            h.headers.set(k, r[k]);\n        }\n        return h;\n    }\n}\nexports.MsgHdrsImpl = MsgHdrsImpl;\n//# sourceMappingURL=headers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9oZWFkZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsOEJBQThCO0FBQ3RFO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsOEVBQVk7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQSwyQ0FBMkMsS0FBSztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWSxFQUFFLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUMsdUJBQXVCLEVBQUUsTUFBTSxFQUFFLElBQUksS0FBSztBQUMxQztBQUNBO0FBQ0Esa0JBQWtCLEVBQUU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWSxFQUFFLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9oZWFkZXJzLmpzP2IyM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAtMjAyMyBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Nc2dIZHJzSW1wbCA9IGV4cG9ydHMuaGVhZGVycyA9IGV4cG9ydHMuY2Fub25pY2FsTUlNRUhlYWRlcktleSA9IHZvaWQgMDtcbi8vIEhlYXZpbHkgaW5zcGlyZWQgYnkgR29sYW5nJ3MgaHR0cHM6Ly9nb2xhbmcub3JnL3NyYy9uZXQvaHR0cC9oZWFkZXIuZ29cbmNvbnN0IGVuY29kZXJzXzEgPSByZXF1aXJlKFwiLi9lbmNvZGVyc1wiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG4vLyBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjODIyLnR4dFxuLy8gMy4xLjIuICBTVFJVQ1RVUkUgT0YgSEVBREVSIEZJRUxEU1xuLy9cbi8vIE9uY2UgYSBmaWVsZCBoYXMgYmVlbiB1bmZvbGRlZCwgaXQgbWF5IGJlIHZpZXdlZCBhcyBiZWluZyBjb20tXG4vLyBwb3NlZCBvZiBhIGZpZWxkLW5hbWUgZm9sbG93ZWQgYnkgYSBjb2xvbiAoXCI6XCIpLCBmb2xsb3dlZCBieSBhXG4vLyBmaWVsZC1ib2R5LCBhbmQgIHRlcm1pbmF0ZWQgIGJ5ICBhICBjYXJyaWFnZS1yZXR1cm4vbGluZS1mZWVkLlxuLy8gVGhlICBmaWVsZC1uYW1lIG11c3QgYmUgY29tcG9zZWQgb2YgcHJpbnRhYmxlIEFTQ0lJIGNoYXJhY3RlcnNcbi8vIChpLmUuLCBjaGFyYWN0ZXJzIHRoYXQgIGhhdmUgIHZhbHVlcyAgYmV0d2VlbiAgMzMuICBhbmQgIDEyNi4sXG4vLyBkZWNpbWFsLCBleGNlcHQgY29sb24pLiAgVGhlIGZpZWxkLWJvZHkgbWF5IGJlIGNvbXBvc2VkIG9mIGFueVxuLy8gQVNDSUkgY2hhcmFjdGVycywgZXhjZXB0IENSIG9yIExGLiAgKFdoaWxlIENSIGFuZC9vciBMRiBtYXkgYmVcbi8vIHByZXNlbnQgIGluIHRoZSBhY3R1YWwgdGV4dCwgdGhleSBhcmUgcmVtb3ZlZCBieSB0aGUgYWN0aW9uIG9mXG4vLyB1bmZvbGRpbmcgdGhlIGZpZWxkLilcbmZ1bmN0aW9uIGNhbm9uaWNhbE1JTUVIZWFkZXJLZXkoaykge1xuICAgIGNvbnN0IGEgPSA5NztcbiAgICBjb25zdCBBID0gNjU7XG4gICAgY29uc3QgWiA9IDkwO1xuICAgIGNvbnN0IHogPSAxMjI7XG4gICAgY29uc3QgZGFzaCA9IDQ1O1xuICAgIGNvbnN0IGNvbG9uID0gNTg7XG4gICAgY29uc3Qgc3RhcnQgPSAzMztcbiAgICBjb25zdCBlbmQgPSAxMjY7XG4gICAgY29uc3QgdG9Mb3dlciA9IGEgLSBBO1xuICAgIGxldCB1cHBlciA9IHRydWU7XG4gICAgY29uc3QgYnVmID0gbmV3IEFycmF5KGsubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSBrLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjID09PSBjb2xvbiB8fCBjIDwgc3RhcnQgfHwgYyA+IGVuZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfMS5OYXRzRXJyb3IoYCcke2tbaV19JyBpcyBub3QgYSB2YWxpZCBjaGFyYWN0ZXIgZm9yIGEgaGVhZGVyIGtleWAsIGNvcmVfMS5FcnJvckNvZGUuQmFkSGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBwZXIgJiYgYSA8PSBjICYmIGMgPD0geikge1xuICAgICAgICAgICAgYyAtPSB0b0xvd2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF1cHBlciAmJiBBIDw9IGMgJiYgYyA8PSBaKSB7XG4gICAgICAgICAgICBjICs9IHRvTG93ZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnVmW2ldID0gYztcbiAgICAgICAgdXBwZXIgPSBjID09IGRhc2g7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmJ1Zik7XG59XG5leHBvcnRzLmNhbm9uaWNhbE1JTUVIZWFkZXJLZXkgPSBjYW5vbmljYWxNSU1FSGVhZGVyS2V5O1xuZnVuY3Rpb24gaGVhZGVycyhjb2RlID0gMCwgZGVzY3JpcHRpb24gPSBcIlwiKSB7XG4gICAgaWYgKChjb2RlID09PSAwICYmIGRlc2NyaXB0aW9uICE9PSBcIlwiKSB8fCAoY29kZSA+IDAgJiYgZGVzY3JpcHRpb24gPT09IFwiXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldHRpbmcgc3RhdHVzIHJlcXVpcmVzIGJvdGggY29kZSBhbmQgZGVzY3JpcHRpb25cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTXNnSGRyc0ltcGwoY29kZSwgZGVzY3JpcHRpb24pO1xufVxuZXhwb3J0cy5oZWFkZXJzID0gaGVhZGVycztcbmNvbnN0IEhFQURFUiA9IFwiTkFUUy8xLjBcIjtcbmNsYXNzIE1zZ0hkcnNJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlID0gMCwgZGVzY3JpcHRpb24gPSBcIlwiKSB7XG4gICAgICAgIHRoaXMuX2NvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLl9kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXJzLmVudHJpZXMoKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVycy5zaXplO1xuICAgIH1cbiAgICBlcXVhbHMobWgpIHtcbiAgICAgICAgaWYgKG1oICYmIHRoaXMuaGVhZGVycy5zaXplID09PSBtaC5oZWFkZXJzLnNpemUgJiZcbiAgICAgICAgICAgIHRoaXMuX2NvZGUgPT09IG1oLl9jb2RlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB0aGlzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhID0gbWgudmFsdWVzKGspO1xuICAgICAgICAgICAgICAgIGlmICh2Lmxlbmd0aCAhPT0gYS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2diA9IFsuLi52XS5zb3J0KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWEgPSBbLi4uYV0uc29ydCgpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdnYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZ2W2ldICE9PSBhYVtpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgZGVjb2RlKGEpIHtcbiAgICAgICAgY29uc3QgbWggPSBuZXcgTXNnSGRyc0ltcGwoKTtcbiAgICAgICAgY29uc3QgcyA9IGVuY29kZXJzXzEuVEQuZGVjb2RlKGEpO1xuICAgICAgICBjb25zdCBsaW5lcyA9IHMuc3BsaXQoXCJcXHJcXG5cIik7XG4gICAgICAgIGNvbnN0IGggPSBsaW5lc1swXTtcbiAgICAgICAgaWYgKGggIT09IEhFQURFUikge1xuICAgICAgICAgICAgLy8gbWFsZm9ybWVkIGhlYWRlcnMgY291bGQgYWRkIGV4dHJhIHNwYWNlIHdpdGhvdXQgYWRkaW5nIGEgY29kZSBvciBkZXNjcmlwdGlvblxuICAgICAgICAgICAgbGV0IHN0ciA9IGgucmVwbGFjZShIRUFERVIsIFwiXCIpLnRyaW0oKTtcbiAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1oLl9jb2RlID0gcGFyc2VJbnQoc3RyLCAxMCk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKG1oLl9jb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBtaC5fY29kZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjb2RlID0gbWguX2NvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZShzY29kZSwgXCJcIik7XG4gICAgICAgICAgICAgICAgbWguX2Rlc2NyaXB0aW9uID0gc3RyLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZXMubGVuZ3RoID49IDEpIHtcbiAgICAgICAgICAgIGxpbmVzLnNsaWNlKDEpLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHMuaW5kZXhPZihcIjpcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgayA9IHMuc2xpY2UoMCwgaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzLnNsaWNlKGlkeCArIDEpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1oLmFwcGVuZChrLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYWRlcnMuc2l6ZSA9PT0gMCAmJiB0aGlzLl9jb2RlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcyA9IEhFQURFUjtcbiAgICAgICAgaWYgKHRoaXMuX2NvZGUgPiAwICYmIHRoaXMuX2Rlc2NyaXB0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBzICs9IGAgJHt0aGlzLl9jb2RlfSAke3RoaXMuX2Rlc2NyaXB0aW9ufWA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdGhpcy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzID0gYCR7c31cXHJcXG4ke2t9OiAke3ZbaV19YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7c31cXHJcXG5cXHJcXG5gO1xuICAgIH1cbiAgICBlbmNvZGUoKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVyc18xLlRFLmVuY29kZSh0aGlzLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBzdGF0aWMgdmFsaWRIZWFkZXJWYWx1ZShrKSB7XG4gICAgICAgIGNvbnN0IGludiA9IC9bXFxyXFxuXS87XG4gICAgICAgIGlmIChpbnYudGVzdChrKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfMS5OYXRzRXJyb3IoXCJpbnZhbGlkIGhlYWRlciB2YWx1ZSAtIFxcXFxyIGFuZCBcXFxcbiBhcmUgbm90IGFsbG93ZWQuXCIsIGNvcmVfMS5FcnJvckNvZGUuQmFkSGVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gay50cmltKCk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzayBvZiB0aGlzLmhlYWRlcnMua2V5cygpKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goc2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbiAgICBmaW5kS2V5cyhrLCBtYXRjaCA9IGNvcmVfMS5NYXRjaC5FeGFjdCkge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5rZXlzKCk7XG4gICAgICAgIHN3aXRjaCAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLk1hdGNoLkV4YWN0OlxuICAgICAgICAgICAgICAgIHJldHVybiBrZXlzLmZpbHRlcigodikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdiA9PT0gaztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgY29yZV8xLk1hdGNoLkNhbm9uaWNhbE1JTUU6XG4gICAgICAgICAgICAgICAgayA9IGNhbm9uaWNhbE1JTUVIZWFkZXJLZXkoayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZmlsdGVyKCh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2ID09PSBrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxjaSA9IGsudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5maWx0ZXIoKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxjaSA9PT0gdi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldChrLCBtYXRjaCA9IGNvcmVfMS5NYXRjaC5FeGFjdCkge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5maW5kS2V5cyhrLCBtYXRjaCk7XG4gICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuaGVhZGVycy5nZXQoa2V5c1swXSk7XG4gICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpID8gdlswXSA6IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGxhc3QoaywgbWF0Y2ggPSBjb3JlXzEuTWF0Y2guRXhhY3QpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZmluZEtleXMoaywgbWF0Y2gpO1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLmhlYWRlcnMuZ2V0KGtleXNbMF0pO1xuICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSA/IHZbdi5sZW5ndGggLSAxXSA6IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGhhcyhrLCBtYXRjaCA9IGNvcmVfMS5NYXRjaC5FeGFjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kS2V5cyhrLCBtYXRjaCkubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgc2V0KGssIHYsIG1hdGNoID0gY29yZV8xLk1hdGNoLkV4YWN0KSB7XG4gICAgICAgIHRoaXMuZGVsZXRlKGssIG1hdGNoKTtcbiAgICAgICAgdGhpcy5hcHBlbmQoaywgdiwgbWF0Y2gpO1xuICAgIH1cbiAgICBhcHBlbmQoaywgdiwgbWF0Y2ggPSBjb3JlXzEuTWF0Y2guRXhhY3QpIHtcbiAgICAgICAgLy8gdmFsaWRhdGUgdGhlIGtleVxuICAgICAgICBjb25zdCBjayA9IGNhbm9uaWNhbE1JTUVIZWFkZXJLZXkoayk7XG4gICAgICAgIGlmIChtYXRjaCA9PT0gY29yZV8xLk1hdGNoLkNhbm9uaWNhbE1JTUUpIHtcbiAgICAgICAgICAgIGsgPSBjaztcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBnZXQgbm9uLXNlbnNpY2FsIGlnbm9yZXMvZXRjLCB3ZSBzaG91bGQgdHJ5XG4gICAgICAgIC8vIHRvIGRvIHRoZSByaWdodCB0aGluZyBhbmQgdXNlIHRoZSBmaXJzdCBrZXkgdGhhdCBtYXRjaGVzXG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLmZpbmRLZXlzKGssIG1hdGNoKTtcbiAgICAgICAgayA9IGtleXMubGVuZ3RoID4gMCA/IGtleXNbMF0gOiBrO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IE1zZ0hkcnNJbXBsLnZhbGlkSGVhZGVyVmFsdWUodik7XG4gICAgICAgIGxldCBhID0gdGhpcy5oZWFkZXJzLmdldChrKTtcbiAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KGssIGEpO1xuICAgICAgICB9XG4gICAgICAgIGEucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHZhbHVlcyhrLCBtYXRjaCA9IGNvcmVfMS5NYXRjaC5FeGFjdCkge1xuICAgICAgICBjb25zdCBidWYgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuZmluZEtleXMoaywgbWF0Y2gpO1xuICAgICAgICBrZXlzLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuaGVhZGVycy5nZXQodik7XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgYnVmLnB1c2goLi4udmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIGRlbGV0ZShrLCBtYXRjaCA9IGNvcmVfMS5NYXRjaC5FeGFjdCkge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5maW5kS2V5cyhrLCBtYXRjaCk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLmRlbGV0ZSh2KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBoYXNFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvZGUgPj0gMzAwO1xuICAgIH1cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5fY29kZX0gJHt0aGlzLl9kZXNjcmlwdGlvbn1gLnRyaW0oKTtcbiAgICB9XG4gICAgdG9SZWNvcmQoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5rZXlzKCkuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgZGF0YVt2XSA9IHRoaXMudmFsdWVzKHYpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGdldCBjb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29kZTtcbiAgICB9XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVzY3JpcHRpb247XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUmVjb3JkKHIpIHtcbiAgICAgICAgY29uc3QgaCA9IG5ldyBNc2dIZHJzSW1wbCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gcikge1xuICAgICAgICAgICAgaC5oZWFkZXJzLnNldChrLCByW2tdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaDtcbiAgICB9XG59XG5leHBvcnRzLk1zZ0hkcnNJbXBsID0gTXNnSGRyc0ltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFkZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/headers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/heartbeats.js":
/*!**************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/heartbeats.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Heartbeat = void 0;\n/*\n * Copyright 2020-2021 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nclass Heartbeat {\n    constructor(ph, interval, maxOut) {\n        this.ph = ph;\n        this.interval = interval;\n        this.maxOut = maxOut;\n        this.pendings = [];\n    }\n    // api to start the heartbeats, since this can be\n    // spuriously called from dial, ensure we don't\n    // leak timers\n    start() {\n        this.cancel();\n        this._schedule();\n    }\n    // api for canceling the heartbeats, if stale is\n    // true it will initiate a client disconnect\n    cancel(stale) {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = undefined;\n        }\n        this._reset();\n        if (stale) {\n            this.ph.disconnect();\n        }\n    }\n    _schedule() {\n        // @ts-ignore: node is not a number - we treat this opaquely\n        this.timer = setTimeout(() => {\n            this.ph.dispatchStatus({ type: core_1.DebugEvents.PingTimer, data: `${this.pendings.length + 1}` });\n            if (this.pendings.length === this.maxOut) {\n                this.cancel(true);\n                return;\n            }\n            const ping = (0, util_1.deferred)();\n            this.ph.flush(ping)\n                .then(() => {\n                this._reset();\n            })\n                .catch(() => {\n                // we disconnected - pongs were rejected\n                this.cancel();\n            });\n            this.pendings.push(ping);\n            this._schedule();\n        }, this.interval);\n    }\n    _reset() {\n        // clear pendings after resolving them\n        this.pendings = this.pendings.filter((p) => {\n            const d = p;\n            d.resolve();\n            return false;\n        });\n    }\n}\nexports.Heartbeat = Heartbeat;\n//# sourceMappingURL=heartbeats.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9oZWFydGJlYXRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxzRUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDZDQUE2Qyx5QkFBeUIsR0FBRztBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L2hlYXJ0YmVhdHMuanM/N2VjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGVhcnRiZWF0ID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCAyMDIwLTIwMjEgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY2xhc3MgSGVhcnRiZWF0IHtcbiAgICBjb25zdHJ1Y3RvcihwaCwgaW50ZXJ2YWwsIG1heE91dCkge1xuICAgICAgICB0aGlzLnBoID0gcGg7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAgICAgdGhpcy5tYXhPdXQgPSBtYXhPdXQ7XG4gICAgICAgIHRoaXMucGVuZGluZ3MgPSBbXTtcbiAgICB9XG4gICAgLy8gYXBpIHRvIHN0YXJ0IHRoZSBoZWFydGJlYXRzLCBzaW5jZSB0aGlzIGNhbiBiZVxuICAgIC8vIHNwdXJpb3VzbHkgY2FsbGVkIGZyb20gZGlhbCwgZW5zdXJlIHdlIGRvbid0XG4gICAgLy8gbGVhayB0aW1lcnNcbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICB9XG4gICAgLy8gYXBpIGZvciBjYW5jZWxpbmcgdGhlIGhlYXJ0YmVhdHMsIGlmIHN0YWxlIGlzXG4gICAgLy8gdHJ1ZSBpdCB3aWxsIGluaXRpYXRlIGEgY2xpZW50IGRpc2Nvbm5lY3RcbiAgICBjYW5jZWwoc3RhbGUpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgaWYgKHN0YWxlKSB7XG4gICAgICAgICAgICB0aGlzLnBoLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2NoZWR1bGUoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IG5vZGUgaXMgbm90IGEgbnVtYmVyIC0gd2UgdHJlYXQgdGhpcyBvcGFxdWVseVxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBoLmRpc3BhdGNoU3RhdHVzKHsgdHlwZTogY29yZV8xLkRlYnVnRXZlbnRzLlBpbmdUaW1lciwgZGF0YTogYCR7dGhpcy5wZW5kaW5ncy5sZW5ndGggKyAxfWAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5ncy5sZW5ndGggPT09IHRoaXMubWF4T3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGluZyA9ICgwLCB1dGlsXzEuZGVmZXJyZWQpKCk7XG4gICAgICAgICAgICB0aGlzLnBoLmZsdXNoKHBpbmcpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0KCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gd2UgZGlzY29ubmVjdGVkIC0gcG9uZ3Mgd2VyZSByZWplY3RlZFxuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ3MucHVzaChwaW5nKTtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gICAgICAgIH0sIHRoaXMuaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBfcmVzZXQoKSB7XG4gICAgICAgIC8vIGNsZWFyIHBlbmRpbmdzIGFmdGVyIHJlc29sdmluZyB0aGVtXG4gICAgICAgIHRoaXMucGVuZGluZ3MgPSB0aGlzLnBlbmRpbmdzLmZpbHRlcigocCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZCA9IHA7XG4gICAgICAgICAgICBkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5IZWFydGJlYXQgPSBIZWFydGJlYXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWFydGJlYXRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/heartbeats.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/idleheartbeat_monitor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/idleheartbeat_monitor.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IdleHeartbeatMonitor = void 0;\nclass IdleHeartbeatMonitor {\n    /**\n     * Constructor\n     * @param interval in millis to check\n     * @param cb a callback to report when heartbeats are missed\n     * @param opts monitor options @see IdleHeartbeatOptions\n     */\n    constructor(interval, cb, opts = { maxOut: 2 }) {\n        this.interval = interval;\n        this.maxOut = (opts === null || opts === void 0 ? void 0 : opts.maxOut) || 2;\n        this.cancelAfter = (opts === null || opts === void 0 ? void 0 : opts.cancelAfter) || 0;\n        this.last = Date.now();\n        this.missed = 0;\n        this.count = 0;\n        this.callback = cb;\n        this._schedule();\n    }\n    /**\n     * cancel monitoring\n     */\n    cancel() {\n        if (this.autoCancelTimer) {\n            clearTimeout(this.autoCancelTimer);\n        }\n        if (this.timer) {\n            clearInterval(this.timer);\n        }\n        this.timer = 0;\n        this.autoCancelTimer = 0;\n    }\n    /**\n     * work signals that there was work performed\n     */\n    work() {\n        this.last = Date.now();\n        this.missed = 0;\n    }\n    /**\n     * internal api to change the interval, cancelAfter and maxOut\n     * @param interval\n     * @param cancelAfter\n     * @param maxOut\n     */\n    _change(interval, cancelAfter = 0, maxOut = 2) {\n        this.interval = interval;\n        this.maxOut = maxOut;\n        this.cancelAfter = cancelAfter;\n        this.restart();\n    }\n    /**\n     * cancels and restarts the monitoring\n     */\n    restart() {\n        this.cancel();\n        this._schedule();\n    }\n    /**\n     * internal api called to start monitoring\n     */\n    _schedule() {\n        if (this.cancelAfter > 0) {\n            // @ts-ignore: in node is not a number - we treat this opaquely\n            this.autoCancelTimer = setTimeout(() => {\n                this.cancel();\n            }, this.cancelAfter);\n        }\n        // @ts-ignore: in node is not a number - we treat this opaquely\n        this.timer = setInterval(() => {\n            this.count++;\n            if ((Date.now() - this.last) > this.interval) {\n                this.missed++;\n            }\n            if (this.missed >= this.maxOut) {\n                try {\n                    if (this.callback(this.missed) === true) {\n                        this.cancel();\n                    }\n                }\n                catch (err) {\n                    console.log(err);\n                }\n            }\n        }, this.interval);\n    }\n}\nexports.IdleHeartbeatMonitor = IdleHeartbeatMonitor;\n//# sourceMappingURL=idleheartbeat_monitor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9pZGxlaGVhcnRiZWF0X21vbml0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9pZGxlaGVhcnRiZWF0X21vbml0b3IuanM/OWYzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JZGxlSGVhcnRiZWF0TW9uaXRvciA9IHZvaWQgMDtcbmNsYXNzIElkbGVIZWFydGJlYXRNb25pdG9yIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCBpbiBtaWxsaXMgdG8gY2hlY2tcbiAgICAgKiBAcGFyYW0gY2IgYSBjYWxsYmFjayB0byByZXBvcnQgd2hlbiBoZWFydGJlYXRzIGFyZSBtaXNzZWRcbiAgICAgKiBAcGFyYW0gb3B0cyBtb25pdG9yIG9wdGlvbnMgQHNlZSBJZGxlSGVhcnRiZWF0T3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGludGVydmFsLCBjYiwgb3B0cyA9IHsgbWF4T3V0OiAyIH0pIHtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsO1xuICAgICAgICB0aGlzLm1heE91dCA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMubWF4T3V0KSB8fCAyO1xuICAgICAgICB0aGlzLmNhbmNlbEFmdGVyID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5jYW5jZWxBZnRlcikgfHwgMDtcbiAgICAgICAgdGhpcy5sYXN0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5taXNzZWQgPSAwO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICAgICAgICB0aGlzLl9zY2hlZHVsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjYW5jZWwgbW9uaXRvcmluZ1xuICAgICAqL1xuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0NhbmNlbFRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hdXRvQ2FuY2VsVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZXIgPSAwO1xuICAgICAgICB0aGlzLmF1dG9DYW5jZWxUaW1lciA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHdvcmsgc2lnbmFscyB0aGF0IHRoZXJlIHdhcyB3b3JrIHBlcmZvcm1lZFxuICAgICAqL1xuICAgIHdvcmsoKSB7XG4gICAgICAgIHRoaXMubGFzdCA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMubWlzc2VkID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaW50ZXJuYWwgYXBpIHRvIGNoYW5nZSB0aGUgaW50ZXJ2YWwsIGNhbmNlbEFmdGVyIGFuZCBtYXhPdXRcbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWxcbiAgICAgKiBAcGFyYW0gY2FuY2VsQWZ0ZXJcbiAgICAgKiBAcGFyYW0gbWF4T3V0XG4gICAgICovXG4gICAgX2NoYW5nZShpbnRlcnZhbCwgY2FuY2VsQWZ0ZXIgPSAwLCBtYXhPdXQgPSAyKSB7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICAgICAgdGhpcy5tYXhPdXQgPSBtYXhPdXQ7XG4gICAgICAgIHRoaXMuY2FuY2VsQWZ0ZXIgPSBjYW5jZWxBZnRlcjtcbiAgICAgICAgdGhpcy5yZXN0YXJ0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGNhbmNlbHMgYW5kIHJlc3RhcnRzIHRoZSBtb25pdG9yaW5nXG4gICAgICovXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaW50ZXJuYWwgYXBpIGNhbGxlZCB0byBzdGFydCBtb25pdG9yaW5nXG4gICAgICovXG4gICAgX3NjaGVkdWxlKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxBZnRlciA+IDApIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmU6IGluIG5vZGUgaXMgbm90IGEgbnVtYmVyIC0gd2UgdHJlYXQgdGhpcyBvcGFxdWVseVxuICAgICAgICAgICAgdGhpcy5hdXRvQ2FuY2VsVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgfSwgdGhpcy5jYW5jZWxBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZTogaW4gbm9kZSBpcyBub3QgYSBudW1iZXIgLSB3ZSB0cmVhdCB0aGlzIG9wYXF1ZWx5XG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvdW50Kys7XG4gICAgICAgICAgICBpZiAoKERhdGUubm93KCkgLSB0aGlzLmxhc3QpID4gdGhpcy5pbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWlzc2VkKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5taXNzZWQgPj0gdGhpcy5tYXhPdXQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjayh0aGlzLm1pc3NlZCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5pbnRlcnZhbCk7XG4gICAgfVxufVxuZXhwb3J0cy5JZGxlSGVhcnRiZWF0TW9uaXRvciA9IElkbGVIZWFydGJlYXRNb25pdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWRsZWhlYXJ0YmVhdF9tb25pdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/idleheartbeat_monitor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/internal_mod.js":
/*!****************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/internal_mod.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Bucket = exports.Base64KeyCodec = exports.TypedSubscription = exports.parseIP = exports.isIP = exports.TE = exports.TD = exports.Metric = exports.Bench = exports.writeAll = exports.readAll = exports.MAX_SIZE = exports.DenoBuffer = exports.State = exports.Parser = exports.Kind = exports.QueuedIteratorImpl = exports.StringCodec = exports.JSONCodec = exports.usernamePasswordAuthenticator = exports.tokenAuthenticator = exports.nkeyAuthenticator = exports.jwtAuthenticator = exports.credsAuthenticator = exports.RequestOne = exports.checkUnsupportedOption = exports.checkOptions = exports.buildAuthenticator = exports.DataBuffer = exports.MuxSubscription = exports.Heartbeat = exports.MsgHdrsImpl = exports.headers = exports.canonicalMIMEHeaderKey = exports.timeout = exports.render = exports.extend = exports.delay = exports.deferred = exports.deadline = exports.collect = exports.backoff = exports.ProtocolHandler = exports.INFO = exports.Connect = exports.setTransportFactory = exports.MsgImpl = exports.nuid = exports.Nuid = exports.NatsConnectionImpl = void 0;\nexports.Subscriptions = exports.SubscriptionImpl = exports.syncIterator = exports.ServiceVerb = exports.ServiceResponseType = exports.ServiceErrorHeader = exports.ServiceErrorCodeHeader = exports.ServiceError = exports.RequestStrategy = exports.NatsError = exports.Match = exports.isNatsError = exports.Events = exports.ErrorCode = exports.DebugEvents = exports.createInbox = exports.extractProtocolMessage = exports.Empty = exports.parseSemVer = exports.compare = exports.NoopKvCodecs = exports.defaultBucketOpts = void 0;\nvar nats_1 = __webpack_require__(/*! ./nats */ \"(rsc)/./node_modules/nats/lib/nats-base-client/nats.js\");\nObject.defineProperty(exports, \"NatsConnectionImpl\", ({ enumerable: true, get: function () { return nats_1.NatsConnectionImpl; } }));\nvar nuid_1 = __webpack_require__(/*! ./nuid */ \"(rsc)/./node_modules/nats/lib/nats-base-client/nuid.js\");\nObject.defineProperty(exports, \"Nuid\", ({ enumerable: true, get: function () { return nuid_1.Nuid; } }));\nObject.defineProperty(exports, \"nuid\", ({ enumerable: true, get: function () { return nuid_1.nuid; } }));\nvar msg_1 = __webpack_require__(/*! ./msg */ \"(rsc)/./node_modules/nats/lib/nats-base-client/msg.js\");\nObject.defineProperty(exports, \"MsgImpl\", ({ enumerable: true, get: function () { return msg_1.MsgImpl; } }));\nvar transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/nats/lib/nats-base-client/transport.js\");\nObject.defineProperty(exports, \"setTransportFactory\", ({ enumerable: true, get: function () { return transport_1.setTransportFactory; } }));\nvar protocol_1 = __webpack_require__(/*! ./protocol */ \"(rsc)/./node_modules/nats/lib/nats-base-client/protocol.js\");\nObject.defineProperty(exports, \"Connect\", ({ enumerable: true, get: function () { return protocol_1.Connect; } }));\nObject.defineProperty(exports, \"INFO\", ({ enumerable: true, get: function () { return protocol_1.INFO; } }));\nObject.defineProperty(exports, \"ProtocolHandler\", ({ enumerable: true, get: function () { return protocol_1.ProtocolHandler; } }));\nvar util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nObject.defineProperty(exports, \"backoff\", ({ enumerable: true, get: function () { return util_1.backoff; } }));\nObject.defineProperty(exports, \"collect\", ({ enumerable: true, get: function () { return util_1.collect; } }));\nObject.defineProperty(exports, \"deadline\", ({ enumerable: true, get: function () { return util_1.deadline; } }));\nObject.defineProperty(exports, \"deferred\", ({ enumerable: true, get: function () { return util_1.deferred; } }));\nObject.defineProperty(exports, \"delay\", ({ enumerable: true, get: function () { return util_1.delay; } }));\nObject.defineProperty(exports, \"extend\", ({ enumerable: true, get: function () { return util_1.extend; } }));\nObject.defineProperty(exports, \"render\", ({ enumerable: true, get: function () { return util_1.render; } }));\nObject.defineProperty(exports, \"timeout\", ({ enumerable: true, get: function () { return util_1.timeout; } }));\nvar headers_1 = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/nats/lib/nats-base-client/headers.js\");\nObject.defineProperty(exports, \"canonicalMIMEHeaderKey\", ({ enumerable: true, get: function () { return headers_1.canonicalMIMEHeaderKey; } }));\nObject.defineProperty(exports, \"headers\", ({ enumerable: true, get: function () { return headers_1.headers; } }));\nObject.defineProperty(exports, \"MsgHdrsImpl\", ({ enumerable: true, get: function () { return headers_1.MsgHdrsImpl; } }));\nvar heartbeats_1 = __webpack_require__(/*! ./heartbeats */ \"(rsc)/./node_modules/nats/lib/nats-base-client/heartbeats.js\");\nObject.defineProperty(exports, \"Heartbeat\", ({ enumerable: true, get: function () { return heartbeats_1.Heartbeat; } }));\nvar muxsubscription_1 = __webpack_require__(/*! ./muxsubscription */ \"(rsc)/./node_modules/nats/lib/nats-base-client/muxsubscription.js\");\nObject.defineProperty(exports, \"MuxSubscription\", ({ enumerable: true, get: function () { return muxsubscription_1.MuxSubscription; } }));\nvar databuffer_1 = __webpack_require__(/*! ./databuffer */ \"(rsc)/./node_modules/nats/lib/nats-base-client/databuffer.js\");\nObject.defineProperty(exports, \"DataBuffer\", ({ enumerable: true, get: function () { return databuffer_1.DataBuffer; } }));\nvar options_1 = __webpack_require__(/*! ./options */ \"(rsc)/./node_modules/nats/lib/nats-base-client/options.js\");\nObject.defineProperty(exports, \"buildAuthenticator\", ({ enumerable: true, get: function () { return options_1.buildAuthenticator; } }));\nObject.defineProperty(exports, \"checkOptions\", ({ enumerable: true, get: function () { return options_1.checkOptions; } }));\nObject.defineProperty(exports, \"checkUnsupportedOption\", ({ enumerable: true, get: function () { return options_1.checkUnsupportedOption; } }));\nvar request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/nats/lib/nats-base-client/request.js\");\nObject.defineProperty(exports, \"RequestOne\", ({ enumerable: true, get: function () { return request_1.RequestOne; } }));\nvar authenticator_1 = __webpack_require__(/*! ./authenticator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/authenticator.js\");\nObject.defineProperty(exports, \"credsAuthenticator\", ({ enumerable: true, get: function () { return authenticator_1.credsAuthenticator; } }));\nObject.defineProperty(exports, \"jwtAuthenticator\", ({ enumerable: true, get: function () { return authenticator_1.jwtAuthenticator; } }));\nObject.defineProperty(exports, \"nkeyAuthenticator\", ({ enumerable: true, get: function () { return authenticator_1.nkeyAuthenticator; } }));\nObject.defineProperty(exports, \"tokenAuthenticator\", ({ enumerable: true, get: function () { return authenticator_1.tokenAuthenticator; } }));\nObject.defineProperty(exports, \"usernamePasswordAuthenticator\", ({ enumerable: true, get: function () { return authenticator_1.usernamePasswordAuthenticator; } }));\nvar codec_1 = __webpack_require__(/*! ./codec */ \"(rsc)/./node_modules/nats/lib/nats-base-client/codec.js\");\nObject.defineProperty(exports, \"JSONCodec\", ({ enumerable: true, get: function () { return codec_1.JSONCodec; } }));\nObject.defineProperty(exports, \"StringCodec\", ({ enumerable: true, get: function () { return codec_1.StringCodec; } }));\n__exportStar(__webpack_require__(/*! ./nkeys */ \"(rsc)/./node_modules/nats/lib/nats-base-client/nkeys.js\"), exports);\nvar queued_iterator_1 = __webpack_require__(/*! ./queued_iterator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\");\nObject.defineProperty(exports, \"QueuedIteratorImpl\", ({ enumerable: true, get: function () { return queued_iterator_1.QueuedIteratorImpl; } }));\nvar parser_1 = __webpack_require__(/*! ./parser */ \"(rsc)/./node_modules/nats/lib/nats-base-client/parser.js\");\nObject.defineProperty(exports, \"Kind\", ({ enumerable: true, get: function () { return parser_1.Kind; } }));\nObject.defineProperty(exports, \"Parser\", ({ enumerable: true, get: function () { return parser_1.Parser; } }));\nObject.defineProperty(exports, \"State\", ({ enumerable: true, get: function () { return parser_1.State; } }));\nvar denobuffer_1 = __webpack_require__(/*! ./denobuffer */ \"(rsc)/./node_modules/nats/lib/nats-base-client/denobuffer.js\");\nObject.defineProperty(exports, \"DenoBuffer\", ({ enumerable: true, get: function () { return denobuffer_1.DenoBuffer; } }));\nObject.defineProperty(exports, \"MAX_SIZE\", ({ enumerable: true, get: function () { return denobuffer_1.MAX_SIZE; } }));\nObject.defineProperty(exports, \"readAll\", ({ enumerable: true, get: function () { return denobuffer_1.readAll; } }));\nObject.defineProperty(exports, \"writeAll\", ({ enumerable: true, get: function () { return denobuffer_1.writeAll; } }));\nvar bench_1 = __webpack_require__(/*! ./bench */ \"(rsc)/./node_modules/nats/lib/nats-base-client/bench.js\");\nObject.defineProperty(exports, \"Bench\", ({ enumerable: true, get: function () { return bench_1.Bench; } }));\nObject.defineProperty(exports, \"Metric\", ({ enumerable: true, get: function () { return bench_1.Metric; } }));\nvar encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nObject.defineProperty(exports, \"TD\", ({ enumerable: true, get: function () { return encoders_1.TD; } }));\nObject.defineProperty(exports, \"TE\", ({ enumerable: true, get: function () { return encoders_1.TE; } }));\nvar ipparser_1 = __webpack_require__(/*! ./ipparser */ \"(rsc)/./node_modules/nats/lib/nats-base-client/ipparser.js\");\nObject.defineProperty(exports, \"isIP\", ({ enumerable: true, get: function () { return ipparser_1.isIP; } }));\nObject.defineProperty(exports, \"parseIP\", ({ enumerable: true, get: function () { return ipparser_1.parseIP; } }));\nvar typedsub_1 = __webpack_require__(/*! ./typedsub */ \"(rsc)/./node_modules/nats/lib/nats-base-client/typedsub.js\");\nObject.defineProperty(exports, \"TypedSubscription\", ({ enumerable: true, get: function () { return typedsub_1.TypedSubscription; } }));\nvar kv_1 = __webpack_require__(/*! ../jetstream/kv */ \"(rsc)/./node_modules/nats/lib/jetstream/kv.js\");\nObject.defineProperty(exports, \"Base64KeyCodec\", ({ enumerable: true, get: function () { return kv_1.Base64KeyCodec; } }));\nObject.defineProperty(exports, \"Bucket\", ({ enumerable: true, get: function () { return kv_1.Bucket; } }));\nObject.defineProperty(exports, \"defaultBucketOpts\", ({ enumerable: true, get: function () { return kv_1.defaultBucketOpts; } }));\nObject.defineProperty(exports, \"NoopKvCodecs\", ({ enumerable: true, get: function () { return kv_1.NoopKvCodecs; } }));\nvar semver_1 = __webpack_require__(/*! ./semver */ \"(rsc)/./node_modules/nats/lib/nats-base-client/semver.js\");\nObject.defineProperty(exports, \"compare\", ({ enumerable: true, get: function () { return semver_1.compare; } }));\nObject.defineProperty(exports, \"parseSemVer\", ({ enumerable: true, get: function () { return semver_1.parseSemVer; } }));\nvar types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/nats/lib/nats-base-client/types.js\");\nObject.defineProperty(exports, \"Empty\", ({ enumerable: true, get: function () { return types_1.Empty; } }));\nvar transport_2 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/nats/lib/nats-base-client/transport.js\");\nObject.defineProperty(exports, \"extractProtocolMessage\", ({ enumerable: true, get: function () { return transport_2.extractProtocolMessage; } }));\nvar core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nObject.defineProperty(exports, \"createInbox\", ({ enumerable: true, get: function () { return core_1.createInbox; } }));\nObject.defineProperty(exports, \"DebugEvents\", ({ enumerable: true, get: function () { return core_1.DebugEvents; } }));\nObject.defineProperty(exports, \"ErrorCode\", ({ enumerable: true, get: function () { return core_1.ErrorCode; } }));\nObject.defineProperty(exports, \"Events\", ({ enumerable: true, get: function () { return core_1.Events; } }));\nObject.defineProperty(exports, \"isNatsError\", ({ enumerable: true, get: function () { return core_1.isNatsError; } }));\nObject.defineProperty(exports, \"Match\", ({ enumerable: true, get: function () { return core_1.Match; } }));\nObject.defineProperty(exports, \"NatsError\", ({ enumerable: true, get: function () { return core_1.NatsError; } }));\nObject.defineProperty(exports, \"RequestStrategy\", ({ enumerable: true, get: function () { return core_1.RequestStrategy; } }));\nObject.defineProperty(exports, \"ServiceError\", ({ enumerable: true, get: function () { return core_1.ServiceError; } }));\nObject.defineProperty(exports, \"ServiceErrorCodeHeader\", ({ enumerable: true, get: function () { return core_1.ServiceErrorCodeHeader; } }));\nObject.defineProperty(exports, \"ServiceErrorHeader\", ({ enumerable: true, get: function () { return core_1.ServiceErrorHeader; } }));\nObject.defineProperty(exports, \"ServiceResponseType\", ({ enumerable: true, get: function () { return core_1.ServiceResponseType; } }));\nObject.defineProperty(exports, \"ServiceVerb\", ({ enumerable: true, get: function () { return core_1.ServiceVerb; } }));\nObject.defineProperty(exports, \"syncIterator\", ({ enumerable: true, get: function () { return core_1.syncIterator; } }));\nvar protocol_2 = __webpack_require__(/*! ./protocol */ \"(rsc)/./node_modules/nats/lib/nats-base-client/protocol.js\");\nObject.defineProperty(exports, \"SubscriptionImpl\", ({ enumerable: true, get: function () { return protocol_2.SubscriptionImpl; } }));\nObject.defineProperty(exports, \"Subscriptions\", ({ enumerable: true, get: function () { return protocol_2.Subscriptions; } }));\n//# sourceMappingURL=internal_mod.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9pbnRlcm5hbF9tb2QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLHNCQUFzQixHQUFHLHlCQUF5QixHQUFHLGVBQWUsR0FBRyxZQUFZLEdBQUcsVUFBVSxHQUFHLFVBQVUsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxrQkFBa0IsR0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHLFlBQVksR0FBRywwQkFBMEIsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxxQ0FBcUMsR0FBRywwQkFBMEIsR0FBRyx5QkFBeUIsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyxrQkFBa0IsR0FBRyw4QkFBOEIsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEIsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsOEJBQThCLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGdCQUFnQixHQUFHLGdCQUFnQixHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsdUJBQXVCLEdBQUcsWUFBWSxHQUFHLGVBQWUsR0FBRywyQkFBMkIsR0FBRyxlQUFlLEdBQUcsWUFBWSxHQUFHLFlBQVksR0FBRywwQkFBMEI7QUFDdGlDLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLDJCQUEyQixHQUFHLDBCQUEwQixHQUFHLDhCQUE4QixHQUFHLG9CQUFvQixHQUFHLHVCQUF1QixHQUFHLGlCQUFpQixH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LHFDQUFxQyxvQ0FBb0MsRUFBQztBQUM1SCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL25hdHMtYmFzZS1jbGllbnQvaW50ZXJuYWxfbW9kLmpzPzQ2NTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQnVja2V0ID0gZXhwb3J0cy5CYXNlNjRLZXlDb2RlYyA9IGV4cG9ydHMuVHlwZWRTdWJzY3JpcHRpb24gPSBleHBvcnRzLnBhcnNlSVAgPSBleHBvcnRzLmlzSVAgPSBleHBvcnRzLlRFID0gZXhwb3J0cy5URCA9IGV4cG9ydHMuTWV0cmljID0gZXhwb3J0cy5CZW5jaCA9IGV4cG9ydHMud3JpdGVBbGwgPSBleHBvcnRzLnJlYWRBbGwgPSBleHBvcnRzLk1BWF9TSVpFID0gZXhwb3J0cy5EZW5vQnVmZmVyID0gZXhwb3J0cy5TdGF0ZSA9IGV4cG9ydHMuUGFyc2VyID0gZXhwb3J0cy5LaW5kID0gZXhwb3J0cy5RdWV1ZWRJdGVyYXRvckltcGwgPSBleHBvcnRzLlN0cmluZ0NvZGVjID0gZXhwb3J0cy5KU09OQ29kZWMgPSBleHBvcnRzLnVzZXJuYW1lUGFzc3dvcmRBdXRoZW50aWNhdG9yID0gZXhwb3J0cy50b2tlbkF1dGhlbnRpY2F0b3IgPSBleHBvcnRzLm5rZXlBdXRoZW50aWNhdG9yID0gZXhwb3J0cy5qd3RBdXRoZW50aWNhdG9yID0gZXhwb3J0cy5jcmVkc0F1dGhlbnRpY2F0b3IgPSBleHBvcnRzLlJlcXVlc3RPbmUgPSBleHBvcnRzLmNoZWNrVW5zdXBwb3J0ZWRPcHRpb24gPSBleHBvcnRzLmNoZWNrT3B0aW9ucyA9IGV4cG9ydHMuYnVpbGRBdXRoZW50aWNhdG9yID0gZXhwb3J0cy5EYXRhQnVmZmVyID0gZXhwb3J0cy5NdXhTdWJzY3JpcHRpb24gPSBleHBvcnRzLkhlYXJ0YmVhdCA9IGV4cG9ydHMuTXNnSGRyc0ltcGwgPSBleHBvcnRzLmhlYWRlcnMgPSBleHBvcnRzLmNhbm9uaWNhbE1JTUVIZWFkZXJLZXkgPSBleHBvcnRzLnRpbWVvdXQgPSBleHBvcnRzLnJlbmRlciA9IGV4cG9ydHMuZXh0ZW5kID0gZXhwb3J0cy5kZWxheSA9IGV4cG9ydHMuZGVmZXJyZWQgPSBleHBvcnRzLmRlYWRsaW5lID0gZXhwb3J0cy5jb2xsZWN0ID0gZXhwb3J0cy5iYWNrb2ZmID0gZXhwb3J0cy5Qcm90b2NvbEhhbmRsZXIgPSBleHBvcnRzLklORk8gPSBleHBvcnRzLkNvbm5lY3QgPSBleHBvcnRzLnNldFRyYW5zcG9ydEZhY3RvcnkgPSBleHBvcnRzLk1zZ0ltcGwgPSBleHBvcnRzLm51aWQgPSBleHBvcnRzLk51aWQgPSBleHBvcnRzLk5hdHNDb25uZWN0aW9uSW1wbCA9IHZvaWQgMDtcbmV4cG9ydHMuU3Vic2NyaXB0aW9ucyA9IGV4cG9ydHMuU3Vic2NyaXB0aW9uSW1wbCA9IGV4cG9ydHMuc3luY0l0ZXJhdG9yID0gZXhwb3J0cy5TZXJ2aWNlVmVyYiA9IGV4cG9ydHMuU2VydmljZVJlc3BvbnNlVHlwZSA9IGV4cG9ydHMuU2VydmljZUVycm9ySGVhZGVyID0gZXhwb3J0cy5TZXJ2aWNlRXJyb3JDb2RlSGVhZGVyID0gZXhwb3J0cy5TZXJ2aWNlRXJyb3IgPSBleHBvcnRzLlJlcXVlc3RTdHJhdGVneSA9IGV4cG9ydHMuTmF0c0Vycm9yID0gZXhwb3J0cy5NYXRjaCA9IGV4cG9ydHMuaXNOYXRzRXJyb3IgPSBleHBvcnRzLkV2ZW50cyA9IGV4cG9ydHMuRXJyb3JDb2RlID0gZXhwb3J0cy5EZWJ1Z0V2ZW50cyA9IGV4cG9ydHMuY3JlYXRlSW5ib3ggPSBleHBvcnRzLmV4dHJhY3RQcm90b2NvbE1lc3NhZ2UgPSBleHBvcnRzLkVtcHR5ID0gZXhwb3J0cy5wYXJzZVNlbVZlciA9IGV4cG9ydHMuY29tcGFyZSA9IGV4cG9ydHMuTm9vcEt2Q29kZWNzID0gZXhwb3J0cy5kZWZhdWx0QnVja2V0T3B0cyA9IHZvaWQgMDtcbnZhciBuYXRzXzEgPSByZXF1aXJlKFwiLi9uYXRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmF0c0Nvbm5lY3Rpb25JbXBsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRzXzEuTmF0c0Nvbm5lY3Rpb25JbXBsOyB9IH0pO1xudmFyIG51aWRfMSA9IHJlcXVpcmUoXCIuL251aWRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWlkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBudWlkXzEuTnVpZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm51aWRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51aWRfMS5udWlkOyB9IH0pO1xudmFyIG1zZ18xID0gcmVxdWlyZShcIi4vbXNnXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXNnSW1wbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbXNnXzEuTXNnSW1wbDsgfSB9KTtcbnZhciB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNldFRyYW5zcG9ydEZhY3RvcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zcG9ydF8xLnNldFRyYW5zcG9ydEZhY3Rvcnk7IH0gfSk7XG52YXIgcHJvdG9jb2xfMSA9IHJlcXVpcmUoXCIuL3Byb3RvY29sXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ29ubmVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfMS5Db25uZWN0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSU5GT1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvdG9jb2xfMS5JTkZPOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJvdG9jb2xIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF8xLlByb3RvY29sSGFuZGxlcjsgfSB9KTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYmFja29mZlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbF8xLmJhY2tvZmY7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb2xsZWN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsXzEuY29sbGVjdDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlYWRsaW5lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsXzEuZGVhZGxpbmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZlcnJlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbF8xLmRlZmVycmVkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVsYXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxfMS5kZWxheTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImV4dGVuZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbF8xLmV4dGVuZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbmRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbF8xLnJlbmRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRpbWVvdXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxfMS50aW1lb3V0OyB9IH0pO1xudmFyIGhlYWRlcnNfMSA9IHJlcXVpcmUoXCIuL2hlYWRlcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjYW5vbmljYWxNSU1FSGVhZGVyS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZWFkZXJzXzEuY2Fub25pY2FsTUlNRUhlYWRlcktleTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImhlYWRlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhlYWRlcnNfMS5oZWFkZXJzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXNnSGRyc0ltcGxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhlYWRlcnNfMS5Nc2dIZHJzSW1wbDsgfSB9KTtcbnZhciBoZWFydGJlYXRzXzEgPSByZXF1aXJlKFwiLi9oZWFydGJlYXRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSGVhcnRiZWF0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBoZWFydGJlYXRzXzEuSGVhcnRiZWF0OyB9IH0pO1xudmFyIG11eHN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vbXV4c3Vic2NyaXB0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXV4U3Vic2NyaXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtdXhzdWJzY3JpcHRpb25fMS5NdXhTdWJzY3JpcHRpb247IH0gfSk7XG52YXIgZGF0YWJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vZGF0YWJ1ZmZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRhdGFCdWZmZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFidWZmZXJfMS5EYXRhQnVmZmVyOyB9IH0pO1xudmFyIG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL29wdGlvbnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJidWlsZEF1dGhlbnRpY2F0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wdGlvbnNfMS5idWlsZEF1dGhlbnRpY2F0b3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGVja09wdGlvbnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wdGlvbnNfMS5jaGVja09wdGlvbnM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjaGVja1Vuc3VwcG9ydGVkT3B0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvcHRpb25zXzEuY2hlY2tVbnN1cHBvcnRlZE9wdGlvbjsgfSB9KTtcbnZhciByZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi9yZXF1ZXN0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVxdWVzdE9uZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVxdWVzdF8xLlJlcXVlc3RPbmU7IH0gfSk7XG52YXIgYXV0aGVudGljYXRvcl8xID0gcmVxdWlyZShcIi4vYXV0aGVudGljYXRvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWRzQXV0aGVudGljYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXV0aGVudGljYXRvcl8xLmNyZWRzQXV0aGVudGljYXRvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImp3dEF1dGhlbnRpY2F0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF1dGhlbnRpY2F0b3JfMS5qd3RBdXRoZW50aWNhdG9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibmtleUF1dGhlbnRpY2F0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGF1dGhlbnRpY2F0b3JfMS5ua2V5QXV0aGVudGljYXRvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInRva2VuQXV0aGVudGljYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXV0aGVudGljYXRvcl8xLnRva2VuQXV0aGVudGljYXRvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZXJuYW1lUGFzc3dvcmRBdXRoZW50aWNhdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhdXRoZW50aWNhdG9yXzEudXNlcm5hbWVQYXNzd29yZEF1dGhlbnRpY2F0b3I7IH0gfSk7XG52YXIgY29kZWNfMSA9IHJlcXVpcmUoXCIuL2NvZGVjXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSlNPTkNvZGVjXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlY18xLkpTT05Db2RlYzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0cmluZ0NvZGVjXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb2RlY18xLlN0cmluZ0NvZGVjOyB9IH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25rZXlzXCIpLCBleHBvcnRzKTtcbnZhciBxdWV1ZWRfaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL3F1ZXVlZF9pdGVyYXRvclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlF1ZXVlZEl0ZXJhdG9ySW1wbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcXVldWVkX2l0ZXJhdG9yXzEuUXVldWVkSXRlcmF0b3JJbXBsOyB9IH0pO1xudmFyIHBhcnNlcl8xID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiS2luZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyXzEuS2luZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcnNlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyXzEuUGFyc2VyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhcnNlcl8xLlN0YXRlOyB9IH0pO1xudmFyIGRlbm9idWZmZXJfMSA9IHJlcXVpcmUoXCIuL2Rlbm9idWZmZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZW5vQnVmZmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZW5vYnVmZmVyXzEuRGVub0J1ZmZlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1BWF9TSVpFXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZW5vYnVmZmVyXzEuTUFYX1NJWkU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWFkQWxsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZW5vYnVmZmVyXzEucmVhZEFsbDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIndyaXRlQWxsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZW5vYnVmZmVyXzEud3JpdGVBbGw7IH0gfSk7XG52YXIgYmVuY2hfMSA9IHJlcXVpcmUoXCIuL2JlbmNoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmVuY2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJlbmNoXzEuQmVuY2g7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXRyaWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJlbmNoXzEuTWV0cmljOyB9IH0pO1xudmFyIGVuY29kZXJzXzEgPSByZXF1aXJlKFwiLi9lbmNvZGVyc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlREXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlbmNvZGVyc18xLlREOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVEVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZXJzXzEuVEU7IH0gfSk7XG52YXIgaXBwYXJzZXJfMSA9IHJlcXVpcmUoXCIuL2lwcGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNJUFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXBwYXJzZXJfMS5pc0lQOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VJUFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaXBwYXJzZXJfMS5wYXJzZUlQOyB9IH0pO1xudmFyIHR5cGVkc3ViXzEgPSByZXF1aXJlKFwiLi90eXBlZHN1YlwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlR5cGVkU3Vic2NyaXB0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlZHN1Yl8xLlR5cGVkU3Vic2NyaXB0aW9uOyB9IH0pO1xudmFyIGt2XzEgPSByZXF1aXJlKFwiLi4vamV0c3RyZWFtL2t2XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZTY0S2V5Q29kZWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGt2XzEuQmFzZTY0S2V5Q29kZWM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCdWNrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGt2XzEuQnVja2V0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdEJ1Y2tldE9wdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGt2XzEuZGVmYXVsdEJ1Y2tldE9wdHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOb29wS3ZDb2RlY3NcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGt2XzEuTm9vcEt2Q29kZWNzOyB9IH0pO1xudmFyIHNlbXZlcl8xID0gcmVxdWlyZShcIi4vc2VtdmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcGFyZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VtdmVyXzEuY29tcGFyZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlU2VtVmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZW12ZXJfMS5wYXJzZVNlbVZlcjsgfSB9KTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbXB0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZXNfMS5FbXB0eTsgfSB9KTtcbnZhciB0cmFuc3BvcnRfMiA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImV4dHJhY3RQcm90b2NvbE1lc3NhZ2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zcG9ydF8yLmV4dHJhY3RQcm90b2NvbE1lc3NhZ2U7IH0gfSk7XG52YXIgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZUluYm94XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlXzEuY3JlYXRlSW5ib3g7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWJ1Z0V2ZW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZV8xLkRlYnVnRXZlbnRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXJyb3JDb2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlXzEuRXJyb3JDb2RlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlXzEuRXZlbnRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNOYXRzRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS5pc05hdHNFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1hdGNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlXzEuTWF0Y2g7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYXRzRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS5OYXRzRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0U3RyYXRlZ3lcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS5SZXF1ZXN0U3RyYXRlZ3k7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2aWNlRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS5TZXJ2aWNlRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2aWNlRXJyb3JDb2RlSGVhZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3JlXzEuU2VydmljZUVycm9yQ29kZUhlYWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZpY2VFcnJvckhlYWRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZV8xLlNlcnZpY2VFcnJvckhlYWRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZpY2VSZXNwb25zZVR5cGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS5TZXJ2aWNlUmVzcG9uc2VUeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmljZVZlcmJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS5TZXJ2aWNlVmVyYjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN5bmNJdGVyYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZV8xLnN5bmNJdGVyYXRvcjsgfSB9KTtcbnZhciBwcm90b2NvbF8yID0gcmVxdWlyZShcIi4vcHJvdG9jb2xcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdWJzY3JpcHRpb25JbXBsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF8yLlN1YnNjcmlwdGlvbkltcGw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdWJzY3JpcHRpb25zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm90b2NvbF8yLlN1YnNjcmlwdGlvbnM7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbF9tb2QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/internal_mod.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/ipparser.js":
/*!************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/ipparser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2020-2021 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseIP = exports.isIP = exports.ipV4 = void 0;\n// JavaScript port of go net/ip/ParseIP\n// https://github.com/golang/go/blob/master/src/net/ip.go\n// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\nconst IPv4LEN = 4;\nconst IPv6LEN = 16;\nconst ASCII0 = 48;\nconst ASCII9 = 57;\nconst ASCIIA = 65;\nconst ASCIIF = 70;\nconst ASCIIa = 97;\nconst ASCIIf = 102;\nconst big = 0xFFFFFF;\nfunction ipV4(a, b, c, d) {\n    const ip = new Uint8Array(IPv6LEN);\n    const prefix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff];\n    prefix.forEach((v, idx) => {\n        ip[idx] = v;\n    });\n    ip[12] = a;\n    ip[13] = b;\n    ip[14] = c;\n    ip[15] = d;\n    return ip;\n}\nexports.ipV4 = ipV4;\nfunction isIP(h) {\n    return parseIP(h) !== undefined;\n}\nexports.isIP = isIP;\nfunction parseIP(h) {\n    for (let i = 0; i < h.length; i++) {\n        switch (h[i]) {\n            case \".\":\n                return parseIPv4(h);\n            case \":\":\n                return parseIPv6(h);\n        }\n    }\n    return;\n}\nexports.parseIP = parseIP;\nfunction parseIPv4(s) {\n    const ip = new Uint8Array(IPv4LEN);\n    for (let i = 0; i < IPv4LEN; i++) {\n        if (s.length === 0) {\n            return undefined;\n        }\n        if (i > 0) {\n            if (s[0] !== \".\") {\n                return undefined;\n            }\n            s = s.substring(1);\n        }\n        const { n, c, ok } = dtoi(s);\n        if (!ok || n > 0xFF) {\n            return undefined;\n        }\n        s = s.substring(c);\n        ip[i] = n;\n    }\n    return ipV4(ip[0], ip[1], ip[2], ip[3]);\n}\nfunction parseIPv6(s) {\n    const ip = new Uint8Array(IPv6LEN);\n    let ellipsis = -1;\n    if (s.length >= 2 && s[0] === \":\" && s[1] === \":\") {\n        ellipsis = 0;\n        s = s.substring(2);\n        if (s.length === 0) {\n            return ip;\n        }\n    }\n    let i = 0;\n    while (i < IPv6LEN) {\n        const { n, c, ok } = xtoi(s);\n        if (!ok || n > 0xFFFF) {\n            return undefined;\n        }\n        if (c < s.length && s[c] === \".\") {\n            if (ellipsis < 0 && i != IPv6LEN - IPv4LEN) {\n                return undefined;\n            }\n            if (i + IPv4LEN > IPv6LEN) {\n                return undefined;\n            }\n            const ip4 = parseIPv4(s);\n            if (ip4 === undefined) {\n                return undefined;\n            }\n            ip[i] = ip4[12];\n            ip[i + 1] = ip4[13];\n            ip[i + 2] = ip4[14];\n            ip[i + 3] = ip4[15];\n            s = \"\";\n            i += IPv4LEN;\n            break;\n        }\n        ip[i] = n >> 8;\n        ip[i + 1] = n;\n        i += 2;\n        s = s.substring(c);\n        if (s.length === 0) {\n            break;\n        }\n        if (s[0] !== \":\" || s.length == 1) {\n            return undefined;\n        }\n        s = s.substring(1);\n        if (s[0] === \":\") {\n            if (ellipsis >= 0) {\n                return undefined;\n            }\n            ellipsis = i;\n            s = s.substring(1);\n            if (s.length === 0) {\n                break;\n            }\n        }\n    }\n    if (s.length !== 0) {\n        return undefined;\n    }\n    if (i < IPv6LEN) {\n        if (ellipsis < 0) {\n            return undefined;\n        }\n        const n = IPv6LEN - i;\n        for (let j = i - 1; j >= ellipsis; j--) {\n            ip[j + n] = ip[j];\n        }\n        for (let j = ellipsis + n - 1; j >= ellipsis; j--) {\n            ip[j] = 0;\n        }\n    }\n    else if (ellipsis >= 0) {\n        return undefined;\n    }\n    return ip;\n}\nfunction dtoi(s) {\n    let i = 0;\n    let n = 0;\n    for (i = 0; i < s.length && ASCII0 <= s.charCodeAt(i) && s.charCodeAt(i) <= ASCII9; i++) {\n        n = n * 10 + (s.charCodeAt(i) - ASCII0);\n        if (n >= big) {\n            return { n: big, c: i, ok: false };\n        }\n    }\n    if (i === 0) {\n        return { n: 0, c: 0, ok: false };\n    }\n    return { n: n, c: i, ok: true };\n}\nfunction xtoi(s) {\n    let n = 0;\n    let i = 0;\n    for (i = 0; i < s.length; i++) {\n        if (ASCII0 <= s.charCodeAt(i) && s.charCodeAt(i) <= ASCII9) {\n            n *= 16;\n            n += s.charCodeAt(i) - ASCII0;\n        }\n        else if (ASCIIa <= s.charCodeAt(i) && s.charCodeAt(i) <= ASCIIf) {\n            n *= 16;\n            n += (s.charCodeAt(i) - ASCIIa) + 10;\n        }\n        else if (ASCIIA <= s.charCodeAt(i) && s.charCodeAt(i) <= ASCIIF) {\n            n *= 16;\n            n += (s.charCodeAt(i) - ASCIIA) + 10;\n        }\n        else {\n            break;\n        }\n        if (n >= big) {\n            return { n: 0, c: i, ok: false };\n        }\n    }\n    if (i === 0) {\n        return { n: 0, c: i, ok: false };\n    }\n    return { n: n, c: i, ok: true };\n}\n//# sourceMappingURL=ipparser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9pcHBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLFlBQVksR0FBRyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdFQUF3RTtBQUN4RjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9pcHBhcnNlci5qcz8zZjc1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIwLTIwMjEgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VJUCA9IGV4cG9ydHMuaXNJUCA9IGV4cG9ydHMuaXBWNCA9IHZvaWQgMDtcbi8vIEphdmFTY3JpcHQgcG9ydCBvZiBnbyBuZXQvaXAvUGFyc2VJUFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2dvbGFuZy9nby9ibG9iL21hc3Rlci9zcmMvbmV0L2lwLmdvXG4vLyBDb3B5cmlnaHQgMjAwOSBUaGUgR28gQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlXG4vLyBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUuXG5jb25zdCBJUHY0TEVOID0gNDtcbmNvbnN0IElQdjZMRU4gPSAxNjtcbmNvbnN0IEFTQ0lJMCA9IDQ4O1xuY29uc3QgQVNDSUk5ID0gNTc7XG5jb25zdCBBU0NJSUEgPSA2NTtcbmNvbnN0IEFTQ0lJRiA9IDcwO1xuY29uc3QgQVNDSUlhID0gOTc7XG5jb25zdCBBU0NJSWYgPSAxMDI7XG5jb25zdCBiaWcgPSAweEZGRkZGRjtcbmZ1bmN0aW9uIGlwVjQoYSwgYiwgYywgZCkge1xuICAgIGNvbnN0IGlwID0gbmV3IFVpbnQ4QXJyYXkoSVB2NkxFTik7XG4gICAgY29uc3QgcHJlZml4ID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4ZmYsIDB4ZmZdO1xuICAgIHByZWZpeC5mb3JFYWNoKCh2LCBpZHgpID0+IHtcbiAgICAgICAgaXBbaWR4XSA9IHY7XG4gICAgfSk7XG4gICAgaXBbMTJdID0gYTtcbiAgICBpcFsxM10gPSBiO1xuICAgIGlwWzE0XSA9IGM7XG4gICAgaXBbMTVdID0gZDtcbiAgICByZXR1cm4gaXA7XG59XG5leHBvcnRzLmlwVjQgPSBpcFY0O1xuZnVuY3Rpb24gaXNJUChoKSB7XG4gICAgcmV0dXJuIHBhcnNlSVAoaCkgIT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuaXNJUCA9IGlzSVA7XG5mdW5jdGlvbiBwYXJzZUlQKGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3dpdGNoIChoW2ldKSB7XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlQdjQoaCk7XG4gICAgICAgICAgICBjYXNlIFwiOlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUlQdjYoaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufVxuZXhwb3J0cy5wYXJzZUlQID0gcGFyc2VJUDtcbmZ1bmN0aW9uIHBhcnNlSVB2NChzKSB7XG4gICAgY29uc3QgaXAgPSBuZXcgVWludDhBcnJheShJUHY0TEVOKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IElQdjRMRU47IGkrKykge1xuICAgICAgICBpZiAocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBpZiAoc1swXSAhPT0gXCIuXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcyA9IHMuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbiwgYywgb2sgfSA9IGR0b2kocyk7XG4gICAgICAgIGlmICghb2sgfHwgbiA+IDB4RkYpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IHMuc3Vic3RyaW5nKGMpO1xuICAgICAgICBpcFtpXSA9IG47XG4gICAgfVxuICAgIHJldHVybiBpcFY0KGlwWzBdLCBpcFsxXSwgaXBbMl0sIGlwWzNdKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSVB2NihzKSB7XG4gICAgY29uc3QgaXAgPSBuZXcgVWludDhBcnJheShJUHY2TEVOKTtcbiAgICBsZXQgZWxsaXBzaXMgPSAtMTtcbiAgICBpZiAocy5sZW5ndGggPj0gMiAmJiBzWzBdID09PSBcIjpcIiAmJiBzWzFdID09PSBcIjpcIikge1xuICAgICAgICBlbGxpcHNpcyA9IDA7XG4gICAgICAgIHMgPSBzLnN1YnN0cmluZygyKTtcbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgSVB2NkxFTikge1xuICAgICAgICBjb25zdCB7IG4sIGMsIG9rIH0gPSB4dG9pKHMpO1xuICAgICAgICBpZiAoIW9rIHx8IG4gPiAweEZGRkYpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCBzLmxlbmd0aCAmJiBzW2NdID09PSBcIi5cIikge1xuICAgICAgICAgICAgaWYgKGVsbGlwc2lzIDwgMCAmJiBpICE9IElQdjZMRU4gLSBJUHY0TEVOKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICsgSVB2NExFTiA+IElQdjZMRU4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXA0ID0gcGFyc2VJUHY0KHMpO1xuICAgICAgICAgICAgaWYgKGlwNCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlwW2ldID0gaXA0WzEyXTtcbiAgICAgICAgICAgIGlwW2kgKyAxXSA9IGlwNFsxM107XG4gICAgICAgICAgICBpcFtpICsgMl0gPSBpcDRbMTRdO1xuICAgICAgICAgICAgaXBbaSArIDNdID0gaXA0WzE1XTtcbiAgICAgICAgICAgIHMgPSBcIlwiO1xuICAgICAgICAgICAgaSArPSBJUHY0TEVOO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaXBbaV0gPSBuID4+IDg7XG4gICAgICAgIGlwW2kgKyAxXSA9IG47XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgcyA9IHMuc3Vic3RyaW5nKGMpO1xuICAgICAgICBpZiAocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzWzBdICE9PSBcIjpcIiB8fCBzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBzLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKHNbMF0gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICBpZiAoZWxsaXBzaXMgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGxpcHNpcyA9IGk7XG4gICAgICAgICAgICBzID0gcy5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGkgPCBJUHY2TEVOKSB7XG4gICAgICAgIGlmIChlbGxpcHNpcyA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbiA9IElQdjZMRU4gLSBpO1xuICAgICAgICBmb3IgKGxldCBqID0gaSAtIDE7IGogPj0gZWxsaXBzaXM7IGotLSkge1xuICAgICAgICAgICAgaXBbaiArIG5dID0gaXBbal07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IGVsbGlwc2lzICsgbiAtIDE7IGogPj0gZWxsaXBzaXM7IGotLSkge1xuICAgICAgICAgICAgaXBbal0gPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsbGlwc2lzID49IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlwO1xufVxuZnVuY3Rpb24gZHRvaShzKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBuID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcy5sZW5ndGggJiYgQVNDSUkwIDw9IHMuY2hhckNvZGVBdChpKSAmJiBzLmNoYXJDb2RlQXQoaSkgPD0gQVNDSUk5OyBpKyspIHtcbiAgICAgICAgbiA9IG4gKiAxMCArIChzLmNoYXJDb2RlQXQoaSkgLSBBU0NJSTApO1xuICAgICAgICBpZiAobiA+PSBiaWcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG46IGJpZywgYzogaSwgb2s6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgbjogMCwgYzogMCwgb2s6IGZhbHNlIH07XG4gICAgfVxuICAgIHJldHVybiB7IG46IG4sIGM6IGksIG9rOiB0cnVlIH07XG59XG5mdW5jdGlvbiB4dG9pKHMpIHtcbiAgICBsZXQgbiA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChBU0NJSTAgPD0gcy5jaGFyQ29kZUF0KGkpICYmIHMuY2hhckNvZGVBdChpKSA8PSBBU0NJSTkpIHtcbiAgICAgICAgICAgIG4gKj0gMTY7XG4gICAgICAgICAgICBuICs9IHMuY2hhckNvZGVBdChpKSAtIEFTQ0lJMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBU0NJSWEgPD0gcy5jaGFyQ29kZUF0KGkpICYmIHMuY2hhckNvZGVBdChpKSA8PSBBU0NJSWYpIHtcbiAgICAgICAgICAgIG4gKj0gMTY7XG4gICAgICAgICAgICBuICs9IChzLmNoYXJDb2RlQXQoaSkgLSBBU0NJSWEpICsgMTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQVNDSUlBIDw9IHMuY2hhckNvZGVBdChpKSAmJiBzLmNoYXJDb2RlQXQoaSkgPD0gQVNDSUlGKSB7XG4gICAgICAgICAgICBuICo9IDE2O1xuICAgICAgICAgICAgbiArPSAocy5jaGFyQ29kZUF0KGkpIC0gQVNDSUlBKSArIDEwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG4gPj0gYmlnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBuOiAwLCBjOiBpLCBvazogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyBuOiAwLCBjOiBpLCBvazogZmFsc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbjogbiwgYzogaSwgb2s6IHRydWUgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlwcGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/ipparser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/mod.js":
/*!*******************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/mod.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.usernamePasswordAuthenticator = exports.tokenAuthenticator = exports.syncIterator = exports.StringCodec = exports.ServiceVerb = exports.ServiceResponseType = exports.ServiceErrorHeader = exports.ServiceErrorCodeHeader = exports.ServiceError = exports.RequestStrategy = exports.nuid = exports.Nuid = exports.nkeys = exports.nkeyAuthenticator = exports.NatsError = exports.MsgHdrsImpl = exports.Metric = exports.Match = exports.jwtAuthenticator = exports.JSONCodec = exports.headers = exports.Events = exports.ErrorCode = exports.Empty = exports.delay = exports.deferred = exports.DebugEvents = exports.deadline = exports.credsAuthenticator = exports.createInbox = exports.canonicalMIMEHeaderKey = exports.buildAuthenticator = exports.Bench = exports.backoff = void 0;\nvar internal_mod_1 = __webpack_require__(/*! ./internal_mod */ \"(rsc)/./node_modules/nats/lib/nats-base-client/internal_mod.js\");\nObject.defineProperty(exports, \"backoff\", ({ enumerable: true, get: function () { return internal_mod_1.backoff; } }));\nObject.defineProperty(exports, \"Bench\", ({ enumerable: true, get: function () { return internal_mod_1.Bench; } }));\nObject.defineProperty(exports, \"buildAuthenticator\", ({ enumerable: true, get: function () { return internal_mod_1.buildAuthenticator; } }));\nObject.defineProperty(exports, \"canonicalMIMEHeaderKey\", ({ enumerable: true, get: function () { return internal_mod_1.canonicalMIMEHeaderKey; } }));\nObject.defineProperty(exports, \"createInbox\", ({ enumerable: true, get: function () { return internal_mod_1.createInbox; } }));\nObject.defineProperty(exports, \"credsAuthenticator\", ({ enumerable: true, get: function () { return internal_mod_1.credsAuthenticator; } }));\nObject.defineProperty(exports, \"deadline\", ({ enumerable: true, get: function () { return internal_mod_1.deadline; } }));\nObject.defineProperty(exports, \"DebugEvents\", ({ enumerable: true, get: function () { return internal_mod_1.DebugEvents; } }));\nObject.defineProperty(exports, \"deferred\", ({ enumerable: true, get: function () { return internal_mod_1.deferred; } }));\nObject.defineProperty(exports, \"delay\", ({ enumerable: true, get: function () { return internal_mod_1.delay; } }));\nObject.defineProperty(exports, \"Empty\", ({ enumerable: true, get: function () { return internal_mod_1.Empty; } }));\nObject.defineProperty(exports, \"ErrorCode\", ({ enumerable: true, get: function () { return internal_mod_1.ErrorCode; } }));\nObject.defineProperty(exports, \"Events\", ({ enumerable: true, get: function () { return internal_mod_1.Events; } }));\nObject.defineProperty(exports, \"headers\", ({ enumerable: true, get: function () { return internal_mod_1.headers; } }));\nObject.defineProperty(exports, \"JSONCodec\", ({ enumerable: true, get: function () { return internal_mod_1.JSONCodec; } }));\nObject.defineProperty(exports, \"jwtAuthenticator\", ({ enumerable: true, get: function () { return internal_mod_1.jwtAuthenticator; } }));\nObject.defineProperty(exports, \"Match\", ({ enumerable: true, get: function () { return internal_mod_1.Match; } }));\nObject.defineProperty(exports, \"Metric\", ({ enumerable: true, get: function () { return internal_mod_1.Metric; } }));\nObject.defineProperty(exports, \"MsgHdrsImpl\", ({ enumerable: true, get: function () { return internal_mod_1.MsgHdrsImpl; } }));\nObject.defineProperty(exports, \"NatsError\", ({ enumerable: true, get: function () { return internal_mod_1.NatsError; } }));\nObject.defineProperty(exports, \"nkeyAuthenticator\", ({ enumerable: true, get: function () { return internal_mod_1.nkeyAuthenticator; } }));\nObject.defineProperty(exports, \"nkeys\", ({ enumerable: true, get: function () { return internal_mod_1.nkeys; } }));\nObject.defineProperty(exports, \"Nuid\", ({ enumerable: true, get: function () { return internal_mod_1.Nuid; } }));\nObject.defineProperty(exports, \"nuid\", ({ enumerable: true, get: function () { return internal_mod_1.nuid; } }));\nObject.defineProperty(exports, \"RequestStrategy\", ({ enumerable: true, get: function () { return internal_mod_1.RequestStrategy; } }));\nObject.defineProperty(exports, \"ServiceError\", ({ enumerable: true, get: function () { return internal_mod_1.ServiceError; } }));\nObject.defineProperty(exports, \"ServiceErrorCodeHeader\", ({ enumerable: true, get: function () { return internal_mod_1.ServiceErrorCodeHeader; } }));\nObject.defineProperty(exports, \"ServiceErrorHeader\", ({ enumerable: true, get: function () { return internal_mod_1.ServiceErrorHeader; } }));\nObject.defineProperty(exports, \"ServiceResponseType\", ({ enumerable: true, get: function () { return internal_mod_1.ServiceResponseType; } }));\nObject.defineProperty(exports, \"ServiceVerb\", ({ enumerable: true, get: function () { return internal_mod_1.ServiceVerb; } }));\nObject.defineProperty(exports, \"StringCodec\", ({ enumerable: true, get: function () { return internal_mod_1.StringCodec; } }));\nObject.defineProperty(exports, \"syncIterator\", ({ enumerable: true, get: function () { return internal_mod_1.syncIterator; } }));\nObject.defineProperty(exports, \"tokenAuthenticator\", ({ enumerable: true, get: function () { return internal_mod_1.tokenAuthenticator; } }));\nObject.defineProperty(exports, \"usernamePasswordAuthenticator\", ({ enumerable: true, get: function () { return internal_mod_1.usernamePasswordAuthenticator; } }));\n//# sourceMappingURL=mod.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9tb2QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDLEdBQUcsMEJBQTBCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsMkJBQTJCLEdBQUcsMEJBQTBCLEdBQUcsOEJBQThCLEdBQUcsb0JBQW9CLEdBQUcsdUJBQXVCLEdBQUcsWUFBWSxHQUFHLFlBQVksR0FBRyxhQUFhLEdBQUcseUJBQXlCLEdBQUcsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyx3QkFBd0IsR0FBRyxpQkFBaUIsR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLGlCQUFpQixHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CLEdBQUcsZ0JBQWdCLEdBQUcsMEJBQTBCLEdBQUcsbUJBQW1CLEdBQUcsOEJBQThCLEdBQUcsMEJBQTBCLEdBQUcsYUFBYSxHQUFHLGVBQWU7QUFDNXZCLHFCQUFxQixtQkFBTyxDQUFDLHNGQUFnQjtBQUM3QywyQ0FBMEMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDcEgseUNBQXdDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2hILHNEQUFxRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUMxSSwwREFBeUQsRUFBRSxxQ0FBcUMsaURBQWlELEVBQUM7QUFDbEosK0NBQThDLEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzVILHNEQUFxRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUMxSSw0Q0FBMkMsRUFBRSxxQ0FBcUMsbUNBQW1DLEVBQUM7QUFDdEgsK0NBQThDLEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQzVILDRDQUEyQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN0SCx5Q0FBd0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDaEgseUNBQXdDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2hILDZDQUE0QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUN4SCwwQ0FBeUMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDbEgsMkNBQTBDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3BILDZDQUE0QyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUN4SCxvREFBbUQsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDdEkseUNBQXdDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2hILDBDQUF5QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNsSCwrQ0FBOEMsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDNUgsNkNBQTRDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3hILHFEQUFvRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUN4SSx5Q0FBd0MsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDaEgsd0NBQXVDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQzlHLHdDQUF1QyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUM5RyxtREFBa0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDcEksZ0RBQStDLEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQzlILDBEQUF5RCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUNsSixzREFBcUQsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDMUksdURBQXNELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQzVJLCtDQUE4QyxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUM1SCwrQ0FBOEMsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDNUgsZ0RBQStDLEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQzlILHNEQUFxRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUMxSSxpRUFBZ0UsRUFBRSxxQ0FBcUMsd0RBQXdELEVBQUM7QUFDaEsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L21vZC5qcz8xOGZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51c2VybmFtZVBhc3N3b3JkQXV0aGVudGljYXRvciA9IGV4cG9ydHMudG9rZW5BdXRoZW50aWNhdG9yID0gZXhwb3J0cy5zeW5jSXRlcmF0b3IgPSBleHBvcnRzLlN0cmluZ0NvZGVjID0gZXhwb3J0cy5TZXJ2aWNlVmVyYiA9IGV4cG9ydHMuU2VydmljZVJlc3BvbnNlVHlwZSA9IGV4cG9ydHMuU2VydmljZUVycm9ySGVhZGVyID0gZXhwb3J0cy5TZXJ2aWNlRXJyb3JDb2RlSGVhZGVyID0gZXhwb3J0cy5TZXJ2aWNlRXJyb3IgPSBleHBvcnRzLlJlcXVlc3RTdHJhdGVneSA9IGV4cG9ydHMubnVpZCA9IGV4cG9ydHMuTnVpZCA9IGV4cG9ydHMubmtleXMgPSBleHBvcnRzLm5rZXlBdXRoZW50aWNhdG9yID0gZXhwb3J0cy5OYXRzRXJyb3IgPSBleHBvcnRzLk1zZ0hkcnNJbXBsID0gZXhwb3J0cy5NZXRyaWMgPSBleHBvcnRzLk1hdGNoID0gZXhwb3J0cy5qd3RBdXRoZW50aWNhdG9yID0gZXhwb3J0cy5KU09OQ29kZWMgPSBleHBvcnRzLmhlYWRlcnMgPSBleHBvcnRzLkV2ZW50cyA9IGV4cG9ydHMuRXJyb3JDb2RlID0gZXhwb3J0cy5FbXB0eSA9IGV4cG9ydHMuZGVsYXkgPSBleHBvcnRzLmRlZmVycmVkID0gZXhwb3J0cy5EZWJ1Z0V2ZW50cyA9IGV4cG9ydHMuZGVhZGxpbmUgPSBleHBvcnRzLmNyZWRzQXV0aGVudGljYXRvciA9IGV4cG9ydHMuY3JlYXRlSW5ib3ggPSBleHBvcnRzLmNhbm9uaWNhbE1JTUVIZWFkZXJLZXkgPSBleHBvcnRzLmJ1aWxkQXV0aGVudGljYXRvciA9IGV4cG9ydHMuQmVuY2ggPSBleHBvcnRzLmJhY2tvZmYgPSB2b2lkIDA7XG52YXIgaW50ZXJuYWxfbW9kXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbF9tb2RcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJiYWNrb2ZmXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5iYWNrb2ZmOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmVuY2hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8xLkJlbmNoOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYnVpbGRBdXRoZW50aWNhdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5idWlsZEF1dGhlbnRpY2F0b3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjYW5vbmljYWxNSU1FSGVhZGVyS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5jYW5vbmljYWxNSU1FSGVhZGVyS2V5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlSW5ib3hcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8xLmNyZWF0ZUluYm94OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlZHNBdXRoZW50aWNhdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5jcmVkc0F1dGhlbnRpY2F0b3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWFkbGluZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuZGVhZGxpbmU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWJ1Z0V2ZW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuRGVidWdFdmVudHM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZlcnJlZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuZGVmZXJyZWQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWxheVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuZGVsYXk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFbXB0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuRW1wdHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFcnJvckNvZGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8xLkVycm9yQ29kZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV2ZW50c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuRXZlbnRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGVhZGVyc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuaGVhZGVyczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkpTT05Db2RlY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuSlNPTkNvZGVjOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiand0QXV0aGVudGljYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuand0QXV0aGVudGljYXRvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1hdGNoXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5NYXRjaDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1ldHJpY1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuTWV0cmljOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTXNnSGRyc0ltcGxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8xLk1zZ0hkcnNJbXBsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTmF0c0Vycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5OYXRzRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJua2V5QXV0aGVudGljYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEubmtleUF1dGhlbnRpY2F0b3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJua2V5c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEubmtleXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOdWlkXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5OdWlkOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibnVpZFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEubnVpZDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RTdHJhdGVneVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJuYWxfbW9kXzEuUmVxdWVzdFN0cmF0ZWd5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmljZUVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5TZXJ2aWNlRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2aWNlRXJyb3JDb2RlSGVhZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5TZXJ2aWNlRXJyb3JDb2RlSGVhZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmljZUVycm9ySGVhZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5TZXJ2aWNlRXJyb3JIZWFkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2aWNlUmVzcG9uc2VUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5TZXJ2aWNlUmVzcG9uc2VUeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmljZVZlcmJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8xLlNlcnZpY2VWZXJiOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RyaW5nQ29kZWNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8xLlN0cmluZ0NvZGVjOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3luY0l0ZXJhdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS5zeW5jSXRlcmF0b3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0b2tlbkF1dGhlbnRpY2F0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGludGVybmFsX21vZF8xLnRva2VuQXV0aGVudGljYXRvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVzZXJuYW1lUGFzc3dvcmRBdXRoZW50aWNhdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnRlcm5hbF9tb2RfMS51c2VybmFtZVBhc3N3b3JkQXV0aGVudGljYXRvcjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/mod.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/msg.js":
/*!*******************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/msg.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MsgImpl = exports.isRequestError = void 0;\n/*\n * Copyright 2020-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst headers_1 = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/nats/lib/nats-base-client/headers.js\");\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst codec_1 = __webpack_require__(/*! ./codec */ \"(rsc)/./node_modules/nats/lib/nats-base-client/codec.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nfunction isRequestError(msg) {\n    var _a;\n    // NATS core only considers errors 503s on messages that have no payload\n    // everything else simply forwarded as part of the message and is considered\n    // application level information\n    if (msg && msg.data.length === 0 && ((_a = msg.headers) === null || _a === void 0 ? void 0 : _a.code) === 503) {\n        return core_1.NatsError.errorForCode(core_1.ErrorCode.NoResponders);\n    }\n    return null;\n}\nexports.isRequestError = isRequestError;\nclass MsgImpl {\n    constructor(msg, data, publisher) {\n        this._msg = msg;\n        this._rdata = data;\n        this.publisher = publisher;\n    }\n    get subject() {\n        if (this._subject) {\n            return this._subject;\n        }\n        this._subject = encoders_1.TD.decode(this._msg.subject);\n        return this._subject;\n    }\n    get reply() {\n        if (this._reply) {\n            return this._reply;\n        }\n        this._reply = encoders_1.TD.decode(this._msg.reply);\n        return this._reply;\n    }\n    get sid() {\n        return this._msg.sid;\n    }\n    get headers() {\n        if (this._msg.hdr > -1 && !this._headers) {\n            const buf = this._rdata.subarray(0, this._msg.hdr);\n            this._headers = headers_1.MsgHdrsImpl.decode(buf);\n        }\n        return this._headers;\n    }\n    get data() {\n        if (!this._rdata) {\n            return new Uint8Array(0);\n        }\n        return this._msg.hdr > -1\n            ? this._rdata.subarray(this._msg.hdr)\n            : this._rdata;\n    }\n    // eslint-ignore-next-line @typescript-eslint/no-explicit-any\n    respond(data = encoders_1.Empty, opts) {\n        if (this.reply) {\n            this.publisher.publish(this.reply, data, opts);\n            return true;\n        }\n        return false;\n    }\n    size() {\n        var _a;\n        const subj = this._msg.subject.length;\n        const reply = ((_a = this._msg.reply) === null || _a === void 0 ? void 0 : _a.length) || 0;\n        const payloadAndHeaders = this._msg.size === -1 ? 0 : this._msg.size;\n        return subj + reply + payloadAndHeaders;\n    }\n    json(reviver) {\n        return (0, codec_1.JSONCodec)(reviver).decode(this.data);\n    }\n    string() {\n        return encoders_1.TD.decode(this.data);\n    }\n}\nexports.MsgImpl = MsgImpl;\n//# sourceMappingURL=msg.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9tc2cuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZSxHQUFHLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsNEVBQVc7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsOEVBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQVM7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL25hdHMtYmFzZS1jbGllbnQvbXNnLmpzPzZiNjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1zZ0ltcGwgPSBleHBvcnRzLmlzUmVxdWVzdEVycm9yID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCAyMDIwLTIwMjMgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IGhlYWRlcnNfMSA9IHJlcXVpcmUoXCIuL2hlYWRlcnNcIik7XG5jb25zdCBlbmNvZGVyc18xID0gcmVxdWlyZShcIi4vZW5jb2RlcnNcIik7XG5jb25zdCBjb2RlY18xID0gcmVxdWlyZShcIi4vY29kZWNcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuZnVuY3Rpb24gaXNSZXF1ZXN0RXJyb3IobXNnKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIE5BVFMgY29yZSBvbmx5IGNvbnNpZGVycyBlcnJvcnMgNTAzcyBvbiBtZXNzYWdlcyB0aGF0IGhhdmUgbm8gcGF5bG9hZFxuICAgIC8vIGV2ZXJ5dGhpbmcgZWxzZSBzaW1wbHkgZm9yd2FyZGVkIGFzIHBhcnQgb2YgdGhlIG1lc3NhZ2UgYW5kIGlzIGNvbnNpZGVyZWRcbiAgICAvLyBhcHBsaWNhdGlvbiBsZXZlbCBpbmZvcm1hdGlvblxuICAgIGlmIChtc2cgJiYgbXNnLmRhdGEubGVuZ3RoID09PSAwICYmICgoX2EgPSBtc2cuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSA1MDMpIHtcbiAgICAgICAgcmV0dXJuIGNvcmVfMS5OYXRzRXJyb3IuZXJyb3JGb3JDb2RlKGNvcmVfMS5FcnJvckNvZGUuTm9SZXNwb25kZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmlzUmVxdWVzdEVycm9yID0gaXNSZXF1ZXN0RXJyb3I7XG5jbGFzcyBNc2dJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2csIGRhdGEsIHB1Ymxpc2hlcikge1xuICAgICAgICB0aGlzLl9tc2cgPSBtc2c7XG4gICAgICAgIHRoaXMuX3JkYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5wdWJsaXNoZXIgPSBwdWJsaXNoZXI7XG4gICAgfVxuICAgIGdldCBzdWJqZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5fc3ViamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IGVuY29kZXJzXzEuVEQuZGVjb2RlKHRoaXMuX21zZy5zdWJqZWN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1YmplY3Q7XG4gICAgfVxuICAgIGdldCByZXBseSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcGx5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVwbHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVwbHkgPSBlbmNvZGVyc18xLlRELmRlY29kZSh0aGlzLl9tc2cucmVwbHkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVwbHk7XG4gICAgfVxuICAgIGdldCBzaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tc2cuc2lkO1xuICAgIH1cbiAgICBnZXQgaGVhZGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX21zZy5oZHIgPiAtMSAmJiAhdGhpcy5faGVhZGVycykge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gdGhpcy5fcmRhdGEuc3ViYXJyYXkoMCwgdGhpcy5fbXNnLmhkcik7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJzID0gaGVhZGVyc18xLk1zZ0hkcnNJbXBsLmRlY29kZShidWYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzO1xuICAgIH1cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tc2cuaGRyID4gLTFcbiAgICAgICAgICAgID8gdGhpcy5fcmRhdGEuc3ViYXJyYXkodGhpcy5fbXNnLmhkcilcbiAgICAgICAgICAgIDogdGhpcy5fcmRhdGE7XG4gICAgfVxuICAgIC8vIGVzbGludC1pZ25vcmUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXNwb25kKGRhdGEgPSBlbmNvZGVyc18xLkVtcHR5LCBvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcGx5KSB7XG4gICAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5wdWJsaXNoKHRoaXMucmVwbHksIGRhdGEsIG9wdHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzaXplKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHN1YmogPSB0aGlzLl9tc2cuc3ViamVjdC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJlcGx5ID0gKChfYSA9IHRoaXMuX21zZy5yZXBseSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgY29uc3QgcGF5bG9hZEFuZEhlYWRlcnMgPSB0aGlzLl9tc2cuc2l6ZSA9PT0gLTEgPyAwIDogdGhpcy5fbXNnLnNpemU7XG4gICAgICAgIHJldHVybiBzdWJqICsgcmVwbHkgKyBwYXlsb2FkQW5kSGVhZGVycztcbiAgICB9XG4gICAganNvbihyZXZpdmVyKSB7XG4gICAgICAgIHJldHVybiAoMCwgY29kZWNfMS5KU09OQ29kZWMpKHJldml2ZXIpLmRlY29kZSh0aGlzLmRhdGEpO1xuICAgIH1cbiAgICBzdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVyc18xLlRELmRlY29kZSh0aGlzLmRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuTXNnSW1wbCA9IE1zZ0ltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tc2cuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/msg.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/muxsubscription.js":
/*!*******************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/muxsubscription.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MuxSubscription = void 0;\n/*\n * Copyright 2020-2021 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst msg_1 = __webpack_require__(/*! ./msg */ \"(rsc)/./node_modules/nats/lib/nats-base-client/msg.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nclass MuxSubscription {\n    constructor() {\n        this.reqs = new Map();\n    }\n    size() {\n        return this.reqs.size;\n    }\n    init(prefix) {\n        this.baseInbox = `${(0, core_1.createInbox)(prefix)}.`;\n        return this.baseInbox;\n    }\n    add(r) {\n        if (!isNaN(r.received)) {\n            r.received = 0;\n        }\n        this.reqs.set(r.token, r);\n    }\n    get(token) {\n        return this.reqs.get(token);\n    }\n    cancel(r) {\n        this.reqs.delete(r.token);\n    }\n    getToken(m) {\n        const s = m.subject || \"\";\n        if (s.indexOf(this.baseInbox) === 0) {\n            return s.substring(this.baseInbox.length);\n        }\n        return null;\n    }\n    all() {\n        return Array.from(this.reqs.values());\n    }\n    handleError(isMuxPermissionError, err) {\n        if (err && err.permissionContext) {\n            if (isMuxPermissionError) {\n                // one or more requests queued but mux cannot process them\n                this.all().forEach((r) => {\n                    r.resolver(err, {});\n                });\n                return true;\n            }\n            const ctx = err.permissionContext;\n            if (ctx.operation === \"publish\") {\n                const req = this.all().find((s) => {\n                    return s.requestSubject === ctx.subject;\n                });\n                if (req) {\n                    req.resolver(err, {});\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    dispatcher() {\n        return (err, m) => {\n            const token = this.getToken(m);\n            if (token) {\n                const r = this.get(token);\n                if (r) {\n                    if (err === null && m.headers) {\n                        err = (0, msg_1.isRequestError)(m);\n                    }\n                    r.resolver(err, m);\n                }\n            }\n        };\n    }\n    close() {\n        const err = core_1.NatsError.errorForCode(core_1.ErrorCode.Timeout);\n        this.reqs.forEach((req) => {\n            req.resolver(err, {});\n        });\n    }\n}\nexports.MuxSubscription = MuxSubscription;\n//# sourceMappingURL=muxsubscription.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9tdXhzdWJzY3JpcHRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1CQUFPLENBQUMsb0VBQU87QUFDN0IsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9tdXhzdWJzY3JpcHRpb24uanM/NThjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTXV4U3Vic2NyaXB0aW9uID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCAyMDIwLTIwMjEgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG1zZ18xID0gcmVxdWlyZShcIi4vbXNnXCIpO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNsYXNzIE11eFN1YnNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVxcyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxcy5zaXplO1xuICAgIH1cbiAgICBpbml0KHByZWZpeCkge1xuICAgICAgICB0aGlzLmJhc2VJbmJveCA9IGAkeygwLCBjb3JlXzEuY3JlYXRlSW5ib3gpKHByZWZpeCl9LmA7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VJbmJveDtcbiAgICB9XG4gICAgYWRkKHIpIHtcbiAgICAgICAgaWYgKCFpc05hTihyLnJlY2VpdmVkKSkge1xuICAgICAgICAgICAgci5yZWNlaXZlZCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXFzLnNldChyLnRva2VuLCByKTtcbiAgICB9XG4gICAgZ2V0KHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXMuZ2V0KHRva2VuKTtcbiAgICB9XG4gICAgY2FuY2VsKHIpIHtcbiAgICAgICAgdGhpcy5yZXFzLmRlbGV0ZShyLnRva2VuKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4obSkge1xuICAgICAgICBjb25zdCBzID0gbS5zdWJqZWN0IHx8IFwiXCI7XG4gICAgICAgIGlmIChzLmluZGV4T2YodGhpcy5iYXNlSW5ib3gpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcy5zdWJzdHJpbmcodGhpcy5iYXNlSW5ib3gubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnJlcXMudmFsdWVzKCkpO1xuICAgIH1cbiAgICBoYW5kbGVFcnJvcihpc011eFBlcm1pc3Npb25FcnJvciwgZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLnBlcm1pc3Npb25Db250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaXNNdXhQZXJtaXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBvbmUgb3IgbW9yZSByZXF1ZXN0cyBxdWV1ZWQgYnV0IG11eCBjYW5ub3QgcHJvY2VzcyB0aGVtXG4gICAgICAgICAgICAgICAgdGhpcy5hbGwoKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHIucmVzb2x2ZXIoZXJyLCB7fSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdHggPSBlcnIucGVybWlzc2lvbkNvbnRleHQ7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wZXJhdGlvbiA9PT0gXCJwdWJsaXNoXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXEgPSB0aGlzLmFsbCgpLmZpbmQoKHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMucmVxdWVzdFN1YmplY3QgPT09IGN0eC5zdWJqZWN0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLnJlc29sdmVyKGVyciwge30pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkaXNwYXRjaGVyKCkge1xuICAgICAgICByZXR1cm4gKGVyciwgbSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldFRva2VuKG0pO1xuICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuZ2V0KHRva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyID09PSBudWxsICYmIG0uaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gKDAsIG1zZ18xLmlzUmVxdWVzdEVycm9yKShtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByLnJlc29sdmVyKGVyciwgbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgY29uc3QgZXJyID0gY29yZV8xLk5hdHNFcnJvci5lcnJvckZvckNvZGUoY29yZV8xLkVycm9yQ29kZS5UaW1lb3V0KTtcbiAgICAgICAgdGhpcy5yZXFzLmZvckVhY2goKHJlcSkgPT4ge1xuICAgICAgICAgICAgcmVxLnJlc29sdmVyKGVyciwge30pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk11eFN1YnNjcmlwdGlvbiA9IE11eFN1YnNjcmlwdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW11eHN1YnNjcmlwdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/muxsubscription.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/nats.js":
/*!********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/nats.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2018-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServicesFactory = exports.NatsConnectionImpl = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst protocol_1 = __webpack_require__(/*! ./protocol */ \"(rsc)/./node_modules/nats/lib/nats-base-client/protocol.js\");\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"(rsc)/./node_modules/nats/lib/nats-base-client/types.js\");\nconst semver_1 = __webpack_require__(/*! ./semver */ \"(rsc)/./node_modules/nats/lib/nats-base-client/semver.js\");\nconst options_1 = __webpack_require__(/*! ./options */ \"(rsc)/./node_modules/nats/lib/nats-base-client/options.js\");\nconst queued_iterator_1 = __webpack_require__(/*! ./queued_iterator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\");\nconst request_1 = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/nats/lib/nats-base-client/request.js\");\nconst msg_1 = __webpack_require__(/*! ./msg */ \"(rsc)/./node_modules/nats/lib/nats-base-client/msg.js\");\nconst jsm_1 = __webpack_require__(/*! ../jetstream/jsm */ \"(rsc)/./node_modules/nats/lib/jetstream/jsm.js\");\nconst jsclient_1 = __webpack_require__(/*! ../jetstream/jsclient */ \"(rsc)/./node_modules/nats/lib/jetstream/jsclient.js\");\nconst service_1 = __webpack_require__(/*! ./service */ \"(rsc)/./node_modules/nats/lib/nats-base-client/service.js\");\nconst serviceclient_1 = __webpack_require__(/*! ./serviceclient */ \"(rsc)/./node_modules/nats/lib/nats-base-client/serviceclient.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nclass NatsConnectionImpl {\n    constructor(opts) {\n        this.draining = false;\n        this.options = (0, options_1.parseOptions)(opts);\n        this.listeners = [];\n    }\n    static connect(opts = {}) {\n        return new Promise((resolve, reject) => {\n            const nc = new NatsConnectionImpl(opts);\n            protocol_1.ProtocolHandler.connect(nc.options, nc)\n                .then((ph) => {\n                nc.protocol = ph;\n                (function () {\n                    var _a, e_1, _b, _c;\n                    return __awaiter(this, void 0, void 0, function* () {\n                        try {\n                            for (var _d = true, _e = __asyncValues(ph.status()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                                _c = _f.value;\n                                _d = false;\n                                const s = _c;\n                                nc.listeners.forEach((l) => {\n                                    l.push(s);\n                                });\n                            }\n                        }\n                        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                        finally {\n                            try {\n                                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                            }\n                            finally { if (e_1) throw e_1.error; }\n                        }\n                    });\n                })();\n                resolve(nc);\n            })\n                .catch((err) => {\n                reject(err);\n            });\n        });\n    }\n    closed() {\n        return this.protocol.closed;\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.protocol.close();\n        });\n    }\n    _check(subject, sub, pub) {\n        if (this.isClosed()) {\n            throw types_1.NatsError.errorForCode(core_1.ErrorCode.ConnectionClosed);\n        }\n        if (sub && this.isDraining()) {\n            throw types_1.NatsError.errorForCode(core_1.ErrorCode.ConnectionDraining);\n        }\n        if (pub && this.protocol.noMorePublishing) {\n            throw types_1.NatsError.errorForCode(core_1.ErrorCode.ConnectionDraining);\n        }\n        subject = subject || \"\";\n        if (subject.length === 0) {\n            throw types_1.NatsError.errorForCode(core_1.ErrorCode.BadSubject);\n        }\n    }\n    publish(subject, data, options) {\n        this._check(subject, false, true);\n        this.protocol.publish(subject, data, options);\n    }\n    subscribe(subject, opts = {}) {\n        this._check(subject, true, false);\n        const sub = new protocol_1.SubscriptionImpl(this.protocol, subject, opts);\n        this.protocol.subscribe(sub);\n        return sub;\n    }\n    _resub(s, subject, max) {\n        this._check(subject, true, false);\n        const si = s;\n        // FIXME: need way of understanding a callbacks processed\n        //   count without it, we cannot really do much - ie\n        //   for rejected messages, the count would be lower, etc.\n        //   To handle cases were for example KV is building a map\n        //   the consumer would say how many messages we need to do\n        //   a proper build before we can handle updates.\n        si.max = max; // this might clear it\n        if (max) {\n            // we cannot auto-unsub, because we don't know the\n            // number of messages we processed vs received\n            // allow the auto-unsub on processMsg to work if they\n            // we were called with a new max\n            si.max = max + si.received;\n        }\n        this.protocol.resub(si, subject);\n    }\n    // possibilities are:\n    // stop on error or any non-100 status\n    // AND:\n    // - wait for timer\n    // - wait for n messages or timer\n    // - wait for unknown messages, done when empty or reset timer expires (with possible alt wait)\n    // - wait for unknown messages, done when an empty payload is received or timer expires (with possible alt wait)\n    requestMany(subject, data = encoders_1.Empty, opts = { maxWait: 1000, maxMessages: -1 }) {\n        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);\n        try {\n            this._check(subject, true, true);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n        opts.strategy = opts.strategy || core_1.RequestStrategy.Timer;\n        opts.maxWait = opts.maxWait || 1000;\n        if (opts.maxWait < 1) {\n            return Promise.reject(new types_1.NatsError(\"timeout\", core_1.ErrorCode.InvalidOption));\n        }\n        // the iterator for user results\n        const qi = new queued_iterator_1.QueuedIteratorImpl();\n        function stop(err) {\n            //@ts-ignore: stop function\n            qi.push(() => {\n                qi.stop(err);\n            });\n        }\n        // callback for the subscription or the mux handler\n        // simply pushes errors and messages into the iterator\n        function callback(err, msg) {\n            if (err || msg === null) {\n                stop(err === null ? undefined : err);\n            }\n            else {\n                qi.push(msg);\n            }\n        }\n        if (opts.noMux) {\n            // we setup a subscription and manage it\n            const stack = asyncTraces ? new Error().stack : null;\n            let max = typeof opts.maxMessages === \"number\" && opts.maxMessages > 0\n                ? opts.maxMessages\n                : -1;\n            const sub = this.subscribe((0, core_1.createInbox)(this.options.inboxPrefix), {\n                callback: (err, msg) => {\n                    var _a, _b;\n                    // we only expect runtime errors or a no responders\n                    if (((_a = msg === null || msg === void 0 ? void 0 : msg.data) === null || _a === void 0 ? void 0 : _a.length) === 0 &&\n                        ((_b = msg === null || msg === void 0 ? void 0 : msg.headers) === null || _b === void 0 ? void 0 : _b.status) === core_1.ErrorCode.NoResponders) {\n                        err = types_1.NatsError.errorForCode(core_1.ErrorCode.NoResponders);\n                    }\n                    // augment any error with the current stack to provide context\n                    // for the error on the suer code\n                    if (err) {\n                        if (stack) {\n                            err.stack += `\\n\\n${stack}`;\n                        }\n                        cancel(err);\n                        return;\n                    }\n                    // push the message\n                    callback(null, msg);\n                    // see if the m request is completed\n                    if (opts.strategy === core_1.RequestStrategy.Count) {\n                        max--;\n                        if (max === 0) {\n                            cancel();\n                        }\n                    }\n                    if (opts.strategy === core_1.RequestStrategy.JitterTimer) {\n                        clearTimers();\n                        timer = setTimeout(() => {\n                            cancel();\n                        }, 300);\n                    }\n                    if (opts.strategy === core_1.RequestStrategy.SentinelMsg) {\n                        if (msg && msg.data.length === 0) {\n                            cancel();\n                        }\n                    }\n                },\n            });\n            sub.closed\n                .then(() => {\n                stop();\n            })\n                .catch((err) => {\n                qi.stop(err);\n            });\n            const cancel = (err) => {\n                if (err) {\n                    //@ts-ignore: error\n                    qi.push(() => {\n                        throw err;\n                    });\n                }\n                clearTimers();\n                sub.drain()\n                    .then(() => {\n                    stop();\n                })\n                    .catch((_err) => {\n                    stop();\n                });\n            };\n            qi.iterClosed\n                .then(() => {\n                clearTimers();\n                sub === null || sub === void 0 ? void 0 : sub.unsubscribe();\n            })\n                .catch((_err) => {\n                clearTimers();\n                sub === null || sub === void 0 ? void 0 : sub.unsubscribe();\n            });\n            try {\n                this.publish(subject, data, { reply: sub.getSubject() });\n            }\n            catch (err) {\n                cancel(err);\n            }\n            let timer = setTimeout(() => {\n                cancel();\n            }, opts.maxWait);\n            const clearTimers = () => {\n                if (timer) {\n                    clearTimeout(timer);\n                }\n            };\n        }\n        else {\n            // the ingestion is the RequestMany\n            const rmo = opts;\n            rmo.callback = callback;\n            qi.iterClosed.then(() => {\n                r.cancel();\n            }).catch((err) => {\n                r.cancel(err);\n            });\n            const r = new request_1.RequestMany(this.protocol.muxSubscriptions, subject, rmo);\n            this.protocol.request(r);\n            try {\n                this.publish(subject, data, {\n                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,\n                    headers: opts.headers,\n                });\n            }\n            catch (err) {\n                r.cancel(err);\n            }\n        }\n        return Promise.resolve(qi);\n    }\n    request(subject, data, opts = { timeout: 1000, noMux: false }) {\n        try {\n            this._check(subject, true, true);\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);\n        opts.timeout = opts.timeout || 1000;\n        if (opts.timeout < 1) {\n            return Promise.reject(new types_1.NatsError(\"timeout\", core_1.ErrorCode.InvalidOption));\n        }\n        if (!opts.noMux && opts.reply) {\n            return Promise.reject(new types_1.NatsError(\"reply can only be used with noMux\", core_1.ErrorCode.InvalidOption));\n        }\n        if (opts.noMux) {\n            const inbox = opts.reply\n                ? opts.reply\n                : (0, core_1.createInbox)(this.options.inboxPrefix);\n            const d = (0, util_1.deferred)();\n            const errCtx = asyncTraces ? new Error() : null;\n            const sub = this.subscribe(inbox, {\n                max: 1,\n                timeout: opts.timeout,\n                callback: (err, msg) => {\n                    if (err) {\n                        // timeouts from `timeout()` will have the proper stack\n                        if (errCtx && err.code !== core_1.ErrorCode.Timeout) {\n                            err.stack += `\\n\\n${errCtx.stack}`;\n                        }\n                        d.reject(err);\n                    }\n                    else {\n                        err = (0, msg_1.isRequestError)(msg);\n                        if (err) {\n                            // if we failed here, help the developer by showing what failed\n                            if (errCtx) {\n                                err.stack += `\\n\\n${errCtx.stack}`;\n                            }\n                            d.reject(err);\n                        }\n                        else {\n                            d.resolve(msg);\n                        }\n                    }\n                },\n            });\n            sub.requestSubject = subject;\n            this.protocol.publish(subject, data, {\n                reply: inbox,\n                headers: opts.headers,\n            });\n            return d;\n        }\n        else {\n            const r = new request_1.RequestOne(this.protocol.muxSubscriptions, subject, opts, asyncTraces);\n            this.protocol.request(r);\n            try {\n                this.publish(subject, data, {\n                    reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,\n                    headers: opts.headers,\n                });\n            }\n            catch (err) {\n                r.cancel(err);\n            }\n            const p = Promise.race([r.timer, r.deferred]);\n            p.catch(() => {\n                r.cancel();\n            });\n            return p;\n        }\n    }\n    /** *\n     * Flushes to the server. Promise resolves when round-trip completes.\n     * @returns {Promise<void>}\n     */\n    flush() {\n        if (this.isClosed()) {\n            return Promise.reject(types_1.NatsError.errorForCode(core_1.ErrorCode.ConnectionClosed));\n        }\n        return this.protocol.flush();\n    }\n    drain() {\n        if (this.isClosed()) {\n            return Promise.reject(types_1.NatsError.errorForCode(core_1.ErrorCode.ConnectionClosed));\n        }\n        if (this.isDraining()) {\n            return Promise.reject(types_1.NatsError.errorForCode(core_1.ErrorCode.ConnectionDraining));\n        }\n        this.draining = true;\n        return this.protocol.drain();\n    }\n    isClosed() {\n        return this.protocol.isClosed();\n    }\n    isDraining() {\n        return this.draining;\n    }\n    getServer() {\n        const srv = this.protocol.getServer();\n        return srv ? srv.listen : \"\";\n    }\n    status() {\n        const iter = new queued_iterator_1.QueuedIteratorImpl();\n        iter.iterClosed.then(() => {\n            const idx = this.listeners.indexOf(iter);\n            this.listeners.splice(idx, 1);\n        });\n        this.listeners.push(iter);\n        return iter;\n    }\n    get info() {\n        return this.protocol.isClosed() ? undefined : this.protocol.info;\n    }\n    stats() {\n        return {\n            inBytes: this.protocol.inBytes,\n            outBytes: this.protocol.outBytes,\n            inMsgs: this.protocol.inMsgs,\n            outMsgs: this.protocol.outMsgs,\n        };\n    }\n    jetstreamManager(opts = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const adm = new jsm_1.JetStreamManagerImpl(this, opts);\n            if (opts.checkAPI !== false) {\n                try {\n                    yield adm.getAccountInfo();\n                }\n                catch (err) {\n                    const ne = err;\n                    if (ne.code === core_1.ErrorCode.NoResponders) {\n                        ne.code = core_1.ErrorCode.JetStreamNotEnabled;\n                    }\n                    throw ne;\n                }\n            }\n            return adm;\n        });\n    }\n    jetstream(opts = {}) {\n        return new jsclient_1.JetStreamClientImpl(this, opts);\n    }\n    getServerVersion() {\n        const info = this.info;\n        return info ? (0, semver_1.parseSemVer)(info.version) : undefined;\n    }\n    rtt() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.protocol._closed && !this.protocol.connected) {\n                throw types_1.NatsError.errorForCode(core_1.ErrorCode.Disconnect);\n            }\n            const start = Date.now();\n            yield this.flush();\n            return Date.now() - start;\n        });\n    }\n    get features() {\n        return this.protocol.features;\n    }\n    get services() {\n        if (!this._services) {\n            this._services = new ServicesFactory(this);\n        }\n        return this._services;\n    }\n    reconnect() {\n        if (this.isClosed()) {\n            return Promise.reject(types_1.NatsError.errorForCode(core_1.ErrorCode.ConnectionClosed));\n        }\n        if (this.isDraining()) {\n            return Promise.reject(types_1.NatsError.errorForCode(core_1.ErrorCode.ConnectionDraining));\n        }\n        return this.protocol.reconnect();\n    }\n}\nexports.NatsConnectionImpl = NatsConnectionImpl;\nclass ServicesFactory {\n    constructor(nc) {\n        this.nc = nc;\n    }\n    add(config) {\n        try {\n            const s = new service_1.ServiceImpl(this.nc, config);\n            return s.start();\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n    client(opts, prefix) {\n        return new serviceclient_1.ServiceClientImpl(this.nc, opts, prefix);\n    }\n}\nexports.ServicesFactory = ServicesFactory;\n//# sourceMappingURL=nats.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9uYXRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsdUZBQXVGLGNBQWM7QUFDaE4sdUJBQXVCLDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRywwQkFBMEI7QUFDcEQsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHdFQUFTO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFVO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLDRFQUFXO0FBQ3JDLDBCQUEwQixtQkFBTyxDQUFDLDRGQUFtQjtBQUNyRCxrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBVztBQUNyQyxjQUFjLG1CQUFPLENBQUMsb0VBQU87QUFDN0IsY0FBYyxtQkFBTyxDQUFDLHdFQUFrQjtBQUN4QyxtQkFBbUIsbUJBQU8sQ0FBQyxrRkFBdUI7QUFDbEQsa0JBQWtCLG1CQUFPLENBQUMsNEVBQVc7QUFDckMsd0JBQXdCLG1CQUFPLENBQUMsd0ZBQWlCO0FBQ2pELGVBQWUsbUJBQU8sQ0FBQyxzRUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlDQUF5QyxFQUFFLFFBQVE7QUFDakY7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9uYXRzLmpzPzIzMTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTgtMjAyMyBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19hc3luY1ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX19hc3luY1ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2aWNlc0ZhY3RvcnkgPSBleHBvcnRzLk5hdHNDb25uZWN0aW9uSW1wbCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBwcm90b2NvbF8xID0gcmVxdWlyZShcIi4vcHJvdG9jb2xcIik7XG5jb25zdCBlbmNvZGVyc18xID0gcmVxdWlyZShcIi4vZW5jb2RlcnNcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCIuL3NlbXZlclwiKTtcbmNvbnN0IG9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL29wdGlvbnNcIik7XG5jb25zdCBxdWV1ZWRfaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL3F1ZXVlZF9pdGVyYXRvclwiKTtcbmNvbnN0IHJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RcIik7XG5jb25zdCBtc2dfMSA9IHJlcXVpcmUoXCIuL21zZ1wiKTtcbmNvbnN0IGpzbV8xID0gcmVxdWlyZShcIi4uL2pldHN0cmVhbS9qc21cIik7XG5jb25zdCBqc2NsaWVudF8xID0gcmVxdWlyZShcIi4uL2pldHN0cmVhbS9qc2NsaWVudFwiKTtcbmNvbnN0IHNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG5jb25zdCBzZXJ2aWNlY2xpZW50XzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlY2xpZW50XCIpO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNsYXNzIE5hdHNDb25uZWN0aW9uSW1wbCB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICB0aGlzLmRyYWluaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICgwLCBvcHRpb25zXzEucGFyc2VPcHRpb25zKShvcHRzKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgc3RhdGljIGNvbm5lY3Qob3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYyA9IG5ldyBOYXRzQ29ubmVjdGlvbkltcGwob3B0cyk7XG4gICAgICAgICAgICBwcm90b2NvbF8xLlByb3RvY29sSGFuZGxlci5jb25uZWN0KG5jLm9wdGlvbnMsIG5jKVxuICAgICAgICAgICAgICAgIC50aGVuKChwaCkgPT4ge1xuICAgICAgICAgICAgICAgIG5jLnByb3RvY29sID0gcGg7XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IF9fYXN5bmNWYWx1ZXMocGguc3RhdHVzKCkpLCBfZjsgX2YgPSB5aWVsZCBfZS5uZXh0KCksIF9hID0gX2YuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYy5saXN0ZW5lcnMuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbC5wdXNoKHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5jKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5jbG9zZWQ7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm90b2NvbC5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NoZWNrKHN1YmplY3QsIHN1YiwgcHViKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHRocm93IHR5cGVzXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLkNvbm5lY3Rpb25DbG9zZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWIgJiYgdGhpcy5pc0RyYWluaW5nKCkpIHtcbiAgICAgICAgICAgIHRocm93IHR5cGVzXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLkNvbm5lY3Rpb25EcmFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHB1YiAmJiB0aGlzLnByb3RvY29sLm5vTW9yZVB1Ymxpc2hpbmcpIHtcbiAgICAgICAgICAgIHRocm93IHR5cGVzXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLkNvbm5lY3Rpb25EcmFpbmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgc3ViamVjdCA9IHN1YmplY3QgfHwgXCJcIjtcbiAgICAgICAgaWYgKHN1YmplY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0eXBlc18xLk5hdHNFcnJvci5lcnJvckZvckNvZGUoY29yZV8xLkVycm9yQ29kZS5CYWRTdWJqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdWJsaXNoKHN1YmplY3QsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2soc3ViamVjdCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLnByb3RvY29sLnB1Ymxpc2goc3ViamVjdCwgZGF0YSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN1YnNjcmliZShzdWJqZWN0LCBvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5fY2hlY2soc3ViamVjdCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBjb25zdCBzdWIgPSBuZXcgcHJvdG9jb2xfMS5TdWJzY3JpcHRpb25JbXBsKHRoaXMucHJvdG9jb2wsIHN1YmplY3QsIG9wdHMpO1xuICAgICAgICB0aGlzLnByb3RvY29sLnN1YnNjcmliZShzdWIpO1xuICAgICAgICByZXR1cm4gc3ViO1xuICAgIH1cbiAgICBfcmVzdWIocywgc3ViamVjdCwgbWF4KSB7XG4gICAgICAgIHRoaXMuX2NoZWNrKHN1YmplY3QsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgY29uc3Qgc2kgPSBzO1xuICAgICAgICAvLyBGSVhNRTogbmVlZCB3YXkgb2YgdW5kZXJzdGFuZGluZyBhIGNhbGxiYWNrcyBwcm9jZXNzZWRcbiAgICAgICAgLy8gICBjb3VudCB3aXRob3V0IGl0LCB3ZSBjYW5ub3QgcmVhbGx5IGRvIG11Y2ggLSBpZVxuICAgICAgICAvLyAgIGZvciByZWplY3RlZCBtZXNzYWdlcywgdGhlIGNvdW50IHdvdWxkIGJlIGxvd2VyLCBldGMuXG4gICAgICAgIC8vICAgVG8gaGFuZGxlIGNhc2VzIHdlcmUgZm9yIGV4YW1wbGUgS1YgaXMgYnVpbGRpbmcgYSBtYXBcbiAgICAgICAgLy8gICB0aGUgY29uc3VtZXIgd291bGQgc2F5IGhvdyBtYW55IG1lc3NhZ2VzIHdlIG5lZWQgdG8gZG9cbiAgICAgICAgLy8gICBhIHByb3BlciBidWlsZCBiZWZvcmUgd2UgY2FuIGhhbmRsZSB1cGRhdGVzLlxuICAgICAgICBzaS5tYXggPSBtYXg7IC8vIHRoaXMgbWlnaHQgY2xlYXIgaXRcbiAgICAgICAgaWYgKG1heCkge1xuICAgICAgICAgICAgLy8gd2UgY2Fubm90IGF1dG8tdW5zdWIsIGJlY2F1c2Ugd2UgZG9uJ3Qga25vdyB0aGVcbiAgICAgICAgICAgIC8vIG51bWJlciBvZiBtZXNzYWdlcyB3ZSBwcm9jZXNzZWQgdnMgcmVjZWl2ZWRcbiAgICAgICAgICAgIC8vIGFsbG93IHRoZSBhdXRvLXVuc3ViIG9uIHByb2Nlc3NNc2cgdG8gd29yayBpZiB0aGV5XG4gICAgICAgICAgICAvLyB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgbmV3IG1heFxuICAgICAgICAgICAgc2kubWF4ID0gbWF4ICsgc2kucmVjZWl2ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm90b2NvbC5yZXN1YihzaSwgc3ViamVjdCk7XG4gICAgfVxuICAgIC8vIHBvc3NpYmlsaXRpZXMgYXJlOlxuICAgIC8vIHN0b3Agb24gZXJyb3Igb3IgYW55IG5vbi0xMDAgc3RhdHVzXG4gICAgLy8gQU5EOlxuICAgIC8vIC0gd2FpdCBmb3IgdGltZXJcbiAgICAvLyAtIHdhaXQgZm9yIG4gbWVzc2FnZXMgb3IgdGltZXJcbiAgICAvLyAtIHdhaXQgZm9yIHVua25vd24gbWVzc2FnZXMsIGRvbmUgd2hlbiBlbXB0eSBvciByZXNldCB0aW1lciBleHBpcmVzICh3aXRoIHBvc3NpYmxlIGFsdCB3YWl0KVxuICAgIC8vIC0gd2FpdCBmb3IgdW5rbm93biBtZXNzYWdlcywgZG9uZSB3aGVuIGFuIGVtcHR5IHBheWxvYWQgaXMgcmVjZWl2ZWQgb3IgdGltZXIgZXhwaXJlcyAod2l0aCBwb3NzaWJsZSBhbHQgd2FpdClcbiAgICByZXF1ZXN0TWFueShzdWJqZWN0LCBkYXRhID0gZW5jb2RlcnNfMS5FbXB0eSwgb3B0cyA9IHsgbWF4V2FpdDogMTAwMCwgbWF4TWVzc2FnZXM6IC0xIH0pIHtcbiAgICAgICAgY29uc3QgYXN5bmNUcmFjZXMgPSAhKHRoaXMucHJvdG9jb2wub3B0aW9ucy5ub0FzeW5jVHJhY2VzIHx8IGZhbHNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrKHN1YmplY3QsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIG9wdHMuc3RyYXRlZ3kgPSBvcHRzLnN0cmF0ZWd5IHx8IGNvcmVfMS5SZXF1ZXN0U3RyYXRlZ3kuVGltZXI7XG4gICAgICAgIG9wdHMubWF4V2FpdCA9IG9wdHMubWF4V2FpdCB8fCAxMDAwO1xuICAgICAgICBpZiAob3B0cy5tYXhXYWl0IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyB0eXBlc18xLk5hdHNFcnJvcihcInRpbWVvdXRcIiwgY29yZV8xLkVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGl0ZXJhdG9yIGZvciB1c2VyIHJlc3VsdHNcbiAgICAgICAgY29uc3QgcWkgPSBuZXcgcXVldWVkX2l0ZXJhdG9yXzEuUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIGZ1bmN0aW9uIHN0b3AoZXJyKSB7XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmU6IHN0b3AgZnVuY3Rpb25cbiAgICAgICAgICAgIHFpLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIHFpLnN0b3AoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGxiYWNrIGZvciB0aGUgc3Vic2NyaXB0aW9uIG9yIHRoZSBtdXggaGFuZGxlclxuICAgICAgICAvLyBzaW1wbHkgcHVzaGVzIGVycm9ycyBhbmQgbWVzc2FnZXMgaW50byB0aGUgaXRlcmF0b3JcbiAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soZXJyLCBtc2cpIHtcbiAgICAgICAgICAgIGlmIChlcnIgfHwgbXNnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RvcChlcnIgPT09IG51bGwgPyB1bmRlZmluZWQgOiBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcWkucHVzaChtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLm5vTXV4KSB7XG4gICAgICAgICAgICAvLyB3ZSBzZXR1cCBhIHN1YnNjcmlwdGlvbiBhbmQgbWFuYWdlIGl0XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IGFzeW5jVHJhY2VzID8gbmV3IEVycm9yKCkuc3RhY2sgOiBudWxsO1xuICAgICAgICAgICAgbGV0IG1heCA9IHR5cGVvZiBvcHRzLm1heE1lc3NhZ2VzID09PSBcIm51bWJlclwiICYmIG9wdHMubWF4TWVzc2FnZXMgPiAwXG4gICAgICAgICAgICAgICAgPyBvcHRzLm1heE1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgICAgIGNvbnN0IHN1YiA9IHRoaXMuc3Vic2NyaWJlKCgwLCBjb3JlXzEuY3JlYXRlSW5ib3gpKHRoaXMub3B0aW9ucy5pbmJveFByZWZpeCksIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogKGVyciwgbXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIG9ubHkgZXhwZWN0IHJ1bnRpbWUgZXJyb3JzIG9yIGEgbm8gcmVzcG9uZGVyc1xuICAgICAgICAgICAgICAgICAgICBpZiAoKChfYSA9IG1zZyA9PT0gbnVsbCB8fCBtc2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1zZy5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IG1zZyA9PT0gbnVsbCB8fCBtc2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1zZy5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhdHVzKSA9PT0gY29yZV8xLkVycm9yQ29kZS5Ob1Jlc3BvbmRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IHR5cGVzXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLk5vUmVzcG9uZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gYXVnbWVudCBhbnkgZXJyb3Igd2l0aCB0aGUgY3VycmVudCBzdGFjayB0byBwcm92aWRlIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBlcnJvciBvbiB0aGUgc3VlciBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5zdGFjayArPSBgXFxuXFxuJHtzdGFja31gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcHVzaCB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtc2cpO1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWUgaWYgdGhlIG0gcmVxdWVzdCBpcyBjb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyYXRlZ3kgPT09IGNvcmVfMS5SZXF1ZXN0U3RyYXRlZ3kuQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRzLnN0cmF0ZWd5ID09PSBjb3JlXzEuUmVxdWVzdFN0cmF0ZWd5LkppdHRlclRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVycygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyYXRlZ3kgPT09IGNvcmVfMS5SZXF1ZXN0U3RyYXRlZ3kuU2VudGluZWxNc2cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtc2cgJiYgbXNnLmRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdWIuY2xvc2VkXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBxaS5zdG9wKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNhbmNlbCA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZTogZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgcWkucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGVhclRpbWVycygpO1xuICAgICAgICAgICAgICAgIHN1Yi5kcmFpbigpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoX2VycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcWkuaXRlckNsb3NlZFxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVycygpO1xuICAgICAgICAgICAgICAgIHN1YiA9PT0gbnVsbCB8fCBzdWIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKF9lcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVycygpO1xuICAgICAgICAgICAgICAgIHN1YiA9PT0gbnVsbCB8fCBzdWIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaChzdWJqZWN0LCBkYXRhLCB7IHJlcGx5OiBzdWIuZ2V0U3ViamVjdCgpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNhbmNlbChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FuY2VsKCk7XG4gICAgICAgICAgICB9LCBvcHRzLm1heFdhaXQpO1xuICAgICAgICAgICAgY29uc3QgY2xlYXJUaW1lcnMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoZSBpbmdlc3Rpb24gaXMgdGhlIFJlcXVlc3RNYW55XG4gICAgICAgICAgICBjb25zdCBybW8gPSBvcHRzO1xuICAgICAgICAgICAgcm1vLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBxaS5pdGVyQ2xvc2VkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHIuY2FuY2VsKCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgci5jYW5jZWwoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgciA9IG5ldyByZXF1ZXN0XzEuUmVxdWVzdE1hbnkodGhpcy5wcm90b2NvbC5tdXhTdWJzY3JpcHRpb25zLCBzdWJqZWN0LCBybW8pO1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5yZXF1ZXN0KHIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1Ymxpc2goc3ViamVjdCwgZGF0YSwge1xuICAgICAgICAgICAgICAgICAgICByZXBseTogYCR7dGhpcy5wcm90b2NvbC5tdXhTdWJzY3JpcHRpb25zLmJhc2VJbmJveH0ke3IudG9rZW59YCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHIuY2FuY2VsKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShxaSk7XG4gICAgfVxuICAgIHJlcXVlc3Qoc3ViamVjdCwgZGF0YSwgb3B0cyA9IHsgdGltZW91dDogMTAwMCwgbm9NdXg6IGZhbHNlIH0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrKHN1YmplY3QsIHRydWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzeW5jVHJhY2VzID0gISh0aGlzLnByb3RvY29sLm9wdGlvbnMubm9Bc3luY1RyYWNlcyB8fCBmYWxzZSk7XG4gICAgICAgIG9wdHMudGltZW91dCA9IG9wdHMudGltZW91dCB8fCAxMDAwO1xuICAgICAgICBpZiAob3B0cy50aW1lb3V0IDwgMSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyB0eXBlc18xLk5hdHNFcnJvcihcInRpbWVvdXRcIiwgY29yZV8xLkVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRzLm5vTXV4ICYmIG9wdHMucmVwbHkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgdHlwZXNfMS5OYXRzRXJyb3IoXCJyZXBseSBjYW4gb25seSBiZSB1c2VkIHdpdGggbm9NdXhcIiwgY29yZV8xLkVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMubm9NdXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluYm94ID0gb3B0cy5yZXBseVxuICAgICAgICAgICAgICAgID8gb3B0cy5yZXBseVxuICAgICAgICAgICAgICAgIDogKDAsIGNvcmVfMS5jcmVhdGVJbmJveCkodGhpcy5vcHRpb25zLmluYm94UHJlZml4KTtcbiAgICAgICAgICAgIGNvbnN0IGQgPSAoMCwgdXRpbF8xLmRlZmVycmVkKSgpO1xuICAgICAgICAgICAgY29uc3QgZXJyQ3R4ID0gYXN5bmNUcmFjZXMgPyBuZXcgRXJyb3IoKSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSB0aGlzLnN1YnNjcmliZShpbmJveCwge1xuICAgICAgICAgICAgICAgIG1heDogMSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBvcHRzLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IChlcnIsIG1zZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aW1lb3V0cyBmcm9tIGB0aW1lb3V0KClgIHdpbGwgaGF2ZSB0aGUgcHJvcGVyIHN0YWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyQ3R4ICYmIGVyci5jb2RlICE9PSBjb3JlXzEuRXJyb3JDb2RlLlRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuc3RhY2sgKz0gYFxcblxcbiR7ZXJyQ3R4LnN0YWNrfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyID0gKDAsIG1zZ18xLmlzUmVxdWVzdEVycm9yKShtc2cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGZhaWxlZCBoZXJlLCBoZWxwIHRoZSBkZXZlbG9wZXIgYnkgc2hvd2luZyB3aGF0IGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJDdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5cXG4ke2VyckN0eC5zdGFja31gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKG1zZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdWIucmVxdWVzdFN1YmplY3QgPSBzdWJqZWN0O1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5wdWJsaXNoKHN1YmplY3QsIGRhdGEsIHtcbiAgICAgICAgICAgICAgICByZXBseTogaW5ib3gsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBuZXcgcmVxdWVzdF8xLlJlcXVlc3RPbmUodGhpcy5wcm90b2NvbC5tdXhTdWJzY3JpcHRpb25zLCBzdWJqZWN0LCBvcHRzLCBhc3luY1RyYWNlcyk7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sLnJlcXVlc3Qocik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMucHVibGlzaChzdWJqZWN0LCBkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGx5OiBgJHt0aGlzLnByb3RvY29sLm11eFN1YnNjcmlwdGlvbnMuYmFzZUluYm94fSR7ci50b2tlbn1gLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBvcHRzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgci5jYW5jZWwoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHAgPSBQcm9taXNlLnJhY2UoW3IudGltZXIsIHIuZGVmZXJyZWRdKTtcbiAgICAgICAgICAgIHAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIHIuY2FuY2VsKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiAqXG4gICAgICogRmx1c2hlcyB0byB0aGUgc2VydmVyLiBQcm9taXNlIHJlc29sdmVzIHdoZW4gcm91bmQtdHJpcCBjb21wbGV0ZXMuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0eXBlc18xLk5hdHNFcnJvci5lcnJvckZvckNvZGUoY29yZV8xLkVycm9yQ29kZS5Db25uZWN0aW9uQ2xvc2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdG9jb2wuZmx1c2goKTtcbiAgICB9XG4gICAgZHJhaW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0eXBlc18xLk5hdHNFcnJvci5lcnJvckZvckNvZGUoY29yZV8xLkVycm9yQ29kZS5Db25uZWN0aW9uQ2xvc2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNEcmFpbmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodHlwZXNfMS5OYXRzRXJyb3IuZXJyb3JGb3JDb2RlKGNvcmVfMS5FcnJvckNvZGUuQ29ubmVjdGlvbkRyYWluaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFpbmluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvY29sLmRyYWluKCk7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5pc0Nsb3NlZCgpO1xuICAgIH1cbiAgICBpc0RyYWluaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmFpbmluZztcbiAgICB9XG4gICAgZ2V0U2VydmVyKCkge1xuICAgICAgICBjb25zdCBzcnYgPSB0aGlzLnByb3RvY29sLmdldFNlcnZlcigpO1xuICAgICAgICByZXR1cm4gc3J2ID8gc3J2Lmxpc3RlbiA6IFwiXCI7XG4gICAgfVxuICAgIHN0YXR1cygpIHtcbiAgICAgICAgY29uc3QgaXRlciA9IG5ldyBxdWV1ZWRfaXRlcmF0b3JfMS5RdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgaXRlci5pdGVyQ2xvc2VkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5saXN0ZW5lcnMuaW5kZXhPZihpdGVyKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChpdGVyKTtcbiAgICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgfVxuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5pc0Nsb3NlZCgpID8gdW5kZWZpbmVkIDogdGhpcy5wcm90b2NvbC5pbmZvO1xuICAgIH1cbiAgICBzdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluQnl0ZXM6IHRoaXMucHJvdG9jb2wuaW5CeXRlcyxcbiAgICAgICAgICAgIG91dEJ5dGVzOiB0aGlzLnByb3RvY29sLm91dEJ5dGVzLFxuICAgICAgICAgICAgaW5Nc2dzOiB0aGlzLnByb3RvY29sLmluTXNncyxcbiAgICAgICAgICAgIG91dE1zZ3M6IHRoaXMucHJvdG9jb2wub3V0TXNncyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgamV0c3RyZWFtTWFuYWdlcihvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkbSA9IG5ldyBqc21fMS5KZXRTdHJlYW1NYW5hZ2VySW1wbCh0aGlzLCBvcHRzKTtcbiAgICAgICAgICAgIGlmIChvcHRzLmNoZWNrQVBJICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGFkbS5nZXRBY2NvdW50SW5mbygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5lID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmUuY29kZSA9PT0gY29yZV8xLkVycm9yQ29kZS5Ob1Jlc3BvbmRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lLmNvZGUgPSBjb3JlXzEuRXJyb3JDb2RlLkpldFN0cmVhbU5vdEVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkbTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGpldHN0cmVhbShvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBqc2NsaWVudF8xLkpldFN0cmVhbUNsaWVudEltcGwodGhpcywgb3B0cyk7XG4gICAgfVxuICAgIGdldFNlcnZlclZlcnNpb24oKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLmluZm87XG4gICAgICAgIHJldHVybiBpbmZvID8gKDAsIHNlbXZlcl8xLnBhcnNlU2VtVmVyKShpbmZvLnZlcnNpb24pIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBydHQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvdG9jb2wuX2Nsb3NlZCAmJiAhdGhpcy5wcm90b2NvbC5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0eXBlc18xLk5hdHNFcnJvci5lcnJvckZvckNvZGUoY29yZV8xLkVycm9yQ29kZS5EaXNjb25uZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgZmVhdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3RvY29sLmZlYXR1cmVzO1xuICAgIH1cbiAgICBnZXQgc2VydmljZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2VydmljZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2VzID0gbmV3IFNlcnZpY2VzRmFjdG9yeSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmljZXM7XG4gICAgfVxuICAgIHJlY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHR5cGVzXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLkNvbm5lY3Rpb25DbG9zZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0RyYWluaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0eXBlc18xLk5hdHNFcnJvci5lcnJvckZvckNvZGUoY29yZV8xLkVycm9yQ29kZS5Db25uZWN0aW9uRHJhaW5pbmcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbC5yZWNvbm5lY3QoKTtcbiAgICB9XG59XG5leHBvcnRzLk5hdHNDb25uZWN0aW9uSW1wbCA9IE5hdHNDb25uZWN0aW9uSW1wbDtcbmNsYXNzIFNlcnZpY2VzRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IobmMpIHtcbiAgICAgICAgdGhpcy5uYyA9IG5jO1xuICAgIH1cbiAgICBhZGQoY29uZmlnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzID0gbmV3IHNlcnZpY2VfMS5TZXJ2aWNlSW1wbCh0aGlzLm5jLCBjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuIHMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGllbnQob3B0cywgcHJlZml4KSB7XG4gICAgICAgIHJldHVybiBuZXcgc2VydmljZWNsaWVudF8xLlNlcnZpY2VDbGllbnRJbXBsKHRoaXMubmMsIG9wdHMsIHByZWZpeCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2aWNlc0ZhY3RvcnkgPSBTZXJ2aWNlc0ZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/nats.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/nkeys.js":
/*!*********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/nkeys.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.nkeys = void 0;\nexports.nkeys = __webpack_require__(/*! nkeys.js */ \"(rsc)/./node_modules/nkeys.js/lib/index.js\");\n//# sourceMappingURL=nkeys.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9ua2V5cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2IsaUdBQW1DO0FBQ25DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9ua2V5cy5qcz8zM2Y3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ua2V5cyA9IHZvaWQgMDtcbmV4cG9ydHMubmtleXMgPSByZXF1aXJlKFwibmtleXMuanNcIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ua2V5cy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/nkeys.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/nuid.js":
/*!********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/nuid.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*\n * Copyright 2016-2021 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.nuid = exports.Nuid = void 0;\nconst digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nconst base = 36;\nconst preLen = 12;\nconst seqLen = 10;\nconst maxSeq = 3656158440062976; // base^seqLen == 36^10\nconst minInc = 33;\nconst maxInc = 333;\nconst totalLen = preLen + seqLen;\nfunction _getRandomValues(a) {\n    for (let i = 0; i < a.length; i++) {\n        a[i] = Math.floor(Math.random() * 255);\n    }\n}\nfunction fillRandom(a) {\n    var _a;\n    if ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.getRandomValues) {\n        globalThis.crypto.getRandomValues(a);\n    }\n    else {\n        _getRandomValues(a);\n    }\n}\n/**\n * Create and initialize a nuid.\n *\n * @api private\n */\nclass Nuid {\n    constructor() {\n        this.buf = new Uint8Array(totalLen);\n        this.init();\n    }\n    /**\n     * Initializes a nuid with a crypto random prefix,\n     * and pseudo-random sequence and increment.\n     *\n     * @api private\n     */\n    init() {\n        this.setPre();\n        this.initSeqAndInc();\n        this.fillSeq();\n    }\n    /**\n     * Initializes the pseudo randmon sequence number and the increment range.\n     *\n     * @api private\n     */\n    initSeqAndInc() {\n        this.seq = Math.floor(Math.random() * maxSeq);\n        this.inc = Math.floor(Math.random() * (maxInc - minInc) + minInc);\n    }\n    /**\n     * Sets the prefix from crypto random bytes. Converts to base36.\n     *\n     * @api private\n     */\n    setPre() {\n        const cbuf = new Uint8Array(preLen);\n        fillRandom(cbuf);\n        for (let i = 0; i < preLen; i++) {\n            const di = cbuf[i] % base;\n            this.buf[i] = digits.charCodeAt(di);\n        }\n    }\n    /**\n     * Fills the sequence part of the nuid as base36 from this.seq.\n     *\n     * @api private\n     */\n    fillSeq() {\n        let n = this.seq;\n        for (let i = totalLen - 1; i >= preLen; i--) {\n            this.buf[i] = digits.charCodeAt(n % base);\n            n = Math.floor(n / base);\n        }\n    }\n    /**\n     * Returns the next nuid.\n     *\n     * @api private\n     */\n    next() {\n        this.seq += this.inc;\n        if (this.seq > maxSeq) {\n            this.setPre();\n            this.initSeqAndInc();\n        }\n        this.fillSeq();\n        // @ts-ignore - Uint8Arrays can be an argument\n        return String.fromCharCode.apply(String, this.buf);\n    }\n    reset() {\n        this.init();\n    }\n}\nexports.Nuid = Nuid;\nexports.nuid = new Nuid();\n//# sourceMappingURL=nuid.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9udWlkLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxZQUFZLEdBQUcsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixZQUFZO0FBQ1oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L251aWQuanM/ZTBlNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTYtMjAyMSBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm51aWQgPSBleHBvcnRzLk51aWQgPSB2b2lkIDA7XG5jb25zdCBkaWdpdHMgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xuY29uc3QgYmFzZSA9IDM2O1xuY29uc3QgcHJlTGVuID0gMTI7XG5jb25zdCBzZXFMZW4gPSAxMDtcbmNvbnN0IG1heFNlcSA9IDM2NTYxNTg0NDAwNjI5NzY7IC8vIGJhc2Vec2VxTGVuID09IDM2XjEwXG5jb25zdCBtaW5JbmMgPSAzMztcbmNvbnN0IG1heEluYyA9IDMzMztcbmNvbnN0IHRvdGFsTGVuID0gcHJlTGVuICsgc2VxTGVuO1xuZnVuY3Rpb24gX2dldFJhbmRvbVZhbHVlcyhhKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbGxSYW5kb20oYSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKF9hID0gZ2xvYmFsVGhpcyA9PT0gbnVsbCB8fCBnbG9iYWxUaGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxUaGlzLmNyeXB0bykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFJhbmRvbVZhbHVlcykge1xuICAgICAgICBnbG9iYWxUaGlzLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfZ2V0UmFuZG9tVmFsdWVzKGEpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlIGFuZCBpbml0aWFsaXplIGEgbnVpZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuY2xhc3MgTnVpZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW4pO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBudWlkIHdpdGggYSBjcnlwdG8gcmFuZG9tIHByZWZpeCxcbiAgICAgKiBhbmQgcHNldWRvLXJhbmRvbSBzZXF1ZW5jZSBhbmQgaW5jcmVtZW50LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXRQcmUoKTtcbiAgICAgICAgdGhpcy5pbml0U2VxQW5kSW5jKCk7XG4gICAgICAgIHRoaXMuZmlsbFNlcSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgcHNldWRvIHJhbmRtb24gc2VxdWVuY2UgbnVtYmVyIGFuZCB0aGUgaW5jcmVtZW50IHJhbmdlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdFNlcUFuZEluYygpIHtcbiAgICAgICAgdGhpcy5zZXEgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXhTZXEpO1xuICAgICAgICB0aGlzLmluYyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXhJbmMgLSBtaW5JbmMpICsgbWluSW5jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJlZml4IGZyb20gY3J5cHRvIHJhbmRvbSBieXRlcy4gQ29udmVydHMgdG8gYmFzZTM2LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgc2V0UHJlKCkge1xuICAgICAgICBjb25zdCBjYnVmID0gbmV3IFVpbnQ4QXJyYXkocHJlTGVuKTtcbiAgICAgICAgZmlsbFJhbmRvbShjYnVmKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVMZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZGkgPSBjYnVmW2ldICUgYmFzZTtcbiAgICAgICAgICAgIHRoaXMuYnVmW2ldID0gZGlnaXRzLmNoYXJDb2RlQXQoZGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbGxzIHRoZSBzZXF1ZW5jZSBwYXJ0IG9mIHRoZSBudWlkIGFzIGJhc2UzNiBmcm9tIHRoaXMuc2VxLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZmlsbFNlcSgpIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzLnNlcTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRvdGFsTGVuIC0gMTsgaSA+PSBwcmVMZW47IGktLSkge1xuICAgICAgICAgICAgdGhpcy5idWZbaV0gPSBkaWdpdHMuY2hhckNvZGVBdChuICUgYmFzZSk7XG4gICAgICAgICAgICBuID0gTWF0aC5mbG9vcihuIC8gYmFzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmV4dCBudWlkLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5zZXEgKz0gdGhpcy5pbmM7XG4gICAgICAgIGlmICh0aGlzLnNlcSA+IG1heFNlcSkge1xuICAgICAgICAgICAgdGhpcy5zZXRQcmUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdFNlcUFuZEluYygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsbFNlcSgpO1xuICAgICAgICAvLyBAdHMtaWdub3JlIC0gVWludDhBcnJheXMgY2FuIGJlIGFuIGFyZ3VtZW50XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdGhpcy5idWYpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxufVxuZXhwb3J0cy5OdWlkID0gTnVpZDtcbmV4cG9ydHMubnVpZCA9IG5ldyBOdWlkKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udWlkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/nuid.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/options.js":
/*!***********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/options.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checkUnsupportedOption = exports.checkOptions = exports.parseOptions = exports.buildAuthenticator = exports.defaultOptions = exports.DEFAULT_RECONNECT_TIME_WAIT = exports.DEFAULT_MAX_PING_OUT = exports.DEFAULT_PING_INTERVAL = exports.DEFAULT_JITTER_TLS = exports.DEFAULT_JITTER = exports.DEFAULT_MAX_RECONNECT_ATTEMPTS = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/nats/lib/nats-base-client/transport.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nconst authenticator_1 = __webpack_require__(/*! ./authenticator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/authenticator.js\");\nconst core_2 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nexports.DEFAULT_MAX_RECONNECT_ATTEMPTS = 10;\nexports.DEFAULT_JITTER = 100;\nexports.DEFAULT_JITTER_TLS = 1000;\n// Ping interval\nexports.DEFAULT_PING_INTERVAL = 2 * 60 * 1000; // 2 minutes\nexports.DEFAULT_MAX_PING_OUT = 2;\n// DISCONNECT Parameters, 2 sec wait, 10 tries\nexports.DEFAULT_RECONNECT_TIME_WAIT = 2 * 1000;\nfunction defaultOptions() {\n    return {\n        maxPingOut: exports.DEFAULT_MAX_PING_OUT,\n        maxReconnectAttempts: exports.DEFAULT_MAX_RECONNECT_ATTEMPTS,\n        noRandomize: false,\n        pedantic: false,\n        pingInterval: exports.DEFAULT_PING_INTERVAL,\n        reconnect: true,\n        reconnectJitter: exports.DEFAULT_JITTER,\n        reconnectJitterTLS: exports.DEFAULT_JITTER_TLS,\n        reconnectTimeWait: exports.DEFAULT_RECONNECT_TIME_WAIT,\n        tls: undefined,\n        verbose: false,\n        waitOnFirstConnect: false,\n        ignoreAuthErrorAbort: false,\n    };\n}\nexports.defaultOptions = defaultOptions;\nfunction buildAuthenticator(opts) {\n    const buf = [];\n    // jwtAuthenticator is created by the user, since it\n    // will require possibly reading files which\n    // some of the clients are simply unable to do\n    if (typeof opts.authenticator === \"function\") {\n        buf.push(opts.authenticator);\n    }\n    if (Array.isArray(opts.authenticator)) {\n        buf.push(...opts.authenticator);\n    }\n    if (opts.token) {\n        buf.push((0, authenticator_1.tokenAuthenticator)(opts.token));\n    }\n    if (opts.user) {\n        buf.push((0, authenticator_1.usernamePasswordAuthenticator)(opts.user, opts.pass));\n    }\n    return buf.length === 0 ? (0, authenticator_1.noAuthFn)() : (0, authenticator_1.multiAuthenticator)(buf);\n}\nexports.buildAuthenticator = buildAuthenticator;\nfunction parseOptions(opts) {\n    const dhp = `${core_2.DEFAULT_HOST}:${(0, transport_1.defaultPort)()}`;\n    opts = opts || { servers: [dhp] };\n    opts.servers = opts.servers || [];\n    if (typeof opts.servers === \"string\") {\n        opts.servers = [opts.servers];\n    }\n    if (opts.servers.length > 0 && opts.port) {\n        throw new core_2.NatsError(\"port and servers options are mutually exclusive\", core_2.ErrorCode.InvalidOption);\n    }\n    if (opts.servers.length === 0 && opts.port) {\n        opts.servers = [`${core_2.DEFAULT_HOST}:${opts.port}`];\n    }\n    if (opts.servers && opts.servers.length === 0) {\n        opts.servers = [dhp];\n    }\n    const options = (0, util_1.extend)(defaultOptions(), opts);\n    options.authenticator = buildAuthenticator(options);\n    [\"reconnectDelayHandler\", \"authenticator\"].forEach((n) => {\n        if (options[n] && typeof options[n] !== \"function\") {\n            throw new core_2.NatsError(`${n} option should be a function`, core_2.ErrorCode.NotFunction);\n        }\n    });\n    if (!options.reconnectDelayHandler) {\n        options.reconnectDelayHandler = () => {\n            let extra = options.tls\n                ? options.reconnectJitterTLS\n                : options.reconnectJitter;\n            if (extra) {\n                extra++;\n                extra = Math.floor(Math.random() * extra);\n            }\n            return options.reconnectTimeWait + extra;\n        };\n    }\n    if (options.inboxPrefix) {\n        try {\n            (0, core_1.createInbox)(options.inboxPrefix);\n        }\n        catch (err) {\n            throw new core_2.NatsError(err.message, core_2.ErrorCode.ApiError);\n        }\n    }\n    if (options.resolve) {\n        if (typeof (0, transport_1.getResolveFn)() !== \"function\") {\n            throw new core_2.NatsError(`'resolve' is not supported on this client`, core_2.ErrorCode.InvalidOption);\n        }\n    }\n    return options;\n}\nexports.parseOptions = parseOptions;\nfunction checkOptions(info, options) {\n    const { proto, tls_required: tlsRequired, tls_available: tlsAvailable } = info;\n    if ((proto === undefined || proto < 1) && options.noEcho) {\n        throw new core_2.NatsError(\"noEcho\", core_2.ErrorCode.ServerOptionNotAvailable);\n    }\n    const tls = tlsRequired || tlsAvailable || false;\n    if (options.tls && !tls) {\n        throw new core_2.NatsError(\"tls\", core_2.ErrorCode.ServerOptionNotAvailable);\n    }\n}\nexports.checkOptions = checkOptions;\nfunction checkUnsupportedOption(prop, v) {\n    if (v) {\n        throw new core_2.NatsError(prop, core_2.ErrorCode.InvalidOption);\n    }\n}\nexports.checkUnsupportedOption = checkUnsupportedOption;\n//# sourceMappingURL=options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw4QkFBOEIsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyxtQ0FBbUMsR0FBRyw0QkFBNEIsR0FBRyw2QkFBNkIsR0FBRywwQkFBMEIsR0FBRyxzQkFBc0IsR0FBRyxzQ0FBc0M7QUFDdFUsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLGdGQUFhO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBUTtBQUMvQix3QkFBd0IsbUJBQU8sQ0FBQyx3RkFBaUI7QUFDakQsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CLHNDQUFzQztBQUN0QyxzQkFBc0I7QUFDdEIsMEJBQTBCO0FBQzFCO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQyw0QkFBNEI7QUFDNUI7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLG1CQUFtQixvQkFBb0IsR0FBRywrQkFBK0I7QUFDekUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CLEdBQUcsVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLEdBQUc7QUFDN0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsWUFBWSxnRUFBZ0U7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9vcHRpb25zLmpzPzVlOWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEtMjAyMyBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGVja1Vuc3VwcG9ydGVkT3B0aW9uID0gZXhwb3J0cy5jaGVja09wdGlvbnMgPSBleHBvcnRzLnBhcnNlT3B0aW9ucyA9IGV4cG9ydHMuYnVpbGRBdXRoZW50aWNhdG9yID0gZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGV4cG9ydHMuREVGQVVMVF9SRUNPTk5FQ1RfVElNRV9XQUlUID0gZXhwb3J0cy5ERUZBVUxUX01BWF9QSU5HX09VVCA9IGV4cG9ydHMuREVGQVVMVF9QSU5HX0lOVEVSVkFMID0gZXhwb3J0cy5ERUZBVUxUX0pJVFRFUl9UTFMgPSBleHBvcnRzLkRFRkFVTFRfSklUVEVSID0gZXhwb3J0cy5ERUZBVUxUX01BWF9SRUNPTk5FQ1RfQVRURU1QVFMgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3QgYXV0aGVudGljYXRvcl8xID0gcmVxdWlyZShcIi4vYXV0aGVudGljYXRvclwiKTtcbmNvbnN0IGNvcmVfMiA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5leHBvcnRzLkRFRkFVTFRfTUFYX1JFQ09OTkVDVF9BVFRFTVBUUyA9IDEwO1xuZXhwb3J0cy5ERUZBVUxUX0pJVFRFUiA9IDEwMDtcbmV4cG9ydHMuREVGQVVMVF9KSVRURVJfVExTID0gMTAwMDtcbi8vIFBpbmcgaW50ZXJ2YWxcbmV4cG9ydHMuREVGQVVMVF9QSU5HX0lOVEVSVkFMID0gMiAqIDYwICogMTAwMDsgLy8gMiBtaW51dGVzXG5leHBvcnRzLkRFRkFVTFRfTUFYX1BJTkdfT1VUID0gMjtcbi8vIERJU0NPTk5FQ1QgUGFyYW1ldGVycywgMiBzZWMgd2FpdCwgMTAgdHJpZXNcbmV4cG9ydHMuREVGQVVMVF9SRUNPTk5FQ1RfVElNRV9XQUlUID0gMiAqIDEwMDA7XG5mdW5jdGlvbiBkZWZhdWx0T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtYXhQaW5nT3V0OiBleHBvcnRzLkRFRkFVTFRfTUFYX1BJTkdfT1VULFxuICAgICAgICBtYXhSZWNvbm5lY3RBdHRlbXB0czogZXhwb3J0cy5ERUZBVUxUX01BWF9SRUNPTk5FQ1RfQVRURU1QVFMsXG4gICAgICAgIG5vUmFuZG9taXplOiBmYWxzZSxcbiAgICAgICAgcGVkYW50aWM6IGZhbHNlLFxuICAgICAgICBwaW5nSW50ZXJ2YWw6IGV4cG9ydHMuREVGQVVMVF9QSU5HX0lOVEVSVkFMLFxuICAgICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICAgIHJlY29ubmVjdEppdHRlcjogZXhwb3J0cy5ERUZBVUxUX0pJVFRFUixcbiAgICAgICAgcmVjb25uZWN0Sml0dGVyVExTOiBleHBvcnRzLkRFRkFVTFRfSklUVEVSX1RMUyxcbiAgICAgICAgcmVjb25uZWN0VGltZVdhaXQ6IGV4cG9ydHMuREVGQVVMVF9SRUNPTk5FQ1RfVElNRV9XQUlULFxuICAgICAgICB0bHM6IHVuZGVmaW5lZCxcbiAgICAgICAgdmVyYm9zZTogZmFsc2UsXG4gICAgICAgIHdhaXRPbkZpcnN0Q29ubmVjdDogZmFsc2UsXG4gICAgICAgIGlnbm9yZUF1dGhFcnJvckFib3J0OiBmYWxzZSxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0T3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuZnVuY3Rpb24gYnVpbGRBdXRoZW50aWNhdG9yKG9wdHMpIHtcbiAgICBjb25zdCBidWYgPSBbXTtcbiAgICAvLyBqd3RBdXRoZW50aWNhdG9yIGlzIGNyZWF0ZWQgYnkgdGhlIHVzZXIsIHNpbmNlIGl0XG4gICAgLy8gd2lsbCByZXF1aXJlIHBvc3NpYmx5IHJlYWRpbmcgZmlsZXMgd2hpY2hcbiAgICAvLyBzb21lIG9mIHRoZSBjbGllbnRzIGFyZSBzaW1wbHkgdW5hYmxlIHRvIGRvXG4gICAgaWYgKHR5cGVvZiBvcHRzLmF1dGhlbnRpY2F0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBidWYucHVzaChvcHRzLmF1dGhlbnRpY2F0b3IpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzLmF1dGhlbnRpY2F0b3IpKSB7XG4gICAgICAgIGJ1Zi5wdXNoKC4uLm9wdHMuYXV0aGVudGljYXRvcik7XG4gICAgfVxuICAgIGlmIChvcHRzLnRva2VuKSB7XG4gICAgICAgIGJ1Zi5wdXNoKCgwLCBhdXRoZW50aWNhdG9yXzEudG9rZW5BdXRoZW50aWNhdG9yKShvcHRzLnRva2VuKSk7XG4gICAgfVxuICAgIGlmIChvcHRzLnVzZXIpIHtcbiAgICAgICAgYnVmLnB1c2goKDAsIGF1dGhlbnRpY2F0b3JfMS51c2VybmFtZVBhc3N3b3JkQXV0aGVudGljYXRvcikob3B0cy51c2VyLCBvcHRzLnBhc3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi5sZW5ndGggPT09IDAgPyAoMCwgYXV0aGVudGljYXRvcl8xLm5vQXV0aEZuKSgpIDogKDAsIGF1dGhlbnRpY2F0b3JfMS5tdWx0aUF1dGhlbnRpY2F0b3IpKGJ1Zik7XG59XG5leHBvcnRzLmJ1aWxkQXV0aGVudGljYXRvciA9IGJ1aWxkQXV0aGVudGljYXRvcjtcbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhvcHRzKSB7XG4gICAgY29uc3QgZGhwID0gYCR7Y29yZV8yLkRFRkFVTFRfSE9TVH06JHsoMCwgdHJhbnNwb3J0XzEuZGVmYXVsdFBvcnQpKCl9YDtcbiAgICBvcHRzID0gb3B0cyB8fCB7IHNlcnZlcnM6IFtkaHBdIH07XG4gICAgb3B0cy5zZXJ2ZXJzID0gb3B0cy5zZXJ2ZXJzIHx8IFtdO1xuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdHMuc2VydmVycyA9IFtvcHRzLnNlcnZlcnNdO1xuICAgIH1cbiAgICBpZiAob3B0cy5zZXJ2ZXJzLmxlbmd0aCA+IDAgJiYgb3B0cy5wb3J0KSB7XG4gICAgICAgIHRocm93IG5ldyBjb3JlXzIuTmF0c0Vycm9yKFwicG9ydCBhbmQgc2VydmVycyBvcHRpb25zIGFyZSBtdXR1YWxseSBleGNsdXNpdmVcIiwgY29yZV8yLkVycm9yQ29kZS5JbnZhbGlkT3B0aW9uKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2VydmVycy5sZW5ndGggPT09IDAgJiYgb3B0cy5wb3J0KSB7XG4gICAgICAgIG9wdHMuc2VydmVycyA9IFtgJHtjb3JlXzIuREVGQVVMVF9IT1NUfToke29wdHMucG9ydH1gXTtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2VydmVycyAmJiBvcHRzLnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG9wdHMuc2VydmVycyA9IFtkaHBdO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gKDAsIHV0aWxfMS5leHRlbmQpKGRlZmF1bHRPcHRpb25zKCksIG9wdHMpO1xuICAgIG9wdGlvbnMuYXV0aGVudGljYXRvciA9IGJ1aWxkQXV0aGVudGljYXRvcihvcHRpb25zKTtcbiAgICBbXCJyZWNvbm5lY3REZWxheUhhbmRsZXJcIiwgXCJhdXRoZW50aWNhdG9yXCJdLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnNbbl0gJiYgdHlwZW9mIG9wdGlvbnNbbl0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfMi5OYXRzRXJyb3IoYCR7bn0gb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uYCwgY29yZV8yLkVycm9yQ29kZS5Ob3RGdW5jdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIW9wdGlvbnMucmVjb25uZWN0RGVsYXlIYW5kbGVyKSB7XG4gICAgICAgIG9wdGlvbnMucmVjb25uZWN0RGVsYXlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgbGV0IGV4dHJhID0gb3B0aW9ucy50bHNcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMucmVjb25uZWN0Sml0dGVyVExTXG4gICAgICAgICAgICAgICAgOiBvcHRpb25zLnJlY29ubmVjdEppdHRlcjtcbiAgICAgICAgICAgIGlmIChleHRyYSkge1xuICAgICAgICAgICAgICAgIGV4dHJhKys7XG4gICAgICAgICAgICAgICAgZXh0cmEgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBleHRyYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZWNvbm5lY3RUaW1lV2FpdCArIGV4dHJhO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbmJveFByZWZpeCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgKDAsIGNvcmVfMS5jcmVhdGVJbmJveCkob3B0aW9ucy5pbmJveFByZWZpeCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfMi5OYXRzRXJyb3IoZXJyLm1lc3NhZ2UsIGNvcmVfMi5FcnJvckNvZGUuQXBpRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlc29sdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoMCwgdHJhbnNwb3J0XzEuZ2V0UmVzb2x2ZUZuKSgpICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlXzIuTmF0c0Vycm9yKGAncmVzb2x2ZScgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGNsaWVudGAsIGNvcmVfMi5FcnJvckNvZGUuSW52YWxpZE9wdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcbmZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhpbmZvLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBwcm90bywgdGxzX3JlcXVpcmVkOiB0bHNSZXF1aXJlZCwgdGxzX2F2YWlsYWJsZTogdGxzQXZhaWxhYmxlIH0gPSBpbmZvO1xuICAgIGlmICgocHJvdG8gPT09IHVuZGVmaW5lZCB8fCBwcm90byA8IDEpICYmIG9wdGlvbnMubm9FY2hvKSB7XG4gICAgICAgIHRocm93IG5ldyBjb3JlXzIuTmF0c0Vycm9yKFwibm9FY2hvXCIsIGNvcmVfMi5FcnJvckNvZGUuU2VydmVyT3B0aW9uTm90QXZhaWxhYmxlKTtcbiAgICB9XG4gICAgY29uc3QgdGxzID0gdGxzUmVxdWlyZWQgfHwgdGxzQXZhaWxhYmxlIHx8IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnRscyAmJiAhdGxzKSB7XG4gICAgICAgIHRocm93IG5ldyBjb3JlXzIuTmF0c0Vycm9yKFwidGxzXCIsIGNvcmVfMi5FcnJvckNvZGUuU2VydmVyT3B0aW9uTm90QXZhaWxhYmxlKTtcbiAgICB9XG59XG5leHBvcnRzLmNoZWNrT3B0aW9ucyA9IGNoZWNrT3B0aW9ucztcbmZ1bmN0aW9uIGNoZWNrVW5zdXBwb3J0ZWRPcHRpb24ocHJvcCwgdikge1xuICAgIGlmICh2KSB7XG4gICAgICAgIHRocm93IG5ldyBjb3JlXzIuTmF0c0Vycm9yKHByb3AsIGNvcmVfMi5FcnJvckNvZGUuSW52YWxpZE9wdGlvbik7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1Vuc3VwcG9ydGVkT3B0aW9uID0gY2hlY2tVbnN1cHBvcnRlZE9wdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/options.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/parser.js":
/*!**********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/parser.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.State = exports.Parser = exports.describe = exports.Kind = void 0;\n// deno-lint-ignore-file no-undef\n/*\n * Copyright 2020-2021 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst denobuffer_1 = __webpack_require__(/*! ./denobuffer */ \"(rsc)/./node_modules/nats/lib/nats-base-client/denobuffer.js\");\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nvar Kind;\n(function (Kind) {\n    Kind[Kind[\"OK\"] = 0] = \"OK\";\n    Kind[Kind[\"ERR\"] = 1] = \"ERR\";\n    Kind[Kind[\"MSG\"] = 2] = \"MSG\";\n    Kind[Kind[\"INFO\"] = 3] = \"INFO\";\n    Kind[Kind[\"PING\"] = 4] = \"PING\";\n    Kind[Kind[\"PONG\"] = 5] = \"PONG\";\n})(Kind || (exports.Kind = Kind = {}));\nfunction describe(e) {\n    let ks;\n    let data = \"\";\n    switch (e.kind) {\n        case Kind.MSG:\n            ks = \"MSG\";\n            break;\n        case Kind.OK:\n            ks = \"OK\";\n            break;\n        case Kind.ERR:\n            ks = \"ERR\";\n            data = encoders_1.TD.decode(e.data);\n            break;\n        case Kind.PING:\n            ks = \"PING\";\n            break;\n        case Kind.PONG:\n            ks = \"PONG\";\n            break;\n        case Kind.INFO:\n            ks = \"INFO\";\n            data = encoders_1.TD.decode(e.data);\n    }\n    return `${ks}: ${data}`;\n}\nexports.describe = describe;\nfunction newMsgArg() {\n    const ma = {};\n    ma.sid = -1;\n    ma.hdr = -1;\n    ma.size = -1;\n    return ma;\n}\nconst ASCII_0 = 48;\nconst ASCII_9 = 57;\n// This is an almost verbatim port of the Go NATS parser\n// https://github.com/nats-io/nats.go/blob/master/parser.go\nclass Parser {\n    constructor(dispatcher) {\n        this.dispatcher = dispatcher;\n        this.state = State.OP_START;\n        this.as = 0;\n        this.drop = 0;\n        this.hdr = 0;\n    }\n    parse(buf) {\n        let i;\n        for (i = 0; i < buf.length; i++) {\n            const b = buf[i];\n            switch (this.state) {\n                case State.OP_START:\n                    switch (b) {\n                        case cc.M:\n                        case cc.m:\n                            this.state = State.OP_M;\n                            this.hdr = -1;\n                            this.ma = newMsgArg();\n                            break;\n                        case cc.H:\n                        case cc.h:\n                            this.state = State.OP_H;\n                            this.hdr = 0;\n                            this.ma = newMsgArg();\n                            break;\n                        case cc.P:\n                        case cc.p:\n                            this.state = State.OP_P;\n                            break;\n                        case cc.PLUS:\n                            this.state = State.OP_PLUS;\n                            break;\n                        case cc.MINUS:\n                            this.state = State.OP_MINUS;\n                            break;\n                        case cc.I:\n                        case cc.i:\n                            this.state = State.OP_I;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_H:\n                    switch (b) {\n                        case cc.M:\n                        case cc.m:\n                            this.state = State.OP_M;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_M:\n                    switch (b) {\n                        case cc.S:\n                        case cc.s:\n                            this.state = State.OP_MS;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MS:\n                    switch (b) {\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_MSG;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MSG:\n                    switch (b) {\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_MSG_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MSG_SPC:\n                    switch (b) {\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.MSG_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.MSG_ARG:\n                    switch (b) {\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL: {\n                            const arg = this.argBuf\n                                ? this.argBuf.bytes()\n                                : buf.subarray(this.as, i - this.drop);\n                            this.processMsgArgs(arg);\n                            this.drop = 0;\n                            this.as = i + 1;\n                            this.state = State.MSG_PAYLOAD;\n                            // jump ahead with the index. If this overruns\n                            // what is left we fall out and process a split buffer.\n                            i = this.as + this.ma.size - 1;\n                            break;\n                        }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.writeByte(b);\n                            }\n                    }\n                    break;\n                case State.MSG_PAYLOAD:\n                    if (this.msgBuf) {\n                        if (this.msgBuf.length >= this.ma.size) {\n                            const data = this.msgBuf.bytes({ copy: false });\n                            this.dispatcher.push({ kind: Kind.MSG, msg: this.ma, data: data });\n                            this.argBuf = undefined;\n                            this.msgBuf = undefined;\n                            this.state = State.MSG_END;\n                        }\n                        else {\n                            let toCopy = this.ma.size - this.msgBuf.length;\n                            const avail = buf.length - i;\n                            if (avail < toCopy) {\n                                toCopy = avail;\n                            }\n                            if (toCopy > 0) {\n                                this.msgBuf.write(buf.subarray(i, i + toCopy));\n                                i = (i + toCopy) - 1;\n                            }\n                            else {\n                                this.msgBuf.writeByte(b);\n                            }\n                        }\n                    }\n                    else if (i - this.as >= this.ma.size) {\n                        this.dispatcher.push({ kind: Kind.MSG, msg: this.ma, data: buf.subarray(this.as, i) });\n                        this.argBuf = undefined;\n                        this.msgBuf = undefined;\n                        this.state = State.MSG_END;\n                    }\n                    break;\n                case State.MSG_END:\n                    switch (b) {\n                        case cc.NL:\n                            this.drop = 0;\n                            this.as = i + 1;\n                            this.state = State.OP_START;\n                            break;\n                        default:\n                            continue;\n                    }\n                    break;\n                case State.OP_PLUS:\n                    switch (b) {\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_PLUS_O;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PLUS_O:\n                    switch (b) {\n                        case cc.K:\n                        case cc.k:\n                            this.state = State.OP_PLUS_OK;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PLUS_OK:\n                    switch (b) {\n                        case cc.NL:\n                            this.dispatcher.push({ kind: Kind.OK });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_MINUS:\n                    switch (b) {\n                        case cc.E:\n                        case cc.e:\n                            this.state = State.OP_MINUS_E;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_E:\n                    switch (b) {\n                        case cc.R:\n                        case cc.r:\n                            this.state = State.OP_MINUS_ER;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ER:\n                    switch (b) {\n                        case cc.R:\n                        case cc.r:\n                            this.state = State.OP_MINUS_ERR;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ERR:\n                    switch (b) {\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_MINUS_ERR_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_MINUS_ERR_SPC:\n                    switch (b) {\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.MINUS_ERR_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.MINUS_ERR_ARG:\n                    switch (b) {\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL: {\n                            let arg;\n                            if (this.argBuf) {\n                                arg = this.argBuf.bytes();\n                                this.argBuf = undefined;\n                            }\n                            else {\n                                arg = buf.subarray(this.as, i - this.drop);\n                            }\n                            this.dispatcher.push({ kind: Kind.ERR, data: arg });\n                            this.drop = 0;\n                            this.as = i + 1;\n                            this.state = State.OP_START;\n                            break;\n                        }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.write(Uint8Array.of(b));\n                            }\n                    }\n                    break;\n                case State.OP_P:\n                    switch (b) {\n                        case cc.I:\n                        case cc.i:\n                            this.state = State.OP_PI;\n                            break;\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_PO;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PO:\n                    switch (b) {\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_PON;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PON:\n                    switch (b) {\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_PONG;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PONG:\n                    switch (b) {\n                        case cc.NL:\n                            this.dispatcher.push({ kind: Kind.PONG });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_PI:\n                    switch (b) {\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_PIN;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PIN:\n                    switch (b) {\n                        case cc.G:\n                        case cc.g:\n                            this.state = State.OP_PING;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_PING:\n                    switch (b) {\n                        case cc.NL:\n                            this.dispatcher.push({ kind: Kind.PING });\n                            this.drop = 0;\n                            this.state = State.OP_START;\n                            break;\n                    }\n                    break;\n                case State.OP_I:\n                    switch (b) {\n                        case cc.N:\n                        case cc.n:\n                            this.state = State.OP_IN;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_IN:\n                    switch (b) {\n                        case cc.F:\n                        case cc.f:\n                            this.state = State.OP_INF;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INF:\n                    switch (b) {\n                        case cc.O:\n                        case cc.o:\n                            this.state = State.OP_INFO;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INFO:\n                    switch (b) {\n                        case cc.SPACE:\n                        case cc.TAB:\n                            this.state = State.OP_INFO_SPC;\n                            break;\n                        default:\n                            throw this.fail(buf.subarray(i));\n                    }\n                    break;\n                case State.OP_INFO_SPC:\n                    switch (b) {\n                        case cc.SPACE:\n                        case cc.TAB:\n                            continue;\n                        default:\n                            this.state = State.INFO_ARG;\n                            this.as = i;\n                    }\n                    break;\n                case State.INFO_ARG:\n                    switch (b) {\n                        case cc.CR:\n                            this.drop = 1;\n                            break;\n                        case cc.NL: {\n                            let arg;\n                            if (this.argBuf) {\n                                arg = this.argBuf.bytes();\n                                this.argBuf = undefined;\n                            }\n                            else {\n                                arg = buf.subarray(this.as, i - this.drop);\n                            }\n                            this.dispatcher.push({ kind: Kind.INFO, data: arg });\n                            this.drop = 0;\n                            this.as = i + 1;\n                            this.state = State.OP_START;\n                            break;\n                        }\n                        default:\n                            if (this.argBuf) {\n                                this.argBuf.writeByte(b);\n                            }\n                    }\n                    break;\n                default:\n                    throw this.fail(buf.subarray(i));\n            }\n        }\n        if ((this.state === State.MSG_ARG || this.state === State.MINUS_ERR_ARG ||\n            this.state === State.INFO_ARG) && !this.argBuf) {\n            this.argBuf = new denobuffer_1.DenoBuffer(buf.subarray(this.as, i - this.drop));\n        }\n        if (this.state === State.MSG_PAYLOAD && !this.msgBuf) {\n            if (!this.argBuf) {\n                this.cloneMsgArg();\n            }\n            this.msgBuf = new denobuffer_1.DenoBuffer(buf.subarray(this.as));\n        }\n    }\n    cloneMsgArg() {\n        const s = this.ma.subject.length;\n        const r = this.ma.reply ? this.ma.reply.length : 0;\n        const buf = new Uint8Array(s + r);\n        buf.set(this.ma.subject);\n        if (this.ma.reply) {\n            buf.set(this.ma.reply, s);\n        }\n        this.argBuf = new denobuffer_1.DenoBuffer(buf);\n        this.ma.subject = buf.subarray(0, s);\n        if (this.ma.reply) {\n            this.ma.reply = buf.subarray(s);\n        }\n    }\n    processMsgArgs(arg) {\n        if (this.hdr >= 0) {\n            return this.processHeaderMsgArgs(arg);\n        }\n        const args = [];\n        let start = -1;\n        for (let i = 0; i < arg.length; i++) {\n            const b = arg[i];\n            switch (b) {\n                case cc.SPACE:\n                case cc.TAB:\n                case cc.CR:\n                case cc.NL:\n                    if (start >= 0) {\n                        args.push(arg.subarray(start, i));\n                        start = -1;\n                    }\n                    break;\n                default:\n                    if (start < 0) {\n                        start = i;\n                    }\n            }\n        }\n        if (start >= 0) {\n            args.push(arg.subarray(start));\n        }\n        switch (args.length) {\n            case 3:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = undefined;\n                this.ma.size = this.protoParseInt(args[2]);\n                break;\n            case 4:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = args[2];\n                this.ma.size = this.protoParseInt(args[3]);\n                break;\n            default:\n                throw this.fail(arg, \"processMsgArgs Parse Error\");\n        }\n        if (this.ma.sid < 0) {\n            throw this.fail(arg, \"processMsgArgs Bad or Missing Sid Error\");\n        }\n        if (this.ma.size < 0) {\n            throw this.fail(arg, \"processMsgArgs Bad or Missing Size Error\");\n        }\n    }\n    fail(data, label = \"\") {\n        if (!label) {\n            label = `parse error [${this.state}]`;\n        }\n        else {\n            label = `${label} [${this.state}]`;\n        }\n        return new Error(`${label}: ${encoders_1.TD.decode(data)}`);\n    }\n    processHeaderMsgArgs(arg) {\n        const args = [];\n        let start = -1;\n        for (let i = 0; i < arg.length; i++) {\n            const b = arg[i];\n            switch (b) {\n                case cc.SPACE:\n                case cc.TAB:\n                case cc.CR:\n                case cc.NL:\n                    if (start >= 0) {\n                        args.push(arg.subarray(start, i));\n                        start = -1;\n                    }\n                    break;\n                default:\n                    if (start < 0) {\n                        start = i;\n                    }\n            }\n        }\n        if (start >= 0) {\n            args.push(arg.subarray(start));\n        }\n        switch (args.length) {\n            case 4:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = undefined;\n                this.ma.hdr = this.protoParseInt(args[2]);\n                this.ma.size = this.protoParseInt(args[3]);\n                break;\n            case 5:\n                this.ma.subject = args[0];\n                this.ma.sid = this.protoParseInt(args[1]);\n                this.ma.reply = args[2];\n                this.ma.hdr = this.protoParseInt(args[3]);\n                this.ma.size = this.protoParseInt(args[4]);\n                break;\n            default:\n                throw this.fail(arg, \"processHeaderMsgArgs Parse Error\");\n        }\n        if (this.ma.sid < 0) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Sid Error\");\n        }\n        if (this.ma.hdr < 0 || this.ma.hdr > this.ma.size) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Header Size Error\");\n        }\n        if (this.ma.size < 0) {\n            throw this.fail(arg, \"processHeaderMsgArgs Bad or Missing Size Error\");\n        }\n    }\n    protoParseInt(a) {\n        if (a.length === 0) {\n            return -1;\n        }\n        let n = 0;\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] < ASCII_0 || a[i] > ASCII_9) {\n                return -1;\n            }\n            n = n * 10 + (a[i] - ASCII_0);\n        }\n        return n;\n    }\n}\nexports.Parser = Parser;\nvar State;\n(function (State) {\n    State[State[\"OP_START\"] = 0] = \"OP_START\";\n    State[State[\"OP_PLUS\"] = 1] = \"OP_PLUS\";\n    State[State[\"OP_PLUS_O\"] = 2] = \"OP_PLUS_O\";\n    State[State[\"OP_PLUS_OK\"] = 3] = \"OP_PLUS_OK\";\n    State[State[\"OP_MINUS\"] = 4] = \"OP_MINUS\";\n    State[State[\"OP_MINUS_E\"] = 5] = \"OP_MINUS_E\";\n    State[State[\"OP_MINUS_ER\"] = 6] = \"OP_MINUS_ER\";\n    State[State[\"OP_MINUS_ERR\"] = 7] = \"OP_MINUS_ERR\";\n    State[State[\"OP_MINUS_ERR_SPC\"] = 8] = \"OP_MINUS_ERR_SPC\";\n    State[State[\"MINUS_ERR_ARG\"] = 9] = \"MINUS_ERR_ARG\";\n    State[State[\"OP_M\"] = 10] = \"OP_M\";\n    State[State[\"OP_MS\"] = 11] = \"OP_MS\";\n    State[State[\"OP_MSG\"] = 12] = \"OP_MSG\";\n    State[State[\"OP_MSG_SPC\"] = 13] = \"OP_MSG_SPC\";\n    State[State[\"MSG_ARG\"] = 14] = \"MSG_ARG\";\n    State[State[\"MSG_PAYLOAD\"] = 15] = \"MSG_PAYLOAD\";\n    State[State[\"MSG_END\"] = 16] = \"MSG_END\";\n    State[State[\"OP_H\"] = 17] = \"OP_H\";\n    State[State[\"OP_P\"] = 18] = \"OP_P\";\n    State[State[\"OP_PI\"] = 19] = \"OP_PI\";\n    State[State[\"OP_PIN\"] = 20] = \"OP_PIN\";\n    State[State[\"OP_PING\"] = 21] = \"OP_PING\";\n    State[State[\"OP_PO\"] = 22] = \"OP_PO\";\n    State[State[\"OP_PON\"] = 23] = \"OP_PON\";\n    State[State[\"OP_PONG\"] = 24] = \"OP_PONG\";\n    State[State[\"OP_I\"] = 25] = \"OP_I\";\n    State[State[\"OP_IN\"] = 26] = \"OP_IN\";\n    State[State[\"OP_INF\"] = 27] = \"OP_INF\";\n    State[State[\"OP_INFO\"] = 28] = \"OP_INFO\";\n    State[State[\"OP_INFO_SPC\"] = 29] = \"OP_INFO_SPC\";\n    State[State[\"INFO_ARG\"] = 30] = \"INFO_ARG\";\n})(State || (exports.State = State = {}));\nvar cc;\n(function (cc) {\n    cc[cc[\"CR\"] = \"\\r\".charCodeAt(0)] = \"CR\";\n    cc[cc[\"E\"] = \"E\".charCodeAt(0)] = \"E\";\n    cc[cc[\"e\"] = \"e\".charCodeAt(0)] = \"e\";\n    cc[cc[\"F\"] = \"F\".charCodeAt(0)] = \"F\";\n    cc[cc[\"f\"] = \"f\".charCodeAt(0)] = \"f\";\n    cc[cc[\"G\"] = \"G\".charCodeAt(0)] = \"G\";\n    cc[cc[\"g\"] = \"g\".charCodeAt(0)] = \"g\";\n    cc[cc[\"H\"] = \"H\".charCodeAt(0)] = \"H\";\n    cc[cc[\"h\"] = \"h\".charCodeAt(0)] = \"h\";\n    cc[cc[\"I\"] = \"I\".charCodeAt(0)] = \"I\";\n    cc[cc[\"i\"] = \"i\".charCodeAt(0)] = \"i\";\n    cc[cc[\"K\"] = \"K\".charCodeAt(0)] = \"K\";\n    cc[cc[\"k\"] = \"k\".charCodeAt(0)] = \"k\";\n    cc[cc[\"M\"] = \"M\".charCodeAt(0)] = \"M\";\n    cc[cc[\"m\"] = \"m\".charCodeAt(0)] = \"m\";\n    cc[cc[\"MINUS\"] = \"-\".charCodeAt(0)] = \"MINUS\";\n    cc[cc[\"N\"] = \"N\".charCodeAt(0)] = \"N\";\n    cc[cc[\"n\"] = \"n\".charCodeAt(0)] = \"n\";\n    cc[cc[\"NL\"] = \"\\n\".charCodeAt(0)] = \"NL\";\n    cc[cc[\"O\"] = \"O\".charCodeAt(0)] = \"O\";\n    cc[cc[\"o\"] = \"o\".charCodeAt(0)] = \"o\";\n    cc[cc[\"P\"] = \"P\".charCodeAt(0)] = \"P\";\n    cc[cc[\"p\"] = \"p\".charCodeAt(0)] = \"p\";\n    cc[cc[\"PLUS\"] = \"+\".charCodeAt(0)] = \"PLUS\";\n    cc[cc[\"R\"] = \"R\".charCodeAt(0)] = \"R\";\n    cc[cc[\"r\"] = \"r\".charCodeAt(0)] = \"r\";\n    cc[cc[\"S\"] = \"S\".charCodeAt(0)] = \"S\";\n    cc[cc[\"s\"] = \"s\".charCodeAt(0)] = \"s\";\n    cc[cc[\"SPACE\"] = \" \".charCodeAt(0)] = \"SPACE\";\n    cc[cc[\"TAB\"] = \"\\t\".charCodeAt(0)] = \"TAB\";\n})(cc || (cc = {}));\n//# sourceMappingURL=parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9wYXJzZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFjO0FBQzNDLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFdBQVcsWUFBWSxZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsR0FBRyxJQUFJLEtBQUs7QUFDMUI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsYUFBYTtBQUMxRSxtREFBbUQsMENBQTBDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOERBQThEO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxlQUFlO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwyQkFBMkI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGlCQUFpQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDRCQUE0QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFdBQVc7QUFDL0M7QUFDQTtBQUNBLHVCQUF1QixPQUFPLEdBQUcsV0FBVztBQUM1QztBQUNBLDRCQUE0QixNQUFNLElBQUksMkJBQTJCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFlBQVksYUFBYSxhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQjtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL25hdHMtYmFzZS1jbGllbnQvcGFyc2VyLmpzP2E2MDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YXRlID0gZXhwb3J0cy5QYXJzZXIgPSBleHBvcnRzLmRlc2NyaWJlID0gZXhwb3J0cy5LaW5kID0gdm9pZCAwO1xuLy8gZGVuby1saW50LWlnbm9yZS1maWxlIG5vLXVuZGVmXG4vKlxuICogQ29weXJpZ2h0IDIwMjAtMjAyMSBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZGVub2J1ZmZlcl8xID0gcmVxdWlyZShcIi4vZGVub2J1ZmZlclwiKTtcbmNvbnN0IGVuY29kZXJzXzEgPSByZXF1aXJlKFwiLi9lbmNvZGVyc1wiKTtcbnZhciBLaW5kO1xuKGZ1bmN0aW9uIChLaW5kKSB7XG4gICAgS2luZFtLaW5kW1wiT0tcIl0gPSAwXSA9IFwiT0tcIjtcbiAgICBLaW5kW0tpbmRbXCJFUlJcIl0gPSAxXSA9IFwiRVJSXCI7XG4gICAgS2luZFtLaW5kW1wiTVNHXCJdID0gMl0gPSBcIk1TR1wiO1xuICAgIEtpbmRbS2luZFtcIklORk9cIl0gPSAzXSA9IFwiSU5GT1wiO1xuICAgIEtpbmRbS2luZFtcIlBJTkdcIl0gPSA0XSA9IFwiUElOR1wiO1xuICAgIEtpbmRbS2luZFtcIlBPTkdcIl0gPSA1XSA9IFwiUE9OR1wiO1xufSkoS2luZCB8fCAoZXhwb3J0cy5LaW5kID0gS2luZCA9IHt9KSk7XG5mdW5jdGlvbiBkZXNjcmliZShlKSB7XG4gICAgbGV0IGtzO1xuICAgIGxldCBkYXRhID0gXCJcIjtcbiAgICBzd2l0Y2ggKGUua2luZCkge1xuICAgICAgICBjYXNlIEtpbmQuTVNHOlxuICAgICAgICAgICAga3MgPSBcIk1TR1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgS2luZC5PSzpcbiAgICAgICAgICAgIGtzID0gXCJPS1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgS2luZC5FUlI6XG4gICAgICAgICAgICBrcyA9IFwiRVJSXCI7XG4gICAgICAgICAgICBkYXRhID0gZW5jb2RlcnNfMS5URC5kZWNvZGUoZS5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEtpbmQuUElORzpcbiAgICAgICAgICAgIGtzID0gXCJQSU5HXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBLaW5kLlBPTkc6XG4gICAgICAgICAgICBrcyA9IFwiUE9OR1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgS2luZC5JTkZPOlxuICAgICAgICAgICAga3MgPSBcIklORk9cIjtcbiAgICAgICAgICAgIGRhdGEgPSBlbmNvZGVyc18xLlRELmRlY29kZShlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7a3N9OiAke2RhdGF9YDtcbn1cbmV4cG9ydHMuZGVzY3JpYmUgPSBkZXNjcmliZTtcbmZ1bmN0aW9uIG5ld01zZ0FyZygpIHtcbiAgICBjb25zdCBtYSA9IHt9O1xuICAgIG1hLnNpZCA9IC0xO1xuICAgIG1hLmhkciA9IC0xO1xuICAgIG1hLnNpemUgPSAtMTtcbiAgICByZXR1cm4gbWE7XG59XG5jb25zdCBBU0NJSV8wID0gNDg7XG5jb25zdCBBU0NJSV85ID0gNTc7XG4vLyBUaGlzIGlzIGFuIGFsbW9zdCB2ZXJiYXRpbSBwb3J0IG9mIHRoZSBHbyBOQVRTIHBhcnNlclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25hdHMtaW8vbmF0cy5nby9ibG9iL21hc3Rlci9wYXJzZXIuZ29cbmNsYXNzIFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoZGlzcGF0Y2hlcikge1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfU1RBUlQ7XG4gICAgICAgIHRoaXMuYXMgPSAwO1xuICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICB0aGlzLmhkciA9IDA7XG4gICAgfVxuICAgIHBhcnNlKGJ1Zikge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYiA9IGJ1ZltpXTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfU1RBUlQ6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5NOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5tOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGRyID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYSA9IG5ld01zZ0FyZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5IOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5oOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9IO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGRyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hID0gbmV3TXNnQXJnKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLnA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlBMVVM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BMVVM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk1JTlVTOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NSU5VUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuSTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuaTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfSTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9IOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MubTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9NOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuUzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTVM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTVM6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5HOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NU0c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTVNHOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlRBQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTVNHX1NQQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9NU0dfU1BDOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlRBQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk1TR19BUkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5NU0dfQVJHOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuQ1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLmFyZ0J1ZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMuYXJnQnVmLmJ5dGVzKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBidWYuc3ViYXJyYXkodGhpcy5hcywgaSAtIHRoaXMuZHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTXNnQXJncyhhcmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5NU0dfUEFZTE9BRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBqdW1wIGFoZWFkIHdpdGggdGhlIGluZGV4LiBJZiB0aGlzIG92ZXJydW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hhdCBpcyBsZWZ0IHdlIGZhbGwgb3V0IGFuZCBwcm9jZXNzIGEgc3BsaXQgYnVmZmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSB0aGlzLmFzICsgdGhpcy5tYS5zaXplIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnQnVmLndyaXRlQnl0ZShiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5NU0dfUEFZTE9BRDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubXNnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tc2dCdWYubGVuZ3RoID49IHRoaXMubWEuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLm1zZ0J1Zi5ieXRlcyh7IGNvcHk6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5wdXNoKHsga2luZDogS2luZC5NU0csIG1zZzogdGhpcy5tYSwgZGF0YTogZGF0YSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ0J1ZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ0J1ZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuTVNHX0VORDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b0NvcHkgPSB0aGlzLm1hLnNpemUgLSB0aGlzLm1zZ0J1Zi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXZhaWwgPSBidWYubGVuZ3RoIC0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXZhaWwgPCB0b0NvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9Db3B5ID0gYXZhaWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b0NvcHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubXNnQnVmLndyaXRlKGJ1Zi5zdWJhcnJheShpLCBpICsgdG9Db3B5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAoaSArIHRvQ29weSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tc2dCdWYud3JpdGVCeXRlKGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpIC0gdGhpcy5hcyA+PSB0aGlzLm1hLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5wdXNoKHsga2luZDogS2luZC5NU0csIG1zZzogdGhpcy5tYSwgZGF0YTogYnVmLnN1YmFycmF5KHRoaXMuYXMsIGkpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcmdCdWYgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1zZ0J1ZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5NU0dfRU5EO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuTVNHX0VORDpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QTFVTOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MubzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfUExVU19PO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX1BMVVNfTzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLks6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLms6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BMVVNfT0s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUExVU19PSzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlci5wdXNoKHsga2luZDogS2luZC5PSyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX01JTlVTOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTUlOVVNfRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9NSU5VU19FOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MucjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTUlOVVNfRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTUlOVVNfRVI6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5yOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9NSU5VU19FUlI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfTUlOVVNfRVJSOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlRBQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfTUlOVVNfRVJSX1NQQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9NSU5VU19FUlJfU1BDOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlRBQjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk1JTlVTX0VSUl9BUkc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5NSU5VU19FUlJfQVJHOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuQ1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyZ0J1Zikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSB0aGlzLmFyZ0J1Zi5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ0J1ZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGJ1Zi5zdWJhcnJheSh0aGlzLmFzLCBpIC0gdGhpcy5kcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnB1c2goeyBraW5kOiBLaW5kLkVSUiwgZGF0YTogYXJnIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcyA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnQnVmLndyaXRlKFVpbnQ4QXJyYXkub2YoYikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX1A6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5JOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5pOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QSTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MubzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfUE87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUE86XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QT047XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RhdGUuT1BfUE9OOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuRzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuZzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfUE9ORztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QT05HOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnB1c2goeyBraW5kOiBLaW5kLlBPTkcgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QSTpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLk46XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLm46XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX1BJTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9QSU46XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5HOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9QSU5HO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX1BJTkc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoZXIucHVzaCh7IGtpbmQ6IEtpbmQuUElORyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9TVEFSVDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX0k6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5OOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9JTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9JTjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLkY6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLmY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlLk9QX0lORjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9JTkY6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5POlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5vOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9JTkZPO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYnVmLnN1YmFycmF5KGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLk9QX0lORk86XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5TUEFDRTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuVEFCOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5PUF9JTkZPX1NQQztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5mYWlsKGJ1Zi5zdWJhcnJheShpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdGF0ZS5PUF9JTkZPX1NQQzpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGNjLlNQQUNFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZS5JTkZPX0FSRztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFzID0gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0YXRlLklORk9fQVJHOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuQ1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgY2MuTkw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyZ0J1Zikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSB0aGlzLmFyZ0J1Zi5ieXRlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ0J1ZiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGJ1Zi5zdWJhcnJheSh0aGlzLmFzLCBpIC0gdGhpcy5kcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnB1c2goeyBraW5kOiBLaW5kLklORk8sIGRhdGE6IGFyZyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXMgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGUuT1BfU1RBUlQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFyZ0J1Zikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ0J1Zi53cml0ZUJ5dGUoYik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChidWYuc3ViYXJyYXkoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy5zdGF0ZSA9PT0gU3RhdGUuTVNHX0FSRyB8fCB0aGlzLnN0YXRlID09PSBTdGF0ZS5NSU5VU19FUlJfQVJHIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBTdGF0ZS5JTkZPX0FSRykgJiYgIXRoaXMuYXJnQnVmKSB7XG4gICAgICAgICAgICB0aGlzLmFyZ0J1ZiA9IG5ldyBkZW5vYnVmZmVyXzEuRGVub0J1ZmZlcihidWYuc3ViYXJyYXkodGhpcy5hcywgaSAtIHRoaXMuZHJvcCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBTdGF0ZS5NU0dfUEFZTE9BRCAmJiAhdGhpcy5tc2dCdWYpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hcmdCdWYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb25lTXNnQXJnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1zZ0J1ZiA9IG5ldyBkZW5vYnVmZmVyXzEuRGVub0J1ZmZlcihidWYuc3ViYXJyYXkodGhpcy5hcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb25lTXNnQXJnKCkge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5tYS5zdWJqZWN0Lmxlbmd0aDtcbiAgICAgICAgY29uc3QgciA9IHRoaXMubWEucmVwbHkgPyB0aGlzLm1hLnJlcGx5Lmxlbmd0aCA6IDA7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KHMgKyByKTtcbiAgICAgICAgYnVmLnNldCh0aGlzLm1hLnN1YmplY3QpO1xuICAgICAgICBpZiAodGhpcy5tYS5yZXBseSkge1xuICAgICAgICAgICAgYnVmLnNldCh0aGlzLm1hLnJlcGx5LCBzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFyZ0J1ZiA9IG5ldyBkZW5vYnVmZmVyXzEuRGVub0J1ZmZlcihidWYpO1xuICAgICAgICB0aGlzLm1hLnN1YmplY3QgPSBidWYuc3ViYXJyYXkoMCwgcyk7XG4gICAgICAgIGlmICh0aGlzLm1hLnJlcGx5KSB7XG4gICAgICAgICAgICB0aGlzLm1hLnJlcGx5ID0gYnVmLnN1YmFycmF5KHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NNc2dBcmdzKGFyZykge1xuICAgICAgICBpZiAodGhpcy5oZHIgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc0hlYWRlck1zZ0FyZ3MoYXJnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgIGxldCBzdGFydCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYiA9IGFyZ1tpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5DUjpcbiAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZy5zdWJhcnJheShzdGFydCwgaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZy5zdWJhcnJheShzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnN1YmplY3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2lkID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMubWEucmVwbHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaXplID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHRoaXMubWEuc3ViamVjdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaWQgPSB0aGlzLnByb3RvUGFyc2VJbnQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5yZXBseSA9IGFyZ3NbMl07XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaXplID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbM10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NNc2dBcmdzIFBhcnNlIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hLnNpZCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChhcmcsIFwicHJvY2Vzc01zZ0FyZ3MgQmFkIG9yIE1pc3NpbmcgU2lkIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hLnNpemUgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NNc2dBcmdzIEJhZCBvciBNaXNzaW5nIFNpemUgRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmFpbChkYXRhLCBsYWJlbCA9IFwiXCIpIHtcbiAgICAgICAgaWYgKCFsYWJlbCkge1xuICAgICAgICAgICAgbGFiZWwgPSBgcGFyc2UgZXJyb3IgWyR7dGhpcy5zdGF0ZX1dYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhYmVsID0gYCR7bGFiZWx9IFske3RoaXMuc3RhdGV9XWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgJHtsYWJlbH06ICR7ZW5jb2RlcnNfMS5URC5kZWNvZGUoZGF0YSl9YCk7XG4gICAgfVxuICAgIHByb2Nlc3NIZWFkZXJNc2dBcmdzKGFyZykge1xuICAgICAgICBjb25zdCBhcmdzID0gW107XG4gICAgICAgIGxldCBzdGFydCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYiA9IGFyZ1tpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoYikge1xuICAgICAgICAgICAgICAgIGNhc2UgY2MuU1BBQ0U6XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5UQUI6XG4gICAgICAgICAgICAgICAgY2FzZSBjYy5DUjpcbiAgICAgICAgICAgICAgICBjYXNlIGNjLk5MOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZy5zdWJhcnJheShzdGFydCwgaSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKGFyZy5zdWJhcnJheShzdGFydCkpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzLm1hLnN1YmplY3QgPSBhcmdzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMubWEuc2lkID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIHRoaXMubWEucmVwbHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5oZHIgPSB0aGlzLnByb3RvUGFyc2VJbnQoYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaXplID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbM10pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHRoaXMubWEuc3ViamVjdCA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaWQgPSB0aGlzLnByb3RvUGFyc2VJbnQoYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5yZXBseSA9IGFyZ3NbMl07XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5oZHIgPSB0aGlzLnByb3RvUGFyc2VJbnQoYXJnc1szXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYS5zaXplID0gdGhpcy5wcm90b1BhcnNlSW50KGFyZ3NbNF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmZhaWwoYXJnLCBcInByb2Nlc3NIZWFkZXJNc2dBcmdzIFBhcnNlIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hLnNpZCA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChhcmcsIFwicHJvY2Vzc0hlYWRlck1zZ0FyZ3MgQmFkIG9yIE1pc3NpbmcgU2lkIEVycm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hLmhkciA8IDAgfHwgdGhpcy5tYS5oZHIgPiB0aGlzLm1hLnNpemUpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChhcmcsIFwicHJvY2Vzc0hlYWRlck1zZ0FyZ3MgQmFkIG9yIE1pc3NpbmcgSGVhZGVyIFNpemUgRXJyb3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWEuc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmFpbChhcmcsIFwicHJvY2Vzc0hlYWRlck1zZ0FyZ3MgQmFkIG9yIE1pc3NpbmcgU2l6ZSBFcnJvclwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90b1BhcnNlSW50KGEpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhW2ldIDwgQVNDSUlfMCB8fCBhW2ldID4gQVNDSUlfOSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBuICogMTAgKyAoYVtpXSAtIEFTQ0lJXzApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xudmFyIFN0YXRlO1xuKGZ1bmN0aW9uIChTdGF0ZSkge1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfU1RBUlRcIl0gPSAwXSA9IFwiT1BfU1RBUlRcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX1BMVVNcIl0gPSAxXSA9IFwiT1BfUExVU1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUExVU19PXCJdID0gMl0gPSBcIk9QX1BMVVNfT1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUExVU19PS1wiXSA9IDNdID0gXCJPUF9QTFVTX09LXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NSU5VU1wiXSA9IDRdID0gXCJPUF9NSU5VU1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfTUlOVVNfRVwiXSA9IDVdID0gXCJPUF9NSU5VU19FXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9NSU5VU19FUlwiXSA9IDZdID0gXCJPUF9NSU5VU19FUlwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfTUlOVVNfRVJSXCJdID0gN10gPSBcIk9QX01JTlVTX0VSUlwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfTUlOVVNfRVJSX1NQQ1wiXSA9IDhdID0gXCJPUF9NSU5VU19FUlJfU1BDXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJNSU5VU19FUlJfQVJHXCJdID0gOV0gPSBcIk1JTlVTX0VSUl9BUkdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01cIl0gPSAxMF0gPSBcIk9QX01cIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01TXCJdID0gMTFdID0gXCJPUF9NU1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfTVNHXCJdID0gMTJdID0gXCJPUF9NU0dcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk9QX01TR19TUENcIl0gPSAxM10gPSBcIk9QX01TR19TUENcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk1TR19BUkdcIl0gPSAxNF0gPSBcIk1TR19BUkdcIjtcbiAgICBTdGF0ZVtTdGF0ZVtcIk1TR19QQVlMT0FEXCJdID0gMTVdID0gXCJNU0dfUEFZTE9BRFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiTVNHX0VORFwiXSA9IDE2XSA9IFwiTVNHX0VORFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfSFwiXSA9IDE3XSA9IFwiT1BfSFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUFwiXSA9IDE4XSA9IFwiT1BfUFwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUElcIl0gPSAxOV0gPSBcIk9QX1BJXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9QSU5cIl0gPSAyMF0gPSBcIk9QX1BJTlwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUElOR1wiXSA9IDIxXSA9IFwiT1BfUElOR1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUE9cIl0gPSAyMl0gPSBcIk9QX1BPXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9QT05cIl0gPSAyM10gPSBcIk9QX1BPTlwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfUE9OR1wiXSA9IDI0XSA9IFwiT1BfUE9OR1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfSVwiXSA9IDI1XSA9IFwiT1BfSVwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfSU5cIl0gPSAyNl0gPSBcIk9QX0lOXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJPUF9JTkZcIl0gPSAyN10gPSBcIk9QX0lORlwiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfSU5GT1wiXSA9IDI4XSA9IFwiT1BfSU5GT1wiO1xuICAgIFN0YXRlW1N0YXRlW1wiT1BfSU5GT19TUENcIl0gPSAyOV0gPSBcIk9QX0lORk9fU1BDXCI7XG4gICAgU3RhdGVbU3RhdGVbXCJJTkZPX0FSR1wiXSA9IDMwXSA9IFwiSU5GT19BUkdcIjtcbn0pKFN0YXRlIHx8IChleHBvcnRzLlN0YXRlID0gU3RhdGUgPSB7fSkpO1xudmFyIGNjO1xuKGZ1bmN0aW9uIChjYykge1xuICAgIGNjW2NjW1wiQ1JcIl0gPSBcIlxcclwiLmNoYXJDb2RlQXQoMCldID0gXCJDUlwiO1xuICAgIGNjW2NjW1wiRVwiXSA9IFwiRVwiLmNoYXJDb2RlQXQoMCldID0gXCJFXCI7XG4gICAgY2NbY2NbXCJlXCJdID0gXCJlXCIuY2hhckNvZGVBdCgwKV0gPSBcImVcIjtcbiAgICBjY1tjY1tcIkZcIl0gPSBcIkZcIi5jaGFyQ29kZUF0KDApXSA9IFwiRlwiO1xuICAgIGNjW2NjW1wiZlwiXSA9IFwiZlwiLmNoYXJDb2RlQXQoMCldID0gXCJmXCI7XG4gICAgY2NbY2NbXCJHXCJdID0gXCJHXCIuY2hhckNvZGVBdCgwKV0gPSBcIkdcIjtcbiAgICBjY1tjY1tcImdcIl0gPSBcImdcIi5jaGFyQ29kZUF0KDApXSA9IFwiZ1wiO1xuICAgIGNjW2NjW1wiSFwiXSA9IFwiSFwiLmNoYXJDb2RlQXQoMCldID0gXCJIXCI7XG4gICAgY2NbY2NbXCJoXCJdID0gXCJoXCIuY2hhckNvZGVBdCgwKV0gPSBcImhcIjtcbiAgICBjY1tjY1tcIklcIl0gPSBcIklcIi5jaGFyQ29kZUF0KDApXSA9IFwiSVwiO1xuICAgIGNjW2NjW1wiaVwiXSA9IFwiaVwiLmNoYXJDb2RlQXQoMCldID0gXCJpXCI7XG4gICAgY2NbY2NbXCJLXCJdID0gXCJLXCIuY2hhckNvZGVBdCgwKV0gPSBcIktcIjtcbiAgICBjY1tjY1tcImtcIl0gPSBcImtcIi5jaGFyQ29kZUF0KDApXSA9IFwia1wiO1xuICAgIGNjW2NjW1wiTVwiXSA9IFwiTVwiLmNoYXJDb2RlQXQoMCldID0gXCJNXCI7XG4gICAgY2NbY2NbXCJtXCJdID0gXCJtXCIuY2hhckNvZGVBdCgwKV0gPSBcIm1cIjtcbiAgICBjY1tjY1tcIk1JTlVTXCJdID0gXCItXCIuY2hhckNvZGVBdCgwKV0gPSBcIk1JTlVTXCI7XG4gICAgY2NbY2NbXCJOXCJdID0gXCJOXCIuY2hhckNvZGVBdCgwKV0gPSBcIk5cIjtcbiAgICBjY1tjY1tcIm5cIl0gPSBcIm5cIi5jaGFyQ29kZUF0KDApXSA9IFwiblwiO1xuICAgIGNjW2NjW1wiTkxcIl0gPSBcIlxcblwiLmNoYXJDb2RlQXQoMCldID0gXCJOTFwiO1xuICAgIGNjW2NjW1wiT1wiXSA9IFwiT1wiLmNoYXJDb2RlQXQoMCldID0gXCJPXCI7XG4gICAgY2NbY2NbXCJvXCJdID0gXCJvXCIuY2hhckNvZGVBdCgwKV0gPSBcIm9cIjtcbiAgICBjY1tjY1tcIlBcIl0gPSBcIlBcIi5jaGFyQ29kZUF0KDApXSA9IFwiUFwiO1xuICAgIGNjW2NjW1wicFwiXSA9IFwicFwiLmNoYXJDb2RlQXQoMCldID0gXCJwXCI7XG4gICAgY2NbY2NbXCJQTFVTXCJdID0gXCIrXCIuY2hhckNvZGVBdCgwKV0gPSBcIlBMVVNcIjtcbiAgICBjY1tjY1tcIlJcIl0gPSBcIlJcIi5jaGFyQ29kZUF0KDApXSA9IFwiUlwiO1xuICAgIGNjW2NjW1wiclwiXSA9IFwiclwiLmNoYXJDb2RlQXQoMCldID0gXCJyXCI7XG4gICAgY2NbY2NbXCJTXCJdID0gXCJTXCIuY2hhckNvZGVBdCgwKV0gPSBcIlNcIjtcbiAgICBjY1tjY1tcInNcIl0gPSBcInNcIi5jaGFyQ29kZUF0KDApXSA9IFwic1wiO1xuICAgIGNjW2NjW1wiU1BBQ0VcIl0gPSBcIiBcIi5jaGFyQ29kZUF0KDApXSA9IFwiU1BBQ0VcIjtcbiAgICBjY1tjY1tcIlRBQlwiXSA9IFwiXFx0XCIuY2hhckNvZGVBdCgwKV0gPSBcIlRBQlwiO1xufSkoY2MgfHwgKGNjID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/protocol.js":
/*!************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/protocol.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProtocolHandler = exports.Subscriptions = exports.SubscriptionImpl = exports.Connect = exports.INFO = void 0;\n/*\n * Copyright 2018-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/nats/lib/nats-base-client/transport.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst databuffer_1 = __webpack_require__(/*! ./databuffer */ \"(rsc)/./node_modules/nats/lib/nats-base-client/databuffer.js\");\nconst servers_1 = __webpack_require__(/*! ./servers */ \"(rsc)/./node_modules/nats/lib/nats-base-client/servers.js\");\nconst queued_iterator_1 = __webpack_require__(/*! ./queued_iterator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\");\nconst muxsubscription_1 = __webpack_require__(/*! ./muxsubscription */ \"(rsc)/./node_modules/nats/lib/nats-base-client/muxsubscription.js\");\nconst heartbeats_1 = __webpack_require__(/*! ./heartbeats */ \"(rsc)/./node_modules/nats/lib/nats-base-client/heartbeats.js\");\nconst parser_1 = __webpack_require__(/*! ./parser */ \"(rsc)/./node_modules/nats/lib/nats-base-client/parser.js\");\nconst msg_1 = __webpack_require__(/*! ./msg */ \"(rsc)/./node_modules/nats/lib/nats-base-client/msg.js\");\nconst semver_1 = __webpack_require__(/*! ./semver */ \"(rsc)/./node_modules/nats/lib/nats-base-client/semver.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nconst options_1 = __webpack_require__(/*! ./options */ \"(rsc)/./node_modules/nats/lib/nats-base-client/options.js\");\nconst FLUSH_THRESHOLD = 1024 * 32;\nexports.INFO = /^INFO\\s+([^\\r\\n]+)\\r\\n/i;\nconst PONG_CMD = (0, encoders_1.encode)(\"PONG\\r\\n\");\nconst PING_CMD = (0, encoders_1.encode)(\"PING\\r\\n\");\nclass Connect {\n    constructor(transport, opts, nonce) {\n        this.protocol = 1;\n        this.version = transport.version;\n        this.lang = transport.lang;\n        this.echo = opts.noEcho ? false : undefined;\n        this.verbose = opts.verbose;\n        this.pedantic = opts.pedantic;\n        this.tls_required = opts.tls ? true : undefined;\n        this.name = opts.name;\n        const creds = (opts && typeof opts.authenticator === \"function\"\n            ? opts.authenticator(nonce)\n            : {}) || {};\n        (0, util_1.extend)(this, creds);\n    }\n}\nexports.Connect = Connect;\nclass SubscriptionImpl extends queued_iterator_1.QueuedIteratorImpl {\n    constructor(protocol, subject, opts = {}) {\n        var _a;\n        super();\n        (0, util_1.extend)(this, opts);\n        this.protocol = protocol;\n        this.subject = subject;\n        this.draining = false;\n        this.noIterator = typeof opts.callback === \"function\";\n        this.closed = (0, util_1.deferred)();\n        const asyncTraces = !(((_a = protocol.options) === null || _a === void 0 ? void 0 : _a.noAsyncTraces) || false);\n        if (opts.timeout) {\n            this.timer = (0, util_1.timeout)(opts.timeout, asyncTraces);\n            this.timer\n                .then(() => {\n                // timer was cancelled\n                this.timer = undefined;\n            })\n                .catch((err) => {\n                // timer fired\n                this.stop(err);\n                if (this.noIterator) {\n                    this.callback(err, {});\n                }\n            });\n        }\n        if (!this.noIterator) {\n            // cleanup - they used break or return from the iterator\n            // make sure we clean up, if they didn't call unsub\n            this.iterClosed.then(() => {\n                this.closed.resolve();\n                this.unsubscribe();\n            });\n        }\n    }\n    setPrePostHandlers(opts) {\n        if (this.noIterator) {\n            const uc = this.callback;\n            const ingestion = opts.ingestionFilterFn\n                ? opts.ingestionFilterFn\n                : () => {\n                    return { ingest: true, protocol: false };\n                };\n            const filter = opts.protocolFilterFn ? opts.protocolFilterFn : () => {\n                return true;\n            };\n            const dispatched = opts.dispatchedFn ? opts.dispatchedFn : () => { };\n            this.callback = (err, msg) => {\n                const { ingest } = ingestion(msg);\n                if (!ingest) {\n                    return;\n                }\n                if (filter(msg)) {\n                    uc(err, msg);\n                    dispatched(msg);\n                }\n            };\n        }\n        else {\n            this.protocolFilterFn = opts.protocolFilterFn;\n            this.dispatchedFn = opts.dispatchedFn;\n        }\n    }\n    callback(err, msg) {\n        this.cancelTimeout();\n        err ? this.stop(err) : this.push(msg);\n    }\n    close() {\n        if (!this.isClosed()) {\n            this.cancelTimeout();\n            const fn = () => {\n                this.stop();\n                if (this.cleanupFn) {\n                    try {\n                        this.cleanupFn(this, this.info);\n                    }\n                    catch (_err) {\n                        // ignoring\n                    }\n                }\n                this.closed.resolve();\n            };\n            if (this.noIterator) {\n                fn();\n            }\n            else {\n                //@ts-ignore: schedule the close once all messages are processed\n                this.push(fn);\n            }\n        }\n    }\n    unsubscribe(max) {\n        this.protocol.unsubscribe(this, max);\n    }\n    cancelTimeout() {\n        if (this.timer) {\n            this.timer.cancel();\n            this.timer = undefined;\n        }\n    }\n    drain() {\n        if (this.protocol.isClosed()) {\n            return Promise.reject(core_1.NatsError.errorForCode(core_1.ErrorCode.ConnectionClosed));\n        }\n        if (this.isClosed()) {\n            return Promise.reject(core_1.NatsError.errorForCode(core_1.ErrorCode.SubClosed));\n        }\n        if (!this.drained) {\n            this.draining = true;\n            this.protocol.unsub(this);\n            this.drained = this.protocol.flush((0, util_1.deferred)())\n                .then(() => {\n                this.protocol.subscriptions.cancel(this);\n            })\n                .catch(() => {\n                this.protocol.subscriptions.cancel(this);\n            });\n        }\n        return this.drained;\n    }\n    isDraining() {\n        return this.draining;\n    }\n    isClosed() {\n        return this.done;\n    }\n    getSubject() {\n        return this.subject;\n    }\n    getMax() {\n        return this.max;\n    }\n    getID() {\n        return this.sid;\n    }\n}\nexports.SubscriptionImpl = SubscriptionImpl;\nclass Subscriptions {\n    constructor() {\n        this.sidCounter = 0;\n        this.mux = null;\n        this.subs = new Map();\n    }\n    size() {\n        return this.subs.size;\n    }\n    add(s) {\n        this.sidCounter++;\n        s.sid = this.sidCounter;\n        this.subs.set(s.sid, s);\n        return s;\n    }\n    setMux(s) {\n        this.mux = s;\n        return s;\n    }\n    getMux() {\n        return this.mux;\n    }\n    get(sid) {\n        return this.subs.get(sid);\n    }\n    resub(s) {\n        this.sidCounter++;\n        this.subs.delete(s.sid);\n        s.sid = this.sidCounter;\n        this.subs.set(s.sid, s);\n        return s;\n    }\n    all() {\n        return Array.from(this.subs.values());\n    }\n    cancel(s) {\n        if (s) {\n            s.close();\n            this.subs.delete(s.sid);\n        }\n    }\n    handleError(err) {\n        if (err && err.permissionContext) {\n            const ctx = err.permissionContext;\n            const subs = this.all();\n            let sub;\n            if (ctx.operation === \"subscription\") {\n                sub = subs.find((s) => {\n                    return s.subject === ctx.subject;\n                });\n            }\n            if (ctx.operation === \"publish\") {\n                // we have a no mux subscription\n                sub = subs.find((s) => {\n                    return s.requestSubject === ctx.subject;\n                });\n            }\n            if (sub) {\n                sub.callback(err, {});\n                sub.close();\n                this.subs.delete(sub.sid);\n                return sub !== this.mux;\n            }\n        }\n        return false;\n    }\n    close() {\n        this.subs.forEach((sub) => {\n            sub.close();\n        });\n    }\n}\nexports.Subscriptions = Subscriptions;\nclass ProtocolHandler {\n    constructor(options, publisher) {\n        this._closed = false;\n        this.connected = false;\n        this.connectedOnce = false;\n        this.infoReceived = false;\n        this.noMorePublishing = false;\n        this.abortReconnect = false;\n        this.listeners = [];\n        this.pendingLimit = FLUSH_THRESHOLD;\n        this.outMsgs = 0;\n        this.inMsgs = 0;\n        this.outBytes = 0;\n        this.inBytes = 0;\n        this.options = options;\n        this.publisher = publisher;\n        this.subscriptions = new Subscriptions();\n        this.muxSubscriptions = new muxsubscription_1.MuxSubscription();\n        this.outbound = new databuffer_1.DataBuffer();\n        this.pongs = [];\n        this.whyClosed = \"\";\n        //@ts-ignore: options.pendingLimit is hidden\n        this.pendingLimit = options.pendingLimit || this.pendingLimit;\n        this.features = new semver_1.Features({ major: 0, minor: 0, micro: 0 });\n        this.connectPromise = null;\n        const servers = typeof options.servers === \"string\"\n            ? [options.servers]\n            : options.servers;\n        this.servers = new servers_1.Servers(servers, {\n            randomize: !options.noRandomize,\n        });\n        this.closed = (0, util_1.deferred)();\n        this.parser = new parser_1.Parser(this);\n        this.heartbeats = new heartbeats_1.Heartbeat(this, this.options.pingInterval || options_1.DEFAULT_PING_INTERVAL, this.options.maxPingOut || options_1.DEFAULT_MAX_PING_OUT);\n    }\n    resetOutbound() {\n        this.outbound.reset();\n        const pongs = this.pongs;\n        this.pongs = [];\n        // reject the pongs - the disconnect from here shouldn't have a trace\n        // because that confuses API consumers\n        const err = core_1.NatsError.errorForCode(core_1.ErrorCode.Disconnect);\n        err.stack = \"\";\n        pongs.forEach((p) => {\n            p.reject(err);\n        });\n        this.parser = new parser_1.Parser(this);\n        this.infoReceived = false;\n    }\n    dispatchStatus(status) {\n        this.listeners.forEach((q) => {\n            q.push(status);\n        });\n    }\n    status() {\n        const iter = new queued_iterator_1.QueuedIteratorImpl();\n        this.listeners.push(iter);\n        return iter;\n    }\n    prepare() {\n        if (this.transport) {\n            this.transport.discard();\n        }\n        this.info = undefined;\n        this.resetOutbound();\n        const pong = (0, util_1.deferred)();\n        pong.catch(() => {\n            // provide at least one catch - as pong rejection can happen before it is expected\n        });\n        this.pongs.unshift(pong);\n        this.connectError = (err) => {\n            pong.reject(err);\n        };\n        this.transport = (0, transport_1.newTransport)();\n        this.transport.closed()\n            .then((_err) => __awaiter(this, void 0, void 0, function* () {\n            this.connected = false;\n            if (!this.isClosed()) {\n                // if the transport gave an error use that, otherwise\n                // we may have received a protocol error\n                yield this.disconnected(this.transport.closeError || this.lastError);\n                return;\n            }\n        }));\n        return pong;\n    }\n    disconnect() {\n        this.dispatchStatus({ type: core_1.DebugEvents.StaleConnection, data: \"\" });\n        this.transport.disconnect();\n    }\n    reconnect() {\n        if (this.connected) {\n            this.dispatchStatus({\n                type: core_1.DebugEvents.ClientInitiatedReconnect,\n                data: \"\",\n            });\n            this.transport.disconnect();\n        }\n        return Promise.resolve();\n    }\n    disconnected(err) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.dispatchStatus({\n                type: core_1.Events.Disconnect,\n                data: this.servers.getCurrentServer().toString(),\n            });\n            if (this.options.reconnect) {\n                yield this.dialLoop()\n                    .then(() => {\n                    var _a;\n                    this.dispatchStatus({\n                        type: core_1.Events.Reconnect,\n                        data: this.servers.getCurrentServer().toString(),\n                    });\n                    // if we are here we reconnected, but we have an authentication\n                    // that expired, we need to clean it up, otherwise we'll queue up\n                    // two of these, and the default for the client will be to\n                    // close, rather than attempt again - possibly they have an\n                    // authenticator that dynamically updates\n                    if (((_a = this.lastError) === null || _a === void 0 ? void 0 : _a.code) === core_1.ErrorCode.AuthenticationExpired) {\n                        this.lastError = undefined;\n                    }\n                })\n                    .catch((err) => {\n                    this._close(err);\n                });\n            }\n            else {\n                yield this._close(err);\n            }\n        });\n    }\n    dial(srv) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pong = this.prepare();\n            let timer;\n            try {\n                timer = (0, util_1.timeout)(this.options.timeout || 20000);\n                const cp = this.transport.connect(srv, this.options);\n                yield Promise.race([cp, timer]);\n                (() => __awaiter(this, void 0, void 0, function* () {\n                    var _a, e_1, _b, _c;\n                    try {\n                        try {\n                            for (var _d = true, _e = __asyncValues(this.transport), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {\n                                _c = _f.value;\n                                _d = false;\n                                const b = _c;\n                                this.parser.parse(b);\n                            }\n                        }\n                        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                        finally {\n                            try {\n                                if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                            }\n                            finally { if (e_1) throw e_1.error; }\n                        }\n                    }\n                    catch (err) {\n                        console.log(\"reader closed\", err);\n                    }\n                }))().then();\n            }\n            catch (err) {\n                pong.reject(err);\n            }\n            try {\n                yield Promise.race([timer, pong]);\n                if (timer) {\n                    timer.cancel();\n                }\n                this.connected = true;\n                this.connectError = undefined;\n                this.sendSubscriptions();\n                this.connectedOnce = true;\n                this.server.didConnect = true;\n                this.server.reconnects = 0;\n                this.flushPending();\n                this.heartbeats.start();\n            }\n            catch (err) {\n                if (timer) {\n                    timer.cancel();\n                }\n                yield this.transport.close(err);\n                throw err;\n            }\n        });\n    }\n    _doDial(srv) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const alts = yield srv.resolve({\n                fn: (0, transport_1.getResolveFn)(),\n                debug: this.options.debug,\n                randomize: !this.options.noRandomize,\n            });\n            let lastErr = null;\n            for (const a of alts) {\n                try {\n                    lastErr = null;\n                    this.dispatchStatus({ type: core_1.DebugEvents.Reconnecting, data: a.toString() });\n                    yield this.dial(a);\n                    // if here we connected\n                    return;\n                }\n                catch (err) {\n                    lastErr = err;\n                }\n            }\n            // if we are here, we failed, and we have no additional\n            // alternatives for this server\n            throw lastErr;\n        });\n    }\n    dialLoop() {\n        if (this.connectPromise === null) {\n            this.connectPromise = this.dodialLoop();\n            this.connectPromise\n                .then(() => { })\n                .catch(() => { })\n                .finally(() => {\n                this.connectPromise = null;\n            });\n        }\n        return this.connectPromise;\n    }\n    dodialLoop() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let lastError;\n            while (true) {\n                if (this._closed) {\n                    // if we are disconnected, and close is called, the client\n                    // still tries to reconnect - to match the reconnect policy\n                    // in the case of close, want to stop.\n                    this.servers.clear();\n                }\n                const wait = this.options.reconnectDelayHandler\n                    ? this.options.reconnectDelayHandler()\n                    : options_1.DEFAULT_RECONNECT_TIME_WAIT;\n                let maxWait = wait;\n                const srv = this.selectServer();\n                if (!srv || this.abortReconnect) {\n                    if (lastError) {\n                        throw lastError;\n                    }\n                    else if (this.lastError) {\n                        throw this.lastError;\n                    }\n                    else {\n                        throw core_1.NatsError.errorForCode(core_1.ErrorCode.ConnectionRefused);\n                    }\n                }\n                const now = Date.now();\n                if (srv.lastConnect === 0 || srv.lastConnect + wait <= now) {\n                    srv.lastConnect = Date.now();\n                    try {\n                        yield this._doDial(srv);\n                        break;\n                    }\n                    catch (err) {\n                        lastError = err;\n                        if (!this.connectedOnce) {\n                            if (this.options.waitOnFirstConnect) {\n                                continue;\n                            }\n                            this.servers.removeCurrentServer();\n                        }\n                        srv.reconnects++;\n                        const mra = this.options.maxReconnectAttempts || 0;\n                        if (mra !== -1 && srv.reconnects >= mra) {\n                            this.servers.removeCurrentServer();\n                        }\n                    }\n                }\n                else {\n                    maxWait = Math.min(maxWait, srv.lastConnect + wait - now);\n                    yield (0, util_1.delay)(maxWait);\n                }\n            }\n        });\n    }\n    static connect(options, publisher) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const h = new ProtocolHandler(options, publisher);\n            yield h.dialLoop();\n            return h;\n        });\n    }\n    static toError(s) {\n        const t = s ? s.toLowerCase() : \"\";\n        if (t.indexOf(\"permissions violation\") !== -1) {\n            const err = new core_1.NatsError(s, core_1.ErrorCode.PermissionsViolation);\n            const m = s.match(/(Publish|Subscription) to \"(\\S+)\"/);\n            if (m) {\n                err.permissionContext = {\n                    operation: m[1].toLowerCase(),\n                    subject: m[2],\n                };\n            }\n            return err;\n        }\n        else if (t.indexOf(\"authorization violation\") !== -1) {\n            return new core_1.NatsError(s, core_1.ErrorCode.AuthorizationViolation);\n        }\n        else if (t.indexOf(\"user authentication expired\") !== -1) {\n            return new core_1.NatsError(s, core_1.ErrorCode.AuthenticationExpired);\n        }\n        else if (t.indexOf(\"authentication timeout\") !== -1) {\n            return new core_1.NatsError(s, core_1.ErrorCode.AuthenticationTimeout);\n        }\n        else {\n            return new core_1.NatsError(s, core_1.ErrorCode.ProtocolError);\n        }\n    }\n    processMsg(msg, data) {\n        this.inMsgs++;\n        this.inBytes += data.length;\n        if (!this.subscriptions.sidCounter) {\n            return;\n        }\n        const sub = this.subscriptions.get(msg.sid);\n        if (!sub) {\n            return;\n        }\n        sub.received += 1;\n        if (sub.callback) {\n            sub.callback(null, new msg_1.MsgImpl(msg, data, this));\n        }\n        if (sub.max !== undefined && sub.received >= sub.max) {\n            sub.unsubscribe();\n        }\n    }\n    processError(m) {\n        const s = (0, encoders_1.decode)(m);\n        const err = ProtocolHandler.toError(s);\n        const status = { type: core_1.Events.Error, data: err.code };\n        if (err.isPermissionError()) {\n            let isMuxPermissionError = false;\n            if (err.permissionContext) {\n                status.permissionContext = err.permissionContext;\n                const mux = this.subscriptions.getMux();\n                isMuxPermissionError = (mux === null || mux === void 0 ? void 0 : mux.subject) === err.permissionContext.subject;\n            }\n            this.subscriptions.handleError(err);\n            this.muxSubscriptions.handleError(isMuxPermissionError, err);\n            if (isMuxPermissionError) {\n                // remove the permission - enable it to be recreated\n                this.subscriptions.setMux(null);\n            }\n        }\n        this.dispatchStatus(status);\n        this.handleError(err);\n    }\n    handleError(err) {\n        if (err.isAuthError()) {\n            this.handleAuthError(err);\n        }\n        else if (err.isProtocolError()) {\n            this.lastError = err;\n        }\n        else if (err.isAuthTimeout()) {\n            this.lastError = err;\n        }\n        // fallthrough here\n        if (!err.isPermissionError()) {\n            this.lastError = err;\n        }\n    }\n    handleAuthError(err) {\n        if ((this.lastError && err.code === this.lastError.code) &&\n            this.options.ignoreAuthErrorAbort === false) {\n            this.abortReconnect = true;\n        }\n        if (this.connectError) {\n            this.connectError(err);\n        }\n        else {\n            this.disconnect();\n        }\n    }\n    processPing() {\n        this.transport.send(PONG_CMD);\n    }\n    processPong() {\n        const cb = this.pongs.shift();\n        if (cb) {\n            cb.resolve();\n        }\n    }\n    processInfo(m) {\n        const info = JSON.parse((0, encoders_1.decode)(m));\n        this.info = info;\n        const updates = this.options && this.options.ignoreClusterUpdates\n            ? undefined\n            : this.servers.update(info, this.transport.isEncrypted());\n        if (!this.infoReceived) {\n            this.features.update((0, semver_1.parseSemVer)(info.version));\n            this.infoReceived = true;\n            if (this.transport.isEncrypted()) {\n                this.servers.updateTLSName();\n            }\n            // send connect\n            const { version, lang } = this.transport;\n            try {\n                const c = new Connect({ version, lang }, this.options, info.nonce);\n                if (info.headers) {\n                    c.headers = true;\n                    c.no_responders = true;\n                }\n                const cs = JSON.stringify(c);\n                this.transport.send((0, encoders_1.encode)(`CONNECT ${cs}${transport_1.CR_LF}`));\n                this.transport.send(PING_CMD);\n            }\n            catch (err) {\n                // if we are dying here, this is likely some an authenticator blowing up\n                this._close(err);\n            }\n        }\n        if (updates) {\n            this.dispatchStatus({ type: core_1.Events.Update, data: updates });\n        }\n        const ldm = info.ldm !== undefined ? info.ldm : false;\n        if (ldm) {\n            this.dispatchStatus({\n                type: core_1.Events.LDM,\n                data: this.servers.getCurrentServer().toString(),\n            });\n        }\n    }\n    push(e) {\n        switch (e.kind) {\n            case parser_1.Kind.MSG: {\n                const { msg, data } = e;\n                this.processMsg(msg, data);\n                break;\n            }\n            case parser_1.Kind.OK:\n                break;\n            case parser_1.Kind.ERR:\n                this.processError(e.data);\n                break;\n            case parser_1.Kind.PING:\n                this.processPing();\n                break;\n            case parser_1.Kind.PONG:\n                this.processPong();\n                break;\n            case parser_1.Kind.INFO:\n                this.processInfo(e.data);\n                break;\n        }\n    }\n    sendCommand(cmd, ...payloads) {\n        const len = this.outbound.length();\n        let buf;\n        if (typeof cmd === \"string\") {\n            buf = (0, encoders_1.encode)(cmd);\n        }\n        else {\n            buf = cmd;\n        }\n        this.outbound.fill(buf, ...payloads);\n        if (len === 0) {\n            queueMicrotask(() => {\n                this.flushPending();\n            });\n        }\n        else if (this.outbound.size() >= this.pendingLimit) {\n            // flush inline\n            this.flushPending();\n        }\n    }\n    publish(subject, payload = encoders_1.Empty, options) {\n        let data;\n        if (payload instanceof Uint8Array) {\n            data = payload;\n        }\n        else if (typeof payload === \"string\") {\n            data = encoders_1.TE.encode(payload);\n        }\n        else {\n            throw core_1.NatsError.errorForCode(core_1.ErrorCode.BadPayload);\n        }\n        let len = data.length;\n        options = options || {};\n        options.reply = options.reply || \"\";\n        let headers = encoders_1.Empty;\n        let hlen = 0;\n        if (options.headers) {\n            if (this.info && !this.info.headers) {\n                throw new core_1.NatsError(\"headers\", core_1.ErrorCode.ServerOptionNotAvailable);\n            }\n            const hdrs = options.headers;\n            headers = hdrs.encode();\n            hlen = headers.length;\n            len = data.length + hlen;\n        }\n        if (this.info && len > this.info.max_payload) {\n            throw core_1.NatsError.errorForCode(core_1.ErrorCode.MaxPayloadExceeded);\n        }\n        this.outBytes += len;\n        this.outMsgs++;\n        let proto;\n        if (options.headers) {\n            if (options.reply) {\n                proto = `HPUB ${subject} ${options.reply} ${hlen} ${len}\\r\\n`;\n            }\n            else {\n                proto = `HPUB ${subject} ${hlen} ${len}\\r\\n`;\n            }\n            this.sendCommand(proto, headers, data, transport_1.CRLF);\n        }\n        else {\n            if (options.reply) {\n                proto = `PUB ${subject} ${options.reply} ${len}\\r\\n`;\n            }\n            else {\n                proto = `PUB ${subject} ${len}\\r\\n`;\n            }\n            this.sendCommand(proto, data, transport_1.CRLF);\n        }\n    }\n    request(r) {\n        this.initMux();\n        this.muxSubscriptions.add(r);\n        return r;\n    }\n    subscribe(s) {\n        this.subscriptions.add(s);\n        this._subunsub(s);\n        return s;\n    }\n    _sub(s) {\n        if (s.queue) {\n            this.sendCommand(`SUB ${s.subject} ${s.queue} ${s.sid}\\r\\n`);\n        }\n        else {\n            this.sendCommand(`SUB ${s.subject} ${s.sid}\\r\\n`);\n        }\n    }\n    _subunsub(s) {\n        this._sub(s);\n        if (s.max) {\n            this.unsubscribe(s, s.max);\n        }\n        return s;\n    }\n    unsubscribe(s, max) {\n        this.unsub(s, max);\n        if (s.max === undefined || s.received >= s.max) {\n            this.subscriptions.cancel(s);\n        }\n    }\n    unsub(s, max) {\n        if (!s || this.isClosed()) {\n            return;\n        }\n        if (max) {\n            this.sendCommand(`UNSUB ${s.sid} ${max}\\r\\n`);\n        }\n        else {\n            this.sendCommand(`UNSUB ${s.sid}\\r\\n`);\n        }\n        s.max = max;\n    }\n    resub(s, subject) {\n        if (!s || this.isClosed()) {\n            return;\n        }\n        s.subject = subject;\n        this.subscriptions.resub(s);\n        // we don't auto-unsub here because we don't\n        // really know \"processed\"\n        this._sub(s);\n    }\n    flush(p) {\n        if (!p) {\n            p = (0, util_1.deferred)();\n        }\n        this.pongs.push(p);\n        this.outbound.fill(PING_CMD);\n        this.flushPending();\n        return p;\n    }\n    sendSubscriptions() {\n        const cmds = [];\n        this.subscriptions.all().forEach((s) => {\n            const sub = s;\n            if (sub.queue) {\n                cmds.push(`SUB ${sub.subject} ${sub.queue} ${sub.sid}${transport_1.CR_LF}`);\n            }\n            else {\n                cmds.push(`SUB ${sub.subject} ${sub.sid}${transport_1.CR_LF}`);\n            }\n        });\n        if (cmds.length) {\n            this.transport.send((0, encoders_1.encode)(cmds.join(\"\")));\n        }\n    }\n    _close(err) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._closed) {\n                return;\n            }\n            this.whyClosed = new Error(\"close trace\").stack || \"\";\n            this.heartbeats.cancel();\n            if (this.connectError) {\n                this.connectError(err);\n                this.connectError = undefined;\n            }\n            this.muxSubscriptions.close();\n            this.subscriptions.close();\n            this.listeners.forEach((l) => {\n                l.stop();\n            });\n            this._closed = true;\n            yield this.transport.close(err);\n            yield this.closed.resolve(err);\n        });\n    }\n    close() {\n        return this._close();\n    }\n    isClosed() {\n        return this._closed;\n    }\n    drain() {\n        const subs = this.subscriptions.all();\n        const promises = [];\n        subs.forEach((sub) => {\n            promises.push(sub.drain());\n        });\n        return Promise.all(promises)\n            .then(() => __awaiter(this, void 0, void 0, function* () {\n            this.noMorePublishing = true;\n            yield this.flush();\n            return this.close();\n        }))\n            .catch(() => {\n            // cannot happen\n        });\n    }\n    flushPending() {\n        if (!this.infoReceived || !this.connected) {\n            return;\n        }\n        if (this.outbound.size()) {\n            const d = this.outbound.drain();\n            this.transport.send(d);\n        }\n    }\n    initMux() {\n        const mux = this.subscriptions.getMux();\n        if (!mux) {\n            const inbox = this.muxSubscriptions.init(this.options.inboxPrefix);\n            // dot is already part of mux\n            const sub = new SubscriptionImpl(this, `${inbox}*`);\n            sub.callback = this.muxSubscriptions.dispatcher();\n            this.subscriptions.setMux(sub);\n            this.subscribe(sub);\n        }\n    }\n    selectServer() {\n        const server = this.servers.selectServer();\n        if (server === undefined) {\n            return undefined;\n        }\n        // Place in client context.\n        this.server = server;\n        return this.server;\n    }\n    getServer() {\n        return this.server;\n    }\n}\nexports.ProtocolHandler = ProtocolHandler;\n//# sourceMappingURL=protocol.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9wcm90b2NvbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsdUZBQXVGLGNBQWM7QUFDaE4sdUJBQXVCLDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsWUFBWTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsOEVBQVk7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMsZ0ZBQWE7QUFDekMsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFjO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLDRFQUFXO0FBQ3JDLDBCQUEwQixtQkFBTyxDQUFDLDRGQUFtQjtBQUNyRCwwQkFBMEIsbUJBQU8sQ0FBQyw0RkFBbUI7QUFDckQscUJBQXFCLG1CQUFPLENBQUMsa0ZBQWM7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsMEVBQVU7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLG9FQUFPO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLDBFQUFVO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxzRUFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBVztBQUNyQztBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsOEJBQThCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0RBQW9EO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YseUNBQXlDO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkRBQTJEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsR0FBRyxFQUFFLGtCQUFrQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJDQUEyQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVMsRUFBRSxlQUFlLEVBQUUsTUFBTSxFQUFFLElBQUk7QUFDeEU7QUFDQTtBQUNBLGdDQUFnQyxTQUFTLEVBQUUsTUFBTSxFQUFFLElBQUk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixTQUFTLEVBQUUsZUFBZSxFQUFFLElBQUk7QUFDL0Q7QUFDQTtBQUNBLCtCQUErQixTQUFTLEVBQUUsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXLEVBQUUsU0FBUyxFQUFFLE1BQU07QUFDbEU7QUFDQTtBQUNBLG9DQUFvQyxXQUFXLEVBQUUsTUFBTTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU8sRUFBRSxJQUFJO0FBQ25EO0FBQ0E7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYSxFQUFFLFdBQVcsRUFBRSxRQUFRLEVBQUUsa0JBQWtCO0FBQ3pGO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYSxFQUFFLFFBQVEsRUFBRSxrQkFBa0I7QUFDNUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9wcm90b2NvbC5qcz82YTE0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19hc3luY1ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX19hc3luY1ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm90b2NvbEhhbmRsZXIgPSBleHBvcnRzLlN1YnNjcmlwdGlvbnMgPSBleHBvcnRzLlN1YnNjcmlwdGlvbkltcGwgPSBleHBvcnRzLkNvbm5lY3QgPSBleHBvcnRzLklORk8gPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IDIwMTgtMjAyMyBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZW5jb2RlcnNfMSA9IHJlcXVpcmUoXCIuL2VuY29kZXJzXCIpO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgZGF0YWJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vZGF0YWJ1ZmZlclwiKTtcbmNvbnN0IHNlcnZlcnNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlcnNcIik7XG5jb25zdCBxdWV1ZWRfaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL3F1ZXVlZF9pdGVyYXRvclwiKTtcbmNvbnN0IG11eHN1YnNjcmlwdGlvbl8xID0gcmVxdWlyZShcIi4vbXV4c3Vic2NyaXB0aW9uXCIpO1xuY29uc3QgaGVhcnRiZWF0c18xID0gcmVxdWlyZShcIi4vaGVhcnRiZWF0c1wiKTtcbmNvbnN0IHBhcnNlcl8xID0gcmVxdWlyZShcIi4vcGFyc2VyXCIpO1xuY29uc3QgbXNnXzEgPSByZXF1aXJlKFwiLi9tc2dcIik7XG5jb25zdCBzZW12ZXJfMSA9IHJlcXVpcmUoXCIuL3NlbXZlclwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jb25zdCBvcHRpb25zXzEgPSByZXF1aXJlKFwiLi9vcHRpb25zXCIpO1xuY29uc3QgRkxVU0hfVEhSRVNIT0xEID0gMTAyNCAqIDMyO1xuZXhwb3J0cy5JTkZPID0gL15JTkZPXFxzKyhbXlxcclxcbl0rKVxcclxcbi9pO1xuY29uc3QgUE9OR19DTUQgPSAoMCwgZW5jb2RlcnNfMS5lbmNvZGUpKFwiUE9OR1xcclxcblwiKTtcbmNvbnN0IFBJTkdfQ01EID0gKDAsIGVuY29kZXJzXzEuZW5jb2RlKShcIlBJTkdcXHJcXG5cIik7XG5jbGFzcyBDb25uZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc3BvcnQsIG9wdHMsIG5vbmNlKSB7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSAxO1xuICAgICAgICB0aGlzLnZlcnNpb24gPSB0cmFuc3BvcnQudmVyc2lvbjtcbiAgICAgICAgdGhpcy5sYW5nID0gdHJhbnNwb3J0Lmxhbmc7XG4gICAgICAgIHRoaXMuZWNobyA9IG9wdHMubm9FY2hvID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudmVyYm9zZSA9IG9wdHMudmVyYm9zZTtcbiAgICAgICAgdGhpcy5wZWRhbnRpYyA9IG9wdHMucGVkYW50aWM7XG4gICAgICAgIHRoaXMudGxzX3JlcXVpcmVkID0gb3B0cy50bHMgPyB0cnVlIDogdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5hbWUgPSBvcHRzLm5hbWU7XG4gICAgICAgIGNvbnN0IGNyZWRzID0gKG9wdHMgJiYgdHlwZW9mIG9wdHMuYXV0aGVudGljYXRvciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IG9wdHMuYXV0aGVudGljYXRvcihub25jZSlcbiAgICAgICAgICAgIDoge30pIHx8IHt9O1xuICAgICAgICAoMCwgdXRpbF8xLmV4dGVuZCkodGhpcywgY3JlZHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29ubmVjdCA9IENvbm5lY3Q7XG5jbGFzcyBTdWJzY3JpcHRpb25JbXBsIGV4dGVuZHMgcXVldWVkX2l0ZXJhdG9yXzEuUXVldWVkSXRlcmF0b3JJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm90b2NvbCwgc3ViamVjdCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgKDAsIHV0aWxfMS5leHRlbmQpKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLnByb3RvY29sID0gcHJvdG9jb2w7XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuZHJhaW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub0l0ZXJhdG9yID0gdHlwZW9mIG9wdHMuY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgdGhpcy5jbG9zZWQgPSAoMCwgdXRpbF8xLmRlZmVycmVkKSgpO1xuICAgICAgICBjb25zdCBhc3luY1RyYWNlcyA9ICEoKChfYSA9IHByb3RvY29sLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ub0FzeW5jVHJhY2VzKSB8fCBmYWxzZSk7XG4gICAgICAgIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSAoMCwgdXRpbF8xLnRpbWVvdXQpKG9wdHMudGltZW91dCwgYXN5bmNUcmFjZXMpO1xuICAgICAgICAgICAgdGhpcy50aW1lclxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0aW1lciB3YXMgY2FuY2VsbGVkXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0aW1lciBmaXJlZFxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcChlcnIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vSXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhlcnIsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubm9JdGVyYXRvcikge1xuICAgICAgICAgICAgLy8gY2xlYW51cCAtIHRoZXkgdXNlZCBicmVhayBvciByZXR1cm4gZnJvbSB0aGUgaXRlcmF0b3JcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBjbGVhbiB1cCwgaWYgdGhleSBkaWRuJ3QgY2FsbCB1bnN1YlxuICAgICAgICAgICAgdGhpcy5pdGVyQ2xvc2VkLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQcmVQb3N0SGFuZGxlcnMob3B0cykge1xuICAgICAgICBpZiAodGhpcy5ub0l0ZXJhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCB1YyA9IHRoaXMuY2FsbGJhY2s7XG4gICAgICAgICAgICBjb25zdCBpbmdlc3Rpb24gPSBvcHRzLmluZ2VzdGlvbkZpbHRlckZuXG4gICAgICAgICAgICAgICAgPyBvcHRzLmluZ2VzdGlvbkZpbHRlckZuXG4gICAgICAgICAgICAgICAgOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGluZ2VzdDogdHJ1ZSwgcHJvdG9jb2w6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IG9wdHMucHJvdG9jb2xGaWx0ZXJGbiA/IG9wdHMucHJvdG9jb2xGaWx0ZXJGbiA6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBkaXNwYXRjaGVkID0gb3B0cy5kaXNwYXRjaGVkRm4gPyBvcHRzLmRpc3BhdGNoZWRGbiA6ICgpID0+IHsgfTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSAoZXJyLCBtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGluZ2VzdCB9ID0gaW5nZXN0aW9uKG1zZyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbmdlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyKG1zZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdWMoZXJyLCBtc2cpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVkKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2xGaWx0ZXJGbiA9IG9wdHMucHJvdG9jb2xGaWx0ZXJGbjtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlZEZuID0gb3B0cy5kaXNwYXRjaGVkRm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2soZXJyLCBtc2cpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgIGVyciA/IHRoaXMuc3RvcChlcnIpIDogdGhpcy5wdXNoKG1zZyk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zdCBmbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbGVhbnVwRm4pIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYW51cEZuKHRoaXMsIHRoaXMuaW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yaW5nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZWQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vSXRlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlOiBzY2hlZHVsZSB0aGUgY2xvc2Ugb25jZSBhbGwgbWVzc2FnZXMgYXJlIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIHRoaXMucHVzaChmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmUobWF4KSB7XG4gICAgICAgIHRoaXMucHJvdG9jb2wudW5zdWJzY3JpYmUodGhpcywgbWF4KTtcbiAgICB9XG4gICAgY2FuY2VsVGltZW91dCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbC5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoY29yZV8xLk5hdHNFcnJvci5lcnJvckZvckNvZGUoY29yZV8xLkVycm9yQ29kZS5Db25uZWN0aW9uQ2xvc2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvcmVfMS5OYXRzRXJyb3IuZXJyb3JGb3JDb2RlKGNvcmVfMS5FcnJvckNvZGUuU3ViQ2xvc2VkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRyYWluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhaW5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbC51bnN1Yih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZHJhaW5lZCA9IHRoaXMucHJvdG9jb2wuZmx1c2goKDAsIHV0aWxfMS5kZWZlcnJlZCkoKSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm90b2NvbC5zdWJzY3JpcHRpb25zLmNhbmNlbCh0aGlzKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RvY29sLnN1YnNjcmlwdGlvbnMuY2FuY2VsKHRoaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhaW5lZDtcbiAgICB9XG4gICAgaXNEcmFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhaW5pbmc7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb25lO1xuICAgIH1cbiAgICBnZXRTdWJqZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJqZWN0O1xuICAgIH1cbiAgICBnZXRNYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heDtcbiAgICB9XG4gICAgZ2V0SUQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZDtcbiAgICB9XG59XG5leHBvcnRzLlN1YnNjcmlwdGlvbkltcGwgPSBTdWJzY3JpcHRpb25JbXBsO1xuY2xhc3MgU3Vic2NyaXB0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2lkQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMubXV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzLnNpemU7XG4gICAgfVxuICAgIGFkZChzKSB7XG4gICAgICAgIHRoaXMuc2lkQ291bnRlcisrO1xuICAgICAgICBzLnNpZCA9IHRoaXMuc2lkQ291bnRlcjtcbiAgICAgICAgdGhpcy5zdWJzLnNldChzLnNpZCwgcyk7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBzZXRNdXgocykge1xuICAgICAgICB0aGlzLm11eCA9IHM7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBnZXRNdXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11eDtcbiAgICB9XG4gICAgZ2V0KHNpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzLmdldChzaWQpO1xuICAgIH1cbiAgICByZXN1YihzKSB7XG4gICAgICAgIHRoaXMuc2lkQ291bnRlcisrO1xuICAgICAgICB0aGlzLnN1YnMuZGVsZXRlKHMuc2lkKTtcbiAgICAgICAgcy5zaWQgPSB0aGlzLnNpZENvdW50ZXI7XG4gICAgICAgIHRoaXMuc3Vicy5zZXQocy5zaWQsIHMpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgYWxsKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnN1YnMudmFsdWVzKCkpO1xuICAgIH1cbiAgICBjYW5jZWwocykge1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgcy5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzLmRlbGV0ZShzLnNpZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmIChlcnIgJiYgZXJyLnBlcm1pc3Npb25Db250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBlcnIucGVybWlzc2lvbkNvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCBzdWJzID0gdGhpcy5hbGwoKTtcbiAgICAgICAgICAgIGxldCBzdWI7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wZXJhdGlvbiA9PT0gXCJzdWJzY3JpcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHN1YiA9IHN1YnMuZmluZCgocykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5zdWJqZWN0ID09PSBjdHguc3ViamVjdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdHgub3BlcmF0aW9uID09PSBcInB1Ymxpc2hcIikge1xuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgYSBubyBtdXggc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgc3ViID0gc3Vicy5maW5kKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcXVlc3RTdWJqZWN0ID09PSBjdHguc3ViamVjdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICBzdWIuY2FsbGJhY2soZXJyLCB7fSk7XG4gICAgICAgICAgICAgICAgc3ViLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzLmRlbGV0ZShzdWIuc2lkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViICE9PSB0aGlzLm11eDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnN1YnMuZm9yRWFjaCgoc3ViKSA9PiB7XG4gICAgICAgICAgICBzdWIuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TdWJzY3JpcHRpb25zID0gU3Vic2NyaXB0aW9ucztcbmNsYXNzIFByb3RvY29sSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgcHVibGlzaGVyKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZE9uY2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbmZvUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub01vcmVQdWJsaXNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWJvcnRSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTGltaXQgPSBGTFVTSF9USFJFU0hPTEQ7XG4gICAgICAgIHRoaXMub3V0TXNncyA9IDA7XG4gICAgICAgIHRoaXMuaW5Nc2dzID0gMDtcbiAgICAgICAgdGhpcy5vdXRCeXRlcyA9IDA7XG4gICAgICAgIHRoaXMuaW5CeXRlcyA9IDA7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucHVibGlzaGVyID0gcHVibGlzaGVyO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICB0aGlzLm11eFN1YnNjcmlwdGlvbnMgPSBuZXcgbXV4c3Vic2NyaXB0aW9uXzEuTXV4U3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMub3V0Ym91bmQgPSBuZXcgZGF0YWJ1ZmZlcl8xLkRhdGFCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5wb25ncyA9IFtdO1xuICAgICAgICB0aGlzLndoeUNsb3NlZCA9IFwiXCI7XG4gICAgICAgIC8vQHRzLWlnbm9yZTogb3B0aW9ucy5wZW5kaW5nTGltaXQgaXMgaGlkZGVuXG4gICAgICAgIHRoaXMucGVuZGluZ0xpbWl0ID0gb3B0aW9ucy5wZW5kaW5nTGltaXQgfHwgdGhpcy5wZW5kaW5nTGltaXQ7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBuZXcgc2VtdmVyXzEuRmVhdHVyZXMoeyBtYWpvcjogMCwgbWlub3I6IDAsIG1pY3JvOiAwIH0pO1xuICAgICAgICB0aGlzLmNvbm5lY3RQcm9taXNlID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc2VydmVycyA9IHR5cGVvZiBvcHRpb25zLnNlcnZlcnMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gW29wdGlvbnMuc2VydmVyc11cbiAgICAgICAgICAgIDogb3B0aW9ucy5zZXJ2ZXJzO1xuICAgICAgICB0aGlzLnNlcnZlcnMgPSBuZXcgc2VydmVyc18xLlNlcnZlcnMoc2VydmVycywge1xuICAgICAgICAgICAgcmFuZG9taXplOiAhb3B0aW9ucy5ub1JhbmRvbWl6ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2xvc2VkID0gKDAsIHV0aWxfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBuZXcgcGFyc2VyXzEuUGFyc2VyKHRoaXMpO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdHMgPSBuZXcgaGVhcnRiZWF0c18xLkhlYXJ0YmVhdCh0aGlzLCB0aGlzLm9wdGlvbnMucGluZ0ludGVydmFsIHx8IG9wdGlvbnNfMS5ERUZBVUxUX1BJTkdfSU5URVJWQUwsIHRoaXMub3B0aW9ucy5tYXhQaW5nT3V0IHx8IG9wdGlvbnNfMS5ERUZBVUxUX01BWF9QSU5HX09VVCk7XG4gICAgfVxuICAgIHJlc2V0T3V0Ym91bmQoKSB7XG4gICAgICAgIHRoaXMub3V0Ym91bmQucmVzZXQoKTtcbiAgICAgICAgY29uc3QgcG9uZ3MgPSB0aGlzLnBvbmdzO1xuICAgICAgICB0aGlzLnBvbmdzID0gW107XG4gICAgICAgIC8vIHJlamVjdCB0aGUgcG9uZ3MgLSB0aGUgZGlzY29ubmVjdCBmcm9tIGhlcmUgc2hvdWxkbid0IGhhdmUgYSB0cmFjZVxuICAgICAgICAvLyBiZWNhdXNlIHRoYXQgY29uZnVzZXMgQVBJIGNvbnN1bWVyc1xuICAgICAgICBjb25zdCBlcnIgPSBjb3JlXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLkRpc2Nvbm5lY3QpO1xuICAgICAgICBlcnIuc3RhY2sgPSBcIlwiO1xuICAgICAgICBwb25ncy5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBwLnJlamVjdChlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBuZXcgcGFyc2VyXzEuUGFyc2VyKHRoaXMpO1xuICAgICAgICB0aGlzLmluZm9SZWNlaXZlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBkaXNwYXRjaFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaCgocSkgPT4ge1xuICAgICAgICAgICAgcS5wdXNoKHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0dXMoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXIgPSBuZXcgcXVldWVkX2l0ZXJhdG9yXzEuUXVldWVkSXRlcmF0b3JJbXBsKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2goaXRlcik7XG4gICAgICAgIHJldHVybiBpdGVyO1xuICAgIH1cbiAgICBwcmVwYXJlKCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmRpc2NhcmQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZm8gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVzZXRPdXRib3VuZCgpO1xuICAgICAgICBjb25zdCBwb25nID0gKDAsIHV0aWxfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgcG9uZy5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBwcm92aWRlIGF0IGxlYXN0IG9uZSBjYXRjaCAtIGFzIHBvbmcgcmVqZWN0aW9uIGNhbiBoYXBwZW4gYmVmb3JlIGl0IGlzIGV4cGVjdGVkXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvbmdzLnVuc2hpZnQocG9uZyk7XG4gICAgICAgIHRoaXMuY29ubmVjdEVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgcG9uZy5yZWplY3QoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSAoMCwgdHJhbnNwb3J0XzEubmV3VHJhbnNwb3J0KSgpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZWQoKVxuICAgICAgICAgICAgLnRoZW4oKF9lcnIpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB0cmFuc3BvcnQgZ2F2ZSBhbiBlcnJvciB1c2UgdGhhdCwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgLy8gd2UgbWF5IGhhdmUgcmVjZWl2ZWQgYSBwcm90b2NvbCBlcnJvclxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdGVkKHRoaXMudHJhbnNwb3J0LmNsb3NlRXJyb3IgfHwgdGhpcy5sYXN0RXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gcG9uZztcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFN0YXR1cyh7IHR5cGU6IGNvcmVfMS5EZWJ1Z0V2ZW50cy5TdGFsZUNvbm5lY3Rpb24sIGRhdGE6IFwiXCIgfSk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgcmVjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoe1xuICAgICAgICAgICAgICAgIHR5cGU6IGNvcmVfMS5EZWJ1Z0V2ZW50cy5DbGllbnRJbml0aWF0ZWRSZWNvbm5lY3QsXG4gICAgICAgICAgICAgICAgZGF0YTogXCJcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdGVkKGVycikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgdHlwZTogY29yZV8xLkV2ZW50cy5EaXNjb25uZWN0LFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuc2VydmVycy5nZXRDdXJyZW50U2VydmVyKCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRpYWxMb29wKClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29yZV8xLkV2ZW50cy5SZWNvbm5lY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLnNlcnZlcnMuZ2V0Q3VycmVudFNlcnZlcigpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaGVyZSB3ZSByZWNvbm5lY3RlZCwgYnV0IHdlIGhhdmUgYW4gYXV0aGVudGljYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhhdCBleHBpcmVkLCB3ZSBuZWVkIHRvIGNsZWFuIGl0IHVwLCBvdGhlcndpc2Ugd2UnbGwgcXVldWUgdXBcbiAgICAgICAgICAgICAgICAgICAgLy8gdHdvIG9mIHRoZXNlLCBhbmQgdGhlIGRlZmF1bHQgZm9yIHRoZSBjbGllbnQgd2lsbCBiZSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBjbG9zZSwgcmF0aGVyIHRoYW4gYXR0ZW1wdCBhZ2FpbiAtIHBvc3NpYmx5IHRoZXkgaGF2ZSBhblxuICAgICAgICAgICAgICAgICAgICAvLyBhdXRoZW50aWNhdG9yIHRoYXQgZHluYW1pY2FsbHkgdXBkYXRlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMubGFzdEVycm9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgPT09IGNvcmVfMS5FcnJvckNvZGUuQXV0aGVudGljYXRpb25FeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9jbG9zZShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlhbChzcnYpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvbmcgPSB0aGlzLnByZXBhcmUoKTtcbiAgICAgICAgICAgIGxldCB0aW1lcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSAoMCwgdXRpbF8xLnRpbWVvdXQpKHRoaXMub3B0aW9ucy50aW1lb3V0IHx8IDIwMDAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjcCA9IHRoaXMudHJhbnNwb3J0LmNvbm5lY3Qoc3J2LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UucmFjZShbY3AsIHRpbWVyXSk7XG4gICAgICAgICAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IF9fYXN5bmNWYWx1ZXModGhpcy50cmFuc3BvcnQpLCBfZjsgX2YgPSB5aWVsZCBfZS5uZXh0KCksIF9hID0gX2YuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBfZi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlci5wYXJzZShiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlYWRlciBjbG9zZWRcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKSgpLnRoZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBwb25nLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLnJhY2UoW3RpbWVyLCBwb25nXSk7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpbWVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0RXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGVkT25jZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuZGlkQ29ubmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXIucmVjb25uZWN0cyA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaFBlbmRpbmcoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdHMuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGltZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMudHJhbnNwb3J0LmNsb3NlKGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2RvRGlhbChzcnYpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsdHMgPSB5aWVsZCBzcnYucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgZm46ICgwLCB0cmFuc3BvcnRfMS5nZXRSZXNvbHZlRm4pKCksXG4gICAgICAgICAgICAgICAgZGVidWc6IHRoaXMub3B0aW9ucy5kZWJ1ZyxcbiAgICAgICAgICAgICAgICByYW5kb21pemU6ICF0aGlzLm9wdGlvbnMubm9SYW5kb21pemUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBsYXN0RXJyID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYSBvZiBhbHRzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVyciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoeyB0eXBlOiBjb3JlXzEuRGVidWdFdmVudHMuUmVjb25uZWN0aW5nLCBkYXRhOiBhLnRvU3RyaW5nKCkgfSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGlhbChhKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaGVyZSB3ZSBjb25uZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RFcnIgPSBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIGhlcmUsIHdlIGZhaWxlZCwgYW5kIHdlIGhhdmUgbm8gYWRkaXRpb25hbFxuICAgICAgICAgICAgLy8gYWx0ZXJuYXRpdmVzIGZvciB0aGlzIHNlcnZlclxuICAgICAgICAgICAgdGhyb3cgbGFzdEVycjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpYWxMb29wKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0UHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0UHJvbWlzZSA9IHRoaXMuZG9kaWFsTG9vcCgpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0UHJvbWlzZVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHsgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4geyB9KVxuICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RQcm9taXNlO1xuICAgIH1cbiAgICBkb2RpYWxMb29wKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGxhc3RFcnJvcjtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgZGlzY29ubmVjdGVkLCBhbmQgY2xvc2UgaXMgY2FsbGVkLCB0aGUgY2xpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0aWxsIHRyaWVzIHRvIHJlY29ubmVjdCAtIHRvIG1hdGNoIHRoZSByZWNvbm5lY3QgcG9saWN5XG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBjYXNlIG9mIGNsb3NlLCB3YW50IHRvIHN0b3AuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVycy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3YWl0ID0gdGhpcy5vcHRpb25zLnJlY29ubmVjdERlbGF5SGFuZGxlclxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMub3B0aW9ucy5yZWNvbm5lY3REZWxheUhhbmRsZXIoKVxuICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbnNfMS5ERUZBVUxUX1JFQ09OTkVDVF9USU1FX1dBSVQ7XG4gICAgICAgICAgICAgICAgbGV0IG1heFdhaXQgPSB3YWl0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHNydiA9IHRoaXMuc2VsZWN0U2VydmVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzcnYgfHwgdGhpcy5hYm9ydFJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMubGFzdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgY29yZV8xLk5hdHNFcnJvci5lcnJvckZvckNvZGUoY29yZV8xLkVycm9yQ29kZS5Db25uZWN0aW9uUmVmdXNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBpZiAoc3J2Lmxhc3RDb25uZWN0ID09PSAwIHx8IHNydi5sYXN0Q29ubmVjdCArIHdhaXQgPD0gbm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHNydi5sYXN0Q29ubmVjdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9kb0RpYWwoc3J2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRPbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy53YWl0T25GaXJzdENvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmVycy5yZW1vdmVDdXJyZW50U2VydmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzcnYucmVjb25uZWN0cysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbXJhID0gdGhpcy5vcHRpb25zLm1heFJlY29ubmVjdEF0dGVtcHRzIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobXJhICE9PSAtMSAmJiBzcnYucmVjb25uZWN0cyA+PSBtcmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlcnMucmVtb3ZlQ3VycmVudFNlcnZlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXhXYWl0ID0gTWF0aC5taW4obWF4V2FpdCwgc3J2Lmxhc3RDb25uZWN0ICsgd2FpdCAtIG5vdyk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkICgwLCB1dGlsXzEuZGVsYXkpKG1heFdhaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBjb25uZWN0KG9wdGlvbnMsIHB1Ymxpc2hlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaCA9IG5ldyBQcm90b2NvbEhhbmRsZXIob3B0aW9ucywgcHVibGlzaGVyKTtcbiAgICAgICAgICAgIHlpZWxkIGguZGlhbExvb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIHRvRXJyb3Iocykge1xuICAgICAgICBjb25zdCB0ID0gcyA/IHMudG9Mb3dlckNhc2UoKSA6IFwiXCI7XG4gICAgICAgIGlmICh0LmluZGV4T2YoXCJwZXJtaXNzaW9ucyB2aW9sYXRpb25cIikgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgY29yZV8xLk5hdHNFcnJvcihzLCBjb3JlXzEuRXJyb3JDb2RlLlBlcm1pc3Npb25zVmlvbGF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBzLm1hdGNoKC8oUHVibGlzaHxTdWJzY3JpcHRpb24pIHRvIFwiKFxcUyspXCIvKTtcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgZXJyLnBlcm1pc3Npb25Db250ZXh0ID0ge1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IG1bMV0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgc3ViamVjdDogbVsyXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0LmluZGV4T2YoXCJhdXRob3JpemF0aW9uIHZpb2xhdGlvblwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY29yZV8xLk5hdHNFcnJvcihzLCBjb3JlXzEuRXJyb3JDb2RlLkF1dGhvcml6YXRpb25WaW9sYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHQuaW5kZXhPZihcInVzZXIgYXV0aGVudGljYXRpb24gZXhwaXJlZFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY29yZV8xLk5hdHNFcnJvcihzLCBjb3JlXzEuRXJyb3JDb2RlLkF1dGhlbnRpY2F0aW9uRXhwaXJlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodC5pbmRleE9mKFwiYXV0aGVudGljYXRpb24gdGltZW91dFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgY29yZV8xLk5hdHNFcnJvcihzLCBjb3JlXzEuRXJyb3JDb2RlLkF1dGhlbnRpY2F0aW9uVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IGNvcmVfMS5OYXRzRXJyb3IocywgY29yZV8xLkVycm9yQ29kZS5Qcm90b2NvbEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzTXNnKG1zZywgZGF0YSkge1xuICAgICAgICB0aGlzLmluTXNncysrO1xuICAgICAgICB0aGlzLmluQnl0ZXMgKz0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb25zLnNpZENvdW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWIgPSB0aGlzLnN1YnNjcmlwdGlvbnMuZ2V0KG1zZy5zaWQpO1xuICAgICAgICBpZiAoIXN1Yikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1Yi5yZWNlaXZlZCArPSAxO1xuICAgICAgICBpZiAoc3ViLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICBzdWIuY2FsbGJhY2sobnVsbCwgbmV3IG1zZ18xLk1zZ0ltcGwobXNnLCBkYXRhLCB0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Yi5tYXggIT09IHVuZGVmaW5lZCAmJiBzdWIucmVjZWl2ZWQgPj0gc3ViLm1heCkge1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc0Vycm9yKG0pIHtcbiAgICAgICAgY29uc3QgcyA9ICgwLCBlbmNvZGVyc18xLmRlY29kZSkobSk7XG4gICAgICAgIGNvbnN0IGVyciA9IFByb3RvY29sSGFuZGxlci50b0Vycm9yKHMpO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7IHR5cGU6IGNvcmVfMS5FdmVudHMuRXJyb3IsIGRhdGE6IGVyci5jb2RlIH07XG4gICAgICAgIGlmIChlcnIuaXNQZXJtaXNzaW9uRXJyb3IoKSkge1xuICAgICAgICAgICAgbGV0IGlzTXV4UGVybWlzc2lvbkVycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXJyLnBlcm1pc3Npb25Db250ZXh0KSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLnBlcm1pc3Npb25Db250ZXh0ID0gZXJyLnBlcm1pc3Npb25Db250ZXh0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG11eCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXRNdXgoKTtcbiAgICAgICAgICAgICAgICBpc011eFBlcm1pc3Npb25FcnJvciA9IChtdXggPT09IG51bGwgfHwgbXV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtdXguc3ViamVjdCkgPT09IGVyci5wZXJtaXNzaW9uQ29udGV4dC5zdWJqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLm11eFN1YnNjcmlwdGlvbnMuaGFuZGxlRXJyb3IoaXNNdXhQZXJtaXNzaW9uRXJyb3IsIGVycik7XG4gICAgICAgICAgICBpZiAoaXNNdXhQZXJtaXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIHBlcm1pc3Npb24gLSBlbmFibGUgaXQgdG8gYmUgcmVjcmVhdGVkXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldE11eChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoU3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyKTtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmIChlcnIuaXNBdXRoRXJyb3IoKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRoRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnIuaXNQcm90b2NvbEVycm9yKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVyci5pc0F1dGhUaW1lb3V0KCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZhbGx0aHJvdWdoIGhlcmVcbiAgICAgICAgaWYgKCFlcnIuaXNQZXJtaXNzaW9uRXJyb3IoKSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQXV0aEVycm9yKGVycikge1xuICAgICAgICBpZiAoKHRoaXMubGFzdEVycm9yICYmIGVyci5jb2RlID09PSB0aGlzLmxhc3RFcnJvci5jb2RlKSAmJlxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmlnbm9yZUF1dGhFcnJvckFib3J0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5hYm9ydFJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1BpbmcoKSB7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQoUE9OR19DTUQpO1xuICAgIH1cbiAgICBwcm9jZXNzUG9uZygpIHtcbiAgICAgICAgY29uc3QgY2IgPSB0aGlzLnBvbmdzLnNoaWZ0KCk7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgY2IucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NJbmZvKG0pIHtcbiAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UoKDAsIGVuY29kZXJzXzEuZGVjb2RlKShtKSk7XG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgICAgIGNvbnN0IHVwZGF0ZXMgPSB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLmlnbm9yZUNsdXN0ZXJVcGRhdGVzXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB0aGlzLnNlcnZlcnMudXBkYXRlKGluZm8sIHRoaXMudHJhbnNwb3J0LmlzRW5jcnlwdGVkKCkpO1xuICAgICAgICBpZiAoIXRoaXMuaW5mb1JlY2VpdmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzLnVwZGF0ZSgoMCwgc2VtdmVyXzEucGFyc2VTZW1WZXIpKGluZm8udmVyc2lvbikpO1xuICAgICAgICAgICAgdGhpcy5pbmZvUmVjZWl2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0LmlzRW5jcnlwdGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlcnZlcnMudXBkYXRlVExTTmFtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc2VuZCBjb25uZWN0XG4gICAgICAgICAgICBjb25zdCB7IHZlcnNpb24sIGxhbmcgfSA9IHRoaXMudHJhbnNwb3J0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gbmV3IENvbm5lY3QoeyB2ZXJzaW9uLCBsYW5nIH0sIHRoaXMub3B0aW9ucywgaW5mby5ub25jZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZm8uaGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjLmhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjLm5vX3Jlc3BvbmRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IEpTT04uc3RyaW5naWZ5KGMpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQoKDAsIGVuY29kZXJzXzEuZW5jb2RlKShgQ09OTkVDVCAke2NzfSR7dHJhbnNwb3J0XzEuQ1JfTEZ9YCkpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQoUElOR19DTUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBkeWluZyBoZXJlLCB0aGlzIGlzIGxpa2VseSBzb21lIGFuIGF1dGhlbnRpY2F0b3IgYmxvd2luZyB1cFxuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hTdGF0dXMoeyB0eXBlOiBjb3JlXzEuRXZlbnRzLlVwZGF0ZSwgZGF0YTogdXBkYXRlcyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZG0gPSBpbmZvLmxkbSAhPT0gdW5kZWZpbmVkID8gaW5mby5sZG0gOiBmYWxzZTtcbiAgICAgICAgaWYgKGxkbSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgdHlwZTogY29yZV8xLkV2ZW50cy5MRE0sXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5zZXJ2ZXJzLmdldEN1cnJlbnRTZXJ2ZXIoKS50b1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVzaChlKSB7XG4gICAgICAgIHN3aXRjaCAoZS5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIHBhcnNlcl8xLktpbmQuTVNHOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtc2csIGRhdGEgfSA9IGU7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTXNnKG1zZywgZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIHBhcnNlcl8xLktpbmQuT0s6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBhcnNlcl8xLktpbmQuRVJSOlxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0Vycm9yKGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBhcnNlcl8xLktpbmQuUElORzpcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQaW5nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBhcnNlcl8xLktpbmQuUE9ORzpcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQb25nKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBhcnNlcl8xLktpbmQuSU5GTzpcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NJbmZvKGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZENvbW1hbmQoY21kLCAuLi5wYXlsb2Fkcykge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dGJvdW5kLmxlbmd0aCgpO1xuICAgICAgICBsZXQgYnVmO1xuICAgICAgICBpZiAodHlwZW9mIGNtZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYnVmID0gKDAsIGVuY29kZXJzXzEuZW5jb2RlKShjbWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmID0gY21kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0Ym91bmQuZmlsbChidWYsIC4uLnBheWxvYWRzKTtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm91dGJvdW5kLnNpemUoKSA+PSB0aGlzLnBlbmRpbmdMaW1pdCkge1xuICAgICAgICAgICAgLy8gZmx1c2ggaW5saW5lXG4gICAgICAgICAgICB0aGlzLmZsdXNoUGVuZGluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1Ymxpc2goc3ViamVjdCwgcGF5bG9hZCA9IGVuY29kZXJzXzEuRW1wdHksIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGlmIChwYXlsb2FkIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgZGF0YSA9IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBheWxvYWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRhdGEgPSBlbmNvZGVyc18xLlRFLmVuY29kZShwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGNvcmVfMS5OYXRzRXJyb3IuZXJyb3JGb3JDb2RlKGNvcmVfMS5FcnJvckNvZGUuQmFkUGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5yZXBseSA9IG9wdGlvbnMucmVwbHkgfHwgXCJcIjtcbiAgICAgICAgbGV0IGhlYWRlcnMgPSBlbmNvZGVyc18xLkVtcHR5O1xuICAgICAgICBsZXQgaGxlbiA9IDA7XG4gICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZm8gJiYgIXRoaXMuaW5mby5oZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfMS5OYXRzRXJyb3IoXCJoZWFkZXJzXCIsIGNvcmVfMS5FcnJvckNvZGUuU2VydmVyT3B0aW9uTm90QXZhaWxhYmxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhkcnMgPSBvcHRpb25zLmhlYWRlcnM7XG4gICAgICAgICAgICBoZWFkZXJzID0gaGRycy5lbmNvZGUoKTtcbiAgICAgICAgICAgIGhsZW4gPSBoZWFkZXJzLmxlbmd0aDtcbiAgICAgICAgICAgIGxlbiA9IGRhdGEubGVuZ3RoICsgaGxlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmZvICYmIGxlbiA+IHRoaXMuaW5mby5tYXhfcGF5bG9hZCkge1xuICAgICAgICAgICAgdGhyb3cgY29yZV8xLk5hdHNFcnJvci5lcnJvckZvckNvZGUoY29yZV8xLkVycm9yQ29kZS5NYXhQYXlsb2FkRXhjZWVkZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0Qnl0ZXMgKz0gbGVuO1xuICAgICAgICB0aGlzLm91dE1zZ3MrKztcbiAgICAgICAgbGV0IHByb3RvO1xuICAgICAgICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXBseSkge1xuICAgICAgICAgICAgICAgIHByb3RvID0gYEhQVUIgJHtzdWJqZWN0fSAke29wdGlvbnMucmVwbHl9ICR7aGxlbn0gJHtsZW59XFxyXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3RvID0gYEhQVUIgJHtzdWJqZWN0fSAke2hsZW59ICR7bGVufVxcclxcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKHByb3RvLCBoZWFkZXJzLCBkYXRhLCB0cmFuc3BvcnRfMS5DUkxGKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlcGx5KSB7XG4gICAgICAgICAgICAgICAgcHJvdG8gPSBgUFVCICR7c3ViamVjdH0gJHtvcHRpb25zLnJlcGx5fSAke2xlbn1cXHJcXG5gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvdG8gPSBgUFVCICR7c3ViamVjdH0gJHtsZW59XFxyXFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQocHJvdG8sIGRhdGEsIHRyYW5zcG9ydF8xLkNSTEYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qocikge1xuICAgICAgICB0aGlzLmluaXRNdXgoKTtcbiAgICAgICAgdGhpcy5tdXhTdWJzY3JpcHRpb25zLmFkZChyKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIHN1YnNjcmliZShzKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQocyk7XG4gICAgICAgIHRoaXMuX3N1YnVuc3ViKHMpO1xuICAgICAgICByZXR1cm4gcztcbiAgICB9XG4gICAgX3N1YihzKSB7XG4gICAgICAgIGlmIChzLnF1ZXVlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKGBTVUIgJHtzLnN1YmplY3R9ICR7cy5xdWV1ZX0gJHtzLnNpZH1cXHJcXG5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoYFNVQiAke3Muc3ViamVjdH0gJHtzLnNpZH1cXHJcXG5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3VidW5zdWIocykge1xuICAgICAgICB0aGlzLl9zdWIocyk7XG4gICAgICAgIGlmIChzLm1heCkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZShzLCBzLm1heCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlKHMsIG1heCkge1xuICAgICAgICB0aGlzLnVuc3ViKHMsIG1heCk7XG4gICAgICAgIGlmIChzLm1heCA9PT0gdW5kZWZpbmVkIHx8IHMucmVjZWl2ZWQgPj0gcy5tYXgpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5jYW5jZWwocyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWIocywgbWF4KSB7XG4gICAgICAgIGlmICghcyB8fCB0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF4KSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKGBVTlNVQiAke3Muc2lkfSAke21heH1cXHJcXG5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoYFVOU1VCICR7cy5zaWR9XFxyXFxuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5tYXggPSBtYXg7XG4gICAgfVxuICAgIHJlc3ViKHMsIHN1YmplY3QpIHtcbiAgICAgICAgaWYgKCFzIHx8IHRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHMuc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5yZXN1YihzKTtcbiAgICAgICAgLy8gd2UgZG9uJ3QgYXV0by11bnN1YiBoZXJlIGJlY2F1c2Ugd2UgZG9uJ3RcbiAgICAgICAgLy8gcmVhbGx5IGtub3cgXCJwcm9jZXNzZWRcIlxuICAgICAgICB0aGlzLl9zdWIocyk7XG4gICAgfVxuICAgIGZsdXNoKHApIHtcbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICBwID0gKDAsIHV0aWxfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvbmdzLnB1c2gocCk7XG4gICAgICAgIHRoaXMub3V0Ym91bmQuZmlsbChQSU5HX0NNRCk7XG4gICAgICAgIHRoaXMuZmx1c2hQZW5kaW5nKCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBzZW5kU3Vic2NyaXB0aW9ucygpIHtcbiAgICAgICAgY29uc3QgY21kcyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWxsKCkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3ViID0gcztcbiAgICAgICAgICAgIGlmIChzdWIucXVldWUpIHtcbiAgICAgICAgICAgICAgICBjbWRzLnB1c2goYFNVQiAke3N1Yi5zdWJqZWN0fSAke3N1Yi5xdWV1ZX0gJHtzdWIuc2lkfSR7dHJhbnNwb3J0XzEuQ1JfTEZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbWRzLnB1c2goYFNVQiAke3N1Yi5zdWJqZWN0fSAke3N1Yi5zaWR9JHt0cmFuc3BvcnRfMS5DUl9MRn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjbWRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZCgoMCwgZW5jb2RlcnNfMS5lbmNvZGUpKGNtZHMuam9pbihcIlwiKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jbG9zZShlcnIpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndoeUNsb3NlZCA9IG5ldyBFcnJvcihcImNsb3NlIHRyYWNlXCIpLnN0YWNrIHx8IFwiXCI7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdHMuY2FuY2VsKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tdXhTdWJzY3JpcHRpb25zLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2goKGwpID0+IHtcbiAgICAgICAgICAgICAgICBsLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMudHJhbnNwb3J0LmNsb3NlKGVycik7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNsb3NlZC5yZXNvbHZlKGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlKCk7XG4gICAgfVxuICAgIGlzQ2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH1cbiAgICBkcmFpbigpIHtcbiAgICAgICAgY29uc3Qgc3VicyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5hbGwoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goc3ViLmRyYWluKCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5ub01vcmVQdWJsaXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGNhbm5vdCBoYXBwZW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZsdXNoUGVuZGluZygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluZm9SZWNlaXZlZCB8fCAhdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRib3VuZC5zaXplKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLm91dGJvdW5kLmRyYWluKCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRNdXgoKSB7XG4gICAgICAgIGNvbnN0IG11eCA9IHRoaXMuc3Vic2NyaXB0aW9ucy5nZXRNdXgoKTtcbiAgICAgICAgaWYgKCFtdXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluYm94ID0gdGhpcy5tdXhTdWJzY3JpcHRpb25zLmluaXQodGhpcy5vcHRpb25zLmluYm94UHJlZml4KTtcbiAgICAgICAgICAgIC8vIGRvdCBpcyBhbHJlYWR5IHBhcnQgb2YgbXV4XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBuZXcgU3Vic2NyaXB0aW9uSW1wbCh0aGlzLCBgJHtpbmJveH0qYCk7XG4gICAgICAgICAgICBzdWIuY2FsbGJhY2sgPSB0aGlzLm11eFN1YnNjcmlwdGlvbnMuZGlzcGF0Y2hlcigpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnNldE11eChzdWIpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoc3ViKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RTZXJ2ZXIoKSB7XG4gICAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuc2VydmVycy5zZWxlY3RTZXJ2ZXIoKTtcbiAgICAgICAgaWYgKHNlcnZlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBsYWNlIGluIGNsaWVudCBjb250ZXh0LlxuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVyO1xuICAgIH1cbiAgICBnZXRTZXJ2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlcjtcbiAgICB9XG59XG5leHBvcnRzLlByb3RvY29sSGFuZGxlciA9IFByb3RvY29sSGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3RvY29sLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/protocol.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/queued_iterator.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueuedIteratorImpl = void 0;\n/*\n * Copyright 2020-2022 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nclass QueuedIteratorImpl {\n    constructor() {\n        this.inflight = 0;\n        this.filtered = 0;\n        this.pendingFiltered = 0;\n        this.processed = 0;\n        this.received = 0;\n        this.noIterator = false;\n        this.done = false;\n        this.signal = (0, util_1.deferred)();\n        this.yields = [];\n        this.iterClosed = (0, util_1.deferred)();\n        this.time = 0;\n        this.yielding = false;\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    push(v) {\n        if (this.done) {\n            return;\n        }\n        if (typeof v === \"function\") {\n            this.yields.push(v);\n            this.signal.resolve();\n            return;\n        }\n        const { ingest, protocol } = this.ingestionFilterFn\n            ? this.ingestionFilterFn(v, this.ctx || this)\n            : { ingest: true, protocol: false };\n        if (ingest) {\n            if (protocol) {\n                this.filtered++;\n                this.pendingFiltered++;\n            }\n            this.yields.push(v);\n            this.signal.resolve();\n        }\n    }\n    iterate() {\n        return __asyncGenerator(this, arguments, function* iterate_1() {\n            if (this.noIterator) {\n                throw new core_1.NatsError(\"unsupported iterator\", core_1.ErrorCode.ApiError);\n            }\n            if (this.yielding) {\n                throw new core_1.NatsError(\"already yielding\", core_1.ErrorCode.ApiError);\n            }\n            this.yielding = true;\n            try {\n                while (true) {\n                    if (this.yields.length === 0) {\n                        yield __await(this.signal);\n                    }\n                    if (this.err) {\n                        throw this.err;\n                    }\n                    const yields = this.yields;\n                    this.inflight = yields.length;\n                    this.yields = [];\n                    for (let i = 0; i < yields.length; i++) {\n                        if (typeof yields[i] === \"function\") {\n                            const fn = yields[i];\n                            try {\n                                fn();\n                            }\n                            catch (err) {\n                                // failed on the invocation - fail the iterator\n                                // so they know to fix the callback\n                                throw err;\n                            }\n                            // fn could have also set an error\n                            if (this.err) {\n                                throw this.err;\n                            }\n                            continue;\n                        }\n                        // only pass messages that pass the filter\n                        const ok = this.protocolFilterFn\n                            ? this.protocolFilterFn(yields[i])\n                            : true;\n                        if (ok) {\n                            this.processed++;\n                            const start = Date.now();\n                            yield yield __await(yields[i]);\n                            this.time = Date.now() - start;\n                            if (this.dispatchedFn && yields[i]) {\n                                this.dispatchedFn(yields[i]);\n                            }\n                        }\n                        else {\n                            this.pendingFiltered--;\n                        }\n                        this.inflight--;\n                    }\n                    // yielding could have paused and microtask\n                    // could have added messages. Prevent allocations\n                    // if possible\n                    if (this.done) {\n                        break;\n                    }\n                    else if (this.yields.length === 0) {\n                        yields.length = 0;\n                        this.yields = yields;\n                        this.signal = (0, util_1.deferred)();\n                    }\n                }\n            }\n            finally {\n                // the iterator used break/return\n                this.stop();\n            }\n        });\n    }\n    stop(err) {\n        if (this.done) {\n            return;\n        }\n        this.err = err;\n        this.done = true;\n        this.signal.resolve();\n        this.iterClosed.resolve();\n    }\n    getProcessed() {\n        return this.noIterator ? this.received : this.processed;\n    }\n    getPending() {\n        return this.yields.length + this.inflight - this.pendingFiltered;\n    }\n    getReceived() {\n        return this.received - this.filtered;\n    }\n}\nexports.QueuedIteratorImpl = QueuedIteratorImpl;\n//# sourceMappingURL=queued_iterator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9xdWV1ZWRfaXRlcmF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYix1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9HQUFvRyxjQUFjO0FBQ25JLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsc0VBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L3F1ZXVlZF9pdGVyYXRvci5qcz9mZDcwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXQgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpOyB9XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXVldWVkSXRlcmF0b3JJbXBsID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCAyMDIwLTIwMjIgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY2xhc3MgUXVldWVkSXRlcmF0b3JJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pbmZsaWdodCA9IDA7XG4gICAgICAgIHRoaXMuZmlsdGVyZWQgPSAwO1xuICAgICAgICB0aGlzLnBlbmRpbmdGaWx0ZXJlZCA9IDA7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gMDtcbiAgICAgICAgdGhpcy5yZWNlaXZlZCA9IDA7XG4gICAgICAgIHRoaXMubm9JdGVyYXRvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaWduYWwgPSAoMCwgdXRpbF8xLmRlZmVycmVkKSgpO1xuICAgICAgICB0aGlzLnlpZWxkcyA9IFtdO1xuICAgICAgICB0aGlzLml0ZXJDbG9zZWQgPSAoMCwgdXRpbF8xLmRlZmVycmVkKSgpO1xuICAgICAgICB0aGlzLnRpbWUgPSAwO1xuICAgICAgICB0aGlzLnlpZWxkaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdGUoKTtcbiAgICB9XG4gICAgcHVzaCh2KSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy55aWVsZHMucHVzaCh2KTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlc29sdmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGluZ2VzdCwgcHJvdG9jb2wgfSA9IHRoaXMuaW5nZXN0aW9uRmlsdGVyRm5cbiAgICAgICAgICAgID8gdGhpcy5pbmdlc3Rpb25GaWx0ZXJGbih2LCB0aGlzLmN0eCB8fCB0aGlzKVxuICAgICAgICAgICAgOiB7IGluZ2VzdDogdHJ1ZSwgcHJvdG9jb2w6IGZhbHNlIH07XG4gICAgICAgIGlmIChpbmdlc3QpIHtcbiAgICAgICAgICAgIGlmIChwcm90b2NvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyZWQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdGaWx0ZXJlZCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy55aWVsZHMucHVzaCh2KTtcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpdGVyYXRlKCkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBpdGVyYXRlXzEoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ub0l0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfMS5OYXRzRXJyb3IoXCJ1bnN1cHBvcnRlZCBpdGVyYXRvclwiLCBjb3JlXzEuRXJyb3JDb2RlLkFwaUVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnlpZWxkaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmVfMS5OYXRzRXJyb3IoXCJhbHJlYWR5IHlpZWxkaW5nXCIsIGNvcmVfMS5FcnJvckNvZGUuQXBpRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy55aWVsZGluZyA9IHRydWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnlpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIF9fYXdhaXQodGhpcy5zaWduYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5lcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeWllbGRzID0gdGhpcy55aWVsZHM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mbGlnaHQgPSB5aWVsZHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnlpZWxkcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHlpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB5aWVsZHNbaV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZuID0geWllbGRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIG9uIHRoZSBpbnZvY2F0aW9uIC0gZmFpbCB0aGUgaXRlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhleSBrbm93IHRvIGZpeCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmbiBjb3VsZCBoYXZlIGFsc28gc2V0IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgcGFzcyBtZXNzYWdlcyB0aGF0IHBhc3MgdGhlIGZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2sgPSB0aGlzLnByb3RvY29sRmlsdGVyRm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMucHJvdG9jb2xGaWx0ZXJGbih5aWVsZHNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh5aWVsZHNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGltZSA9IERhdGUubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXNwYXRjaGVkRm4gJiYgeWllbGRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hlZEZuKHlpZWxkc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nRmlsdGVyZWQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5mbGlnaHQtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB5aWVsZGluZyBjb3VsZCBoYXZlIHBhdXNlZCBhbmQgbWljcm90YXNrXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvdWxkIGhhdmUgYWRkZWQgbWVzc2FnZXMuIFByZXZlbnQgYWxsb2NhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy55aWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWllbGRzID0geWllbGRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduYWwgPSAoMCwgdXRpbF8xLmRlZmVycmVkKSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gdGhlIGl0ZXJhdG9yIHVzZWQgYnJlYWsvcmV0dXJuXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9wKGVycikge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lcnIgPSBlcnI7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2lnbmFsLnJlc29sdmUoKTtcbiAgICAgICAgdGhpcy5pdGVyQ2xvc2VkLnJlc29sdmUoKTtcbiAgICB9XG4gICAgZ2V0UHJvY2Vzc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub0l0ZXJhdG9yID8gdGhpcy5yZWNlaXZlZCA6IHRoaXMucHJvY2Vzc2VkO1xuICAgIH1cbiAgICBnZXRQZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZHMubGVuZ3RoICsgdGhpcy5pbmZsaWdodCAtIHRoaXMucGVuZGluZ0ZpbHRlcmVkO1xuICAgIH1cbiAgICBnZXRSZWNlaXZlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZWQgLSB0aGlzLmZpbHRlcmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuUXVldWVkSXRlcmF0b3JJbXBsID0gUXVldWVkSXRlcmF0b3JJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVldWVkX2l0ZXJhdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/request.js":
/*!***********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/request.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RequestOne = exports.RequestMany = exports.BaseRequest = void 0;\n/*\n * Copyright 2020-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst nuid_1 = __webpack_require__(/*! ./nuid */ \"(rsc)/./node_modules/nats/lib/nats-base-client/nuid.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nclass BaseRequest {\n    constructor(mux, requestSubject, asyncTraces = true) {\n        this.mux = mux;\n        this.requestSubject = requestSubject;\n        this.received = 0;\n        this.token = nuid_1.nuid.next();\n        if (asyncTraces) {\n            this.ctx = new Error();\n        }\n    }\n}\nexports.BaseRequest = BaseRequest;\n/**\n * Request expects multiple message response\n * the request ends when the timer expires,\n * an error arrives or an expected count of messages\n * arrives, end is signaled by a null message\n */\nclass RequestMany extends BaseRequest {\n    constructor(mux, requestSubject, opts = { maxWait: 1000 }) {\n        super(mux, requestSubject);\n        this.opts = opts;\n        if (typeof this.opts.callback !== \"function\") {\n            throw new Error(\"callback is required\");\n        }\n        this.callback = this.opts.callback;\n        this.max = typeof opts.maxMessages === \"number\" && opts.maxMessages > 0\n            ? opts.maxMessages\n            : -1;\n        this.done = (0, util_1.deferred)();\n        this.done.then(() => {\n            this.callback(null, null);\n        });\n        // @ts-ignore: node is not a number\n        this.timer = setTimeout(() => {\n            this.cancel();\n        }, opts.maxWait);\n    }\n    cancel(err) {\n        if (err) {\n            this.callback(err, null);\n        }\n        clearTimeout(this.timer);\n        this.mux.cancel(this);\n        this.done.resolve();\n    }\n    resolver(err, msg) {\n        if (err) {\n            if (this.ctx) {\n                err.stack += `\\n\\n${this.ctx.stack}`;\n            }\n            this.cancel(err);\n        }\n        else {\n            this.callback(null, msg);\n            if (this.opts.strategy === core_1.RequestStrategy.Count) {\n                this.max--;\n                if (this.max === 0) {\n                    this.cancel();\n                }\n            }\n            if (this.opts.strategy === core_1.RequestStrategy.JitterTimer) {\n                clearTimeout(this.timer);\n                // @ts-ignore: node is not a number\n                this.timer = setTimeout(() => {\n                    this.cancel();\n                }, this.opts.jitter || 300);\n            }\n            if (this.opts.strategy === core_1.RequestStrategy.SentinelMsg) {\n                if (msg && msg.data.length === 0) {\n                    this.cancel();\n                }\n            }\n        }\n    }\n}\nexports.RequestMany = RequestMany;\nclass RequestOne extends BaseRequest {\n    constructor(mux, requestSubject, opts = { timeout: 1000 }, asyncTraces = true) {\n        super(mux, requestSubject, asyncTraces);\n        // extend(this, opts);\n        this.deferred = (0, util_1.deferred)();\n        this.timer = (0, util_1.timeout)(opts.timeout, asyncTraces);\n    }\n    resolver(err, msg) {\n        if (this.timer) {\n            this.timer.cancel();\n        }\n        if (err) {\n            if (this.ctx) {\n                err.stack += `\\n\\n${this.ctx.stack}`;\n            }\n            this.deferred.reject(err);\n        }\n        else {\n            this.deferred.resolve(msg);\n        }\n        this.cancel();\n    }\n    cancel(err) {\n        if (this.timer) {\n            this.timer.cancel();\n        }\n        this.mux.cancel(this);\n        this.deferred.reject(err ? err : core_1.NatsError.errorForCode(core_1.ErrorCode.Cancelled));\n    }\n}\nexports.RequestOne = RequestOne;\n//# sourceMappingURL=request.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9yZXF1ZXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLG1CQUFtQixHQUFHLG1CQUFtQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxzRUFBUTtBQUMvQixlQUFlLG1CQUFPLENBQUMsc0VBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsOENBQThDLGVBQWU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxlQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9yZXF1ZXN0LmpzPzhjZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlcXVlc3RPbmUgPSBleHBvcnRzLlJlcXVlc3RNYW55ID0gZXhwb3J0cy5CYXNlUmVxdWVzdCA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMC0yMDIzIFRoZSBOQVRTIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgbnVpZF8xID0gcmVxdWlyZShcIi4vbnVpZFwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jbGFzcyBCYXNlUmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3IobXV4LCByZXF1ZXN0U3ViamVjdCwgYXN5bmNUcmFjZXMgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMubXV4ID0gbXV4O1xuICAgICAgICB0aGlzLnJlcXVlc3RTdWJqZWN0ID0gcmVxdWVzdFN1YmplY3Q7XG4gICAgICAgIHRoaXMucmVjZWl2ZWQgPSAwO1xuICAgICAgICB0aGlzLnRva2VuID0gbnVpZF8xLm51aWQubmV4dCgpO1xuICAgICAgICBpZiAoYXN5bmNUcmFjZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkJhc2VSZXF1ZXN0ID0gQmFzZVJlcXVlc3Q7XG4vKipcbiAqIFJlcXVlc3QgZXhwZWN0cyBtdWx0aXBsZSBtZXNzYWdlIHJlc3BvbnNlXG4gKiB0aGUgcmVxdWVzdCBlbmRzIHdoZW4gdGhlIHRpbWVyIGV4cGlyZXMsXG4gKiBhbiBlcnJvciBhcnJpdmVzIG9yIGFuIGV4cGVjdGVkIGNvdW50IG9mIG1lc3NhZ2VzXG4gKiBhcnJpdmVzLCBlbmQgaXMgc2lnbmFsZWQgYnkgYSBudWxsIG1lc3NhZ2VcbiAqL1xuY2xhc3MgUmVxdWVzdE1hbnkgZXh0ZW5kcyBCYXNlUmVxdWVzdCB7XG4gICAgY29uc3RydWN0b3IobXV4LCByZXF1ZXN0U3ViamVjdCwgb3B0cyA9IHsgbWF4V2FpdDogMTAwMCB9KSB7XG4gICAgICAgIHN1cGVyKG11eCwgcmVxdWVzdFN1YmplY3QpO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5jYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBpcyByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxiYWNrID0gdGhpcy5vcHRzLmNhbGxiYWNrO1xuICAgICAgICB0aGlzLm1heCA9IHR5cGVvZiBvcHRzLm1heE1lc3NhZ2VzID09PSBcIm51bWJlclwiICYmIG9wdHMubWF4TWVzc2FnZXMgPiAwXG4gICAgICAgICAgICA/IG9wdHMubWF4TWVzc2FnZXNcbiAgICAgICAgICAgIDogLTE7XG4gICAgICAgIHRoaXMuZG9uZSA9ICgwLCB1dGlsXzEuZGVmZXJyZWQpKCk7XG4gICAgICAgIHRoaXMuZG9uZS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sobnVsbCwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlOiBub2RlIGlzIG5vdCBhIG51bWJlclxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICB9LCBvcHRzLm1heFdhaXQpO1xuICAgIH1cbiAgICBjYW5jZWwoZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMubXV4LmNhbmNlbCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb25lLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcmVzb2x2ZXIoZXJyLCBtc2cpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3R4KSB7XG4gICAgICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5cXG4ke3RoaXMuY3R4LnN0YWNrfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbmNlbChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhudWxsLCBtc2cpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5zdHJhdGVneSA9PT0gY29yZV8xLlJlcXVlc3RTdHJhdGVneS5Db3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF4LS07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5zdHJhdGVneSA9PT0gY29yZV8xLlJlcXVlc3RTdHJhdGVneS5KaXR0ZXJUaW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBub2RlIGlzIG5vdCBhIG51bWJlclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzLm9wdHMuaml0dGVyIHx8IDMwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnN0cmF0ZWd5ID09PSBjb3JlXzEuUmVxdWVzdFN0cmF0ZWd5LlNlbnRpbmVsTXNnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1zZyAmJiBtc2cuZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RNYW55ID0gUmVxdWVzdE1hbnk7XG5jbGFzcyBSZXF1ZXN0T25lIGV4dGVuZHMgQmFzZVJlcXVlc3Qge1xuICAgIGNvbnN0cnVjdG9yKG11eCwgcmVxdWVzdFN1YmplY3QsIG9wdHMgPSB7IHRpbWVvdXQ6IDEwMDAgfSwgYXN5bmNUcmFjZXMgPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKG11eCwgcmVxdWVzdFN1YmplY3QsIGFzeW5jVHJhY2VzKTtcbiAgICAgICAgLy8gZXh0ZW5kKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLmRlZmVycmVkID0gKDAsIHV0aWxfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgdGhpcy50aW1lciA9ICgwLCB1dGlsXzEudGltZW91dCkob3B0cy50aW1lb3V0LCBhc3luY1RyYWNlcyk7XG4gICAgfVxuICAgIHJlc29sdmVyKGVyciwgbXNnKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVyLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN0eCkge1xuICAgICAgICAgICAgICAgIGVyci5zdGFjayArPSBgXFxuXFxuJHt0aGlzLmN0eC5zdGFja31gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVzb2x2ZShtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgfVxuICAgIGNhbmNlbChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMudGltZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdXguY2FuY2VsKHRoaXMpO1xuICAgICAgICB0aGlzLmRlZmVycmVkLnJlamVjdChlcnIgPyBlcnIgOiBjb3JlXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLkNhbmNlbGxlZCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdE9uZSA9IFJlcXVlc3RPbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXF1ZXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/semver.js":
/*!**********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/semver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Features = exports.Feature = exports.compare = exports.parseSemVer = void 0;\nfunction parseSemVer(s = \"\") {\n    const m = s.match(/(\\d+).(\\d+).(\\d+)/);\n    if (m) {\n        return {\n            major: parseInt(m[1]),\n            minor: parseInt(m[2]),\n            micro: parseInt(m[3]),\n        };\n    }\n    throw new Error(`'${s}' is not a semver value`);\n}\nexports.parseSemVer = parseSemVer;\nfunction compare(a, b) {\n    if (a.major < b.major)\n        return -1;\n    if (a.major > b.major)\n        return 1;\n    if (a.minor < b.minor)\n        return -1;\n    if (a.minor > b.minor)\n        return 1;\n    if (a.micro < b.micro)\n        return -1;\n    if (a.micro > b.micro)\n        return 1;\n    return 0;\n}\nexports.compare = compare;\nvar Feature;\n(function (Feature) {\n    Feature[\"JS_KV\"] = \"js_kv\";\n    Feature[\"JS_OBJECTSTORE\"] = \"js_objectstore\";\n    Feature[\"JS_PULL_MAX_BYTES\"] = \"js_pull_max_bytes\";\n    Feature[\"JS_NEW_CONSUMER_CREATE_API\"] = \"js_new_consumer_create\";\n    Feature[\"JS_ALLOW_DIRECT\"] = \"js_allow_direct\";\n    Feature[\"JS_MULTIPLE_CONSUMER_FILTER\"] = \"js_multiple_consumer_filter\";\n    Feature[\"JS_SIMPLIFICATION\"] = \"js_simplification\";\n    Feature[\"JS_STREAM_CONSUMER_METADATA\"] = \"js_stream_consumer_metadata\";\n    Feature[\"JS_CONSUMER_FILTER_SUBJECTS\"] = \"js_consumer_filter_subjects\";\n    Feature[\"JS_STREAM_FIRST_SEQ\"] = \"js_stream_first_seq\";\n    Feature[\"JS_STREAM_SUBJECT_TRANSFORM\"] = \"js_stream_subject_transform\";\n    Feature[\"JS_STREAM_SOURCE_SUBJECT_TRANSFORM\"] = \"js_stream_source_subject_transform\";\n    Feature[\"JS_STREAM_COMPRESSION\"] = \"js_stream_compression\";\n    Feature[\"JS_DEFAULT_CONSUMER_LIMITS\"] = \"js_default_consumer_limits\";\n})(Feature || (exports.Feature = Feature = {}));\nclass Features {\n    constructor(v) {\n        this.features = new Map();\n        this.disabled = [];\n        this.update(v);\n    }\n    /**\n     * Removes all disabled entries\n     */\n    resetDisabled() {\n        this.disabled.length = 0;\n        this.update(this.server);\n    }\n    /**\n     * Disables a particular feature.\n     * @param f\n     */\n    disable(f) {\n        this.disabled.push(f);\n        this.update(this.server);\n    }\n    isDisabled(f) {\n        return this.disabled.indexOf(f) !== -1;\n    }\n    update(v) {\n        if (typeof v === \"string\") {\n            v = parseSemVer(v);\n        }\n        this.server = v;\n        this.set(Feature.JS_KV, \"2.6.2\");\n        this.set(Feature.JS_OBJECTSTORE, \"2.6.3\");\n        this.set(Feature.JS_PULL_MAX_BYTES, \"2.8.3\");\n        this.set(Feature.JS_NEW_CONSUMER_CREATE_API, \"2.9.0\");\n        this.set(Feature.JS_ALLOW_DIRECT, \"2.9.0\");\n        this.set(Feature.JS_MULTIPLE_CONSUMER_FILTER, \"2.10.0\");\n        this.set(Feature.JS_SIMPLIFICATION, \"2.9.4\");\n        this.set(Feature.JS_STREAM_CONSUMER_METADATA, \"2.10.0\");\n        this.set(Feature.JS_CONSUMER_FILTER_SUBJECTS, \"2.10.0\");\n        this.set(Feature.JS_STREAM_FIRST_SEQ, \"2.10.0\");\n        this.set(Feature.JS_STREAM_SUBJECT_TRANSFORM, \"2.10.0\");\n        this.set(Feature.JS_STREAM_SOURCE_SUBJECT_TRANSFORM, \"2.10.0\");\n        this.set(Feature.JS_STREAM_COMPRESSION, \"2.10.0\");\n        this.set(Feature.JS_DEFAULT_CONSUMER_LIMITS, \"2.10.0\");\n        this.disabled.forEach((f) => {\n            this.features.delete(f);\n        });\n    }\n    /**\n     * Register a feature that requires a particular server version.\n     * @param f\n     * @param requires\n     */\n    set(f, requires) {\n        this.features.set(f, {\n            min: requires,\n            ok: compare(this.server, parseSemVer(requires)) >= 0,\n        });\n    }\n    /**\n     * Returns whether the feature is available and the min server\n     * version that supports it.\n     * @param f\n     */\n    get(f) {\n        return this.features.get(f) || { min: \"unknown\", ok: false };\n    }\n    /**\n     * Returns true if the feature is supported\n     * @param f\n     */\n    supports(f) {\n        var _a;\n        return ((_a = this.get(f)) === null || _a === void 0 ? void 0 : _a.ok) || false;\n    }\n    /**\n     * Returns true if the server is at least the specified version\n     * @param v\n     */\n    require(v) {\n        if (typeof v === \"string\") {\n            v = parseSemVer(v);\n        }\n        return compare(this.server, v) >= 0;\n    }\n}\nexports.Features = Features;\n//# sourceMappingURL=semver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9zZW12ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsbUJBQW1CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixFQUFFO0FBQzFCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsY0FBYyxlQUFlLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L3NlbXZlci5qcz9iN2M4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyLTIwMjMgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmVhdHVyZXMgPSBleHBvcnRzLkZlYXR1cmUgPSBleHBvcnRzLmNvbXBhcmUgPSBleHBvcnRzLnBhcnNlU2VtVmVyID0gdm9pZCAwO1xuZnVuY3Rpb24gcGFyc2VTZW1WZXIocyA9IFwiXCIpIHtcbiAgICBjb25zdCBtID0gcy5tYXRjaCgvKFxcZCspLihcXGQrKS4oXFxkKykvKTtcbiAgICBpZiAobSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFqb3I6IHBhcnNlSW50KG1bMV0pLFxuICAgICAgICAgICAgbWlub3I6IHBhcnNlSW50KG1bMl0pLFxuICAgICAgICAgICAgbWljcm86IHBhcnNlSW50KG1bM10pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYCcke3N9JyBpcyBub3QgYSBzZW12ZXIgdmFsdWVgKTtcbn1cbmV4cG9ydHMucGFyc2VTZW1WZXIgPSBwYXJzZVNlbVZlcjtcbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgIGlmIChhLm1ham9yIDwgYi5tYWpvcilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIGlmIChhLm1ham9yID4gYi5tYWpvcilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKGEubWlub3IgPCBiLm1pbm9yKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgaWYgKGEubWlub3IgPiBiLm1pbm9yKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAoYS5taWNybyA8IGIubWljcm8pXG4gICAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoYS5taWNybyA+IGIubWljcm8pXG4gICAgICAgIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xufVxuZXhwb3J0cy5jb21wYXJlID0gY29tcGFyZTtcbnZhciBGZWF0dXJlO1xuKGZ1bmN0aW9uIChGZWF0dXJlKSB7XG4gICAgRmVhdHVyZVtcIkpTX0tWXCJdID0gXCJqc19rdlwiO1xuICAgIEZlYXR1cmVbXCJKU19PQkpFQ1RTVE9SRVwiXSA9IFwianNfb2JqZWN0c3RvcmVcIjtcbiAgICBGZWF0dXJlW1wiSlNfUFVMTF9NQVhfQllURVNcIl0gPSBcImpzX3B1bGxfbWF4X2J5dGVzXCI7XG4gICAgRmVhdHVyZVtcIkpTX05FV19DT05TVU1FUl9DUkVBVEVfQVBJXCJdID0gXCJqc19uZXdfY29uc3VtZXJfY3JlYXRlXCI7XG4gICAgRmVhdHVyZVtcIkpTX0FMTE9XX0RJUkVDVFwiXSA9IFwianNfYWxsb3dfZGlyZWN0XCI7XG4gICAgRmVhdHVyZVtcIkpTX01VTFRJUExFX0NPTlNVTUVSX0ZJTFRFUlwiXSA9IFwianNfbXVsdGlwbGVfY29uc3VtZXJfZmlsdGVyXCI7XG4gICAgRmVhdHVyZVtcIkpTX1NJTVBMSUZJQ0FUSU9OXCJdID0gXCJqc19zaW1wbGlmaWNhdGlvblwiO1xuICAgIEZlYXR1cmVbXCJKU19TVFJFQU1fQ09OU1VNRVJfTUVUQURBVEFcIl0gPSBcImpzX3N0cmVhbV9jb25zdW1lcl9tZXRhZGF0YVwiO1xuICAgIEZlYXR1cmVbXCJKU19DT05TVU1FUl9GSUxURVJfU1VCSkVDVFNcIl0gPSBcImpzX2NvbnN1bWVyX2ZpbHRlcl9zdWJqZWN0c1wiO1xuICAgIEZlYXR1cmVbXCJKU19TVFJFQU1fRklSU1RfU0VRXCJdID0gXCJqc19zdHJlYW1fZmlyc3Rfc2VxXCI7XG4gICAgRmVhdHVyZVtcIkpTX1NUUkVBTV9TVUJKRUNUX1RSQU5TRk9STVwiXSA9IFwianNfc3RyZWFtX3N1YmplY3RfdHJhbnNmb3JtXCI7XG4gICAgRmVhdHVyZVtcIkpTX1NUUkVBTV9TT1VSQ0VfU1VCSkVDVF9UUkFOU0ZPUk1cIl0gPSBcImpzX3N0cmVhbV9zb3VyY2Vfc3ViamVjdF90cmFuc2Zvcm1cIjtcbiAgICBGZWF0dXJlW1wiSlNfU1RSRUFNX0NPTVBSRVNTSU9OXCJdID0gXCJqc19zdHJlYW1fY29tcHJlc3Npb25cIjtcbiAgICBGZWF0dXJlW1wiSlNfREVGQVVMVF9DT05TVU1FUl9MSU1JVFNcIl0gPSBcImpzX2RlZmF1bHRfY29uc3VtZXJfbGltaXRzXCI7XG59KShGZWF0dXJlIHx8IChleHBvcnRzLkZlYXR1cmUgPSBGZWF0dXJlID0ge30pKTtcbmNsYXNzIEZlYXR1cmVzIHtcbiAgICBjb25zdHJ1Y3Rvcih2KSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBbXTtcbiAgICAgICAgdGhpcy51cGRhdGUodik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGRpc2FibGVkIGVudHJpZXNcbiAgICAgKi9cbiAgICByZXNldERpc2FibGVkKCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMudXBkYXRlKHRoaXMuc2VydmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgYSBwYXJ0aWN1bGFyIGZlYXR1cmUuXG4gICAgICogQHBhcmFtIGZcbiAgICAgKi9cbiAgICBkaXNhYmxlKGYpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZC5wdXNoKGYpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnNlcnZlcik7XG4gICAgfVxuICAgIGlzRGlzYWJsZWQoZikge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZC5pbmRleE9mKGYpICE9PSAtMTtcbiAgICB9XG4gICAgdXBkYXRlKHYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2ID0gcGFyc2VTZW1WZXIodik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSB2O1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX0tWLCBcIjIuNi4yXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX09CSkVDVFNUT1JFLCBcIjIuNi4zXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX1BVTExfTUFYX0JZVEVTLCBcIjIuOC4zXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX05FV19DT05TVU1FUl9DUkVBVEVfQVBJLCBcIjIuOS4wXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX0FMTE9XX0RJUkVDVCwgXCIyLjkuMFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19NVUxUSVBMRV9DT05TVU1FUl9GSUxURVIsIFwiMi4xMC4wXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX1NJTVBMSUZJQ0FUSU9OLCBcIjIuOS40XCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX1NUUkVBTV9DT05TVU1FUl9NRVRBREFUQSwgXCIyLjEwLjBcIik7XG4gICAgICAgIHRoaXMuc2V0KEZlYXR1cmUuSlNfQ09OU1VNRVJfRklMVEVSX1NVQkpFQ1RTLCBcIjIuMTAuMFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19TVFJFQU1fRklSU1RfU0VRLCBcIjIuMTAuMFwiKTtcbiAgICAgICAgdGhpcy5zZXQoRmVhdHVyZS5KU19TVFJFQU1fU1VCSkVDVF9UUkFOU0ZPUk0sIFwiMi4xMC4wXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX1NUUkVBTV9TT1VSQ0VfU1VCSkVDVF9UUkFOU0ZPUk0sIFwiMi4xMC4wXCIpO1xuICAgICAgICB0aGlzLnNldChGZWF0dXJlLkpTX1NUUkVBTV9DT01QUkVTU0lPTiwgXCIyLjEwLjBcIik7XG4gICAgICAgIHRoaXMuc2V0KEZlYXR1cmUuSlNfREVGQVVMVF9DT05TVU1FUl9MSU1JVFMsIFwiMi4xMC4wXCIpO1xuICAgICAgICB0aGlzLmRpc2FibGVkLmZvckVhY2goKGYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMuZGVsZXRlKGYpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBmZWF0dXJlIHRoYXQgcmVxdWlyZXMgYSBwYXJ0aWN1bGFyIHNlcnZlciB2ZXJzaW9uLlxuICAgICAqIEBwYXJhbSBmXG4gICAgICogQHBhcmFtIHJlcXVpcmVzXG4gICAgICovXG4gICAgc2V0KGYsIHJlcXVpcmVzKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMuc2V0KGYsIHtcbiAgICAgICAgICAgIG1pbjogcmVxdWlyZXMsXG4gICAgICAgICAgICBvazogY29tcGFyZSh0aGlzLnNlcnZlciwgcGFyc2VTZW1WZXIocmVxdWlyZXMpKSA+PSAwLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBmZWF0dXJlIGlzIGF2YWlsYWJsZSBhbmQgdGhlIG1pbiBzZXJ2ZXJcbiAgICAgKiB2ZXJzaW9uIHRoYXQgc3VwcG9ydHMgaXQuXG4gICAgICogQHBhcmFtIGZcbiAgICAgKi9cbiAgICBnZXQoZikge1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlcy5nZXQoZikgfHwgeyBtaW46IFwidW5rbm93blwiLCBvazogZmFsc2UgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmZWF0dXJlIGlzIHN1cHBvcnRlZFxuICAgICAqIEBwYXJhbSBmXG4gICAgICovXG4gICAgc3VwcG9ydHMoZikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5nZXQoZikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vaykgfHwgZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2VydmVyIGlzIGF0IGxlYXN0IHRoZSBzcGVjaWZpZWQgdmVyc2lvblxuICAgICAqIEBwYXJhbSB2XG4gICAgICovXG4gICAgcmVxdWlyZSh2KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdiA9IHBhcnNlU2VtVmVyKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wYXJlKHRoaXMuc2VydmVyLCB2KSA+PSAwO1xuICAgIH1cbn1cbmV4cG9ydHMuRmVhdHVyZXMgPSBGZWF0dXJlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlbXZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/semver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/servers.js":
/*!***********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/servers.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Servers = exports.ServerImpl = exports.hostPort = exports.isIPV4OrHostname = void 0;\n/*\n * Copyright 2018-2022 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst transport_1 = __webpack_require__(/*! ./transport */ \"(rsc)/./node_modules/nats/lib/nats-base-client/transport.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst ipparser_1 = __webpack_require__(/*! ./ipparser */ \"(rsc)/./node_modules/nats/lib/nats-base-client/ipparser.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nfunction isIPV4OrHostname(hp) {\n    if (hp.indexOf(\".\") !== -1) {\n        return true;\n    }\n    if (hp.indexOf(\"[\") !== -1 || hp.indexOf(\"::\") !== -1) {\n        return false;\n    }\n    // if we have a plain hostname or host:port\n    if (hp.split(\":\").length <= 2) {\n        return true;\n    }\n    return false;\n}\nexports.isIPV4OrHostname = isIPV4OrHostname;\nfunction isIPV6(hp) {\n    return !isIPV4OrHostname(hp);\n}\nfunction filterIpv6MappedToIpv4(hp) {\n    const prefix = \"::FFFF:\";\n    const idx = hp.toUpperCase().indexOf(prefix);\n    if (idx !== -1 && hp.indexOf(\".\") !== -1) {\n        // we have something like: ::FFFF:127.0.0.1 or [::FFFF:127.0.0.1]:4222\n        let ip = hp.substring(idx + prefix.length);\n        ip = ip.replace(\"[\", \"\");\n        return ip.replace(\"]\", \"\");\n    }\n    return hp;\n}\nfunction hostPort(u) {\n    u = u.trim();\n    // remove any protocol that may have been provided\n    if (u.match(/^(.*:\\/\\/)(.*)/m)) {\n        u = u.replace(/^(.*:\\/\\/)(.*)/gm, \"$2\");\n    }\n    // in web environments, URL may not be a living standard\n    // that means that protocols other than HTTP/S are not\n    // parsable correctly.\n    // the third complication is that we may have been given\n    // an IPv6 or worse IPv6 mapping an Ipv4\n    u = filterIpv6MappedToIpv4(u);\n    // we only wrap cases where they gave us a plain ipv6\n    // and we are not already bracketed\n    if (isIPV6(u) && u.indexOf(\"[\") === -1) {\n        u = `[${u}]`;\n    }\n    // if we have ipv6, we expect port after ']:' otherwise after ':'\n    const op = isIPV6(u) ? u.match(/(]:)(\\d+)/) : u.match(/(:)(\\d+)/);\n    const port = op && op.length === 3 && op[1] && op[2]\n        ? parseInt(op[2])\n        : core_1.DEFAULT_PORT;\n    // the next complication is that new URL() may\n    // eat ports which match the protocol - so for example\n    // port 80 may be eliminated - so we flip the protocol\n    // so that it always yields a value\n    const protocol = port === 80 ? \"https\" : \"http\";\n    const url = new URL(`${protocol}://${u}`);\n    url.port = `${port}`;\n    let hostname = url.hostname;\n    // if we are bracketed, we need to rip it out\n    if (hostname.charAt(0) === \"[\") {\n        hostname = hostname.substring(1, hostname.length - 1);\n    }\n    const listen = url.host;\n    return { listen, hostname, port };\n}\nexports.hostPort = hostPort;\n/**\n * @hidden\n */\nclass ServerImpl {\n    constructor(u, gossiped = false) {\n        this.src = u;\n        this.tlsName = \"\";\n        const v = hostPort(u);\n        this.listen = v.listen;\n        this.hostname = v.hostname;\n        this.port = v.port;\n        this.didConnect = false;\n        this.reconnects = 0;\n        this.lastConnect = 0;\n        this.gossiped = gossiped;\n    }\n    toString() {\n        return this.listen;\n    }\n    resolve(opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!opts.fn) {\n                // we cannot resolve - transport doesn't support it\n                // don't add - to resolves or we get a circ reference\n                return [this];\n            }\n            const buf = [];\n            if ((0, ipparser_1.isIP)(this.hostname)) {\n                // don't add - to resolves or we get a circ reference\n                return [this];\n            }\n            else {\n                // resolve the hostname to ips\n                const ips = yield opts.fn(this.hostname);\n                if (opts.debug) {\n                    console.log(`resolve ${this.hostname} = ${ips.join(\",\")}`);\n                }\n                for (const ip of ips) {\n                    // letting URL handle the details of representing IPV6 ip with a port, etc\n                    // careful to make sure the protocol doesn't line with standard ports or they\n                    // get swallowed\n                    const proto = this.port === 80 ? \"https\" : \"http\";\n                    // ipv6 won't be bracketed here, because it came from resolve\n                    const url = new URL(`${proto}://${isIPV6(ip) ? \"[\" + ip + \"]\" : ip}`);\n                    url.port = `${this.port}`;\n                    const ss = new ServerImpl(url.host, false);\n                    ss.tlsName = this.hostname;\n                    buf.push(ss);\n                }\n            }\n            if (opts.randomize) {\n                (0, util_1.shuffle)(buf);\n            }\n            this.resolves = buf;\n            return buf;\n        });\n    }\n}\nexports.ServerImpl = ServerImpl;\n/**\n * @hidden\n */\nclass Servers {\n    constructor(listens = [], opts = {}) {\n        this.firstSelect = true;\n        this.servers = [];\n        this.tlsName = \"\";\n        this.randomize = opts.randomize || false;\n        const urlParseFn = (0, transport_1.getUrlParseFn)();\n        if (listens) {\n            listens.forEach((hp) => {\n                hp = urlParseFn ? urlParseFn(hp) : hp;\n                this.servers.push(new ServerImpl(hp));\n            });\n            if (this.randomize) {\n                this.servers = (0, util_1.shuffle)(this.servers);\n            }\n        }\n        if (this.servers.length === 0) {\n            this.addServer(`${core_1.DEFAULT_HOST}:${(0, transport_1.defaultPort)()}`, false);\n        }\n        this.currentServer = this.servers[0];\n    }\n    clear() {\n        this.servers.length = 0;\n    }\n    updateTLSName() {\n        const cs = this.getCurrentServer();\n        if (!(0, ipparser_1.isIP)(cs.hostname)) {\n            this.tlsName = cs.hostname;\n            this.servers.forEach((s) => {\n                if (s.gossiped) {\n                    s.tlsName = this.tlsName;\n                }\n            });\n        }\n    }\n    getCurrentServer() {\n        return this.currentServer;\n    }\n    addServer(u, implicit = false) {\n        const urlParseFn = (0, transport_1.getUrlParseFn)();\n        u = urlParseFn ? urlParseFn(u) : u;\n        const s = new ServerImpl(u, implicit);\n        if ((0, ipparser_1.isIP)(s.hostname)) {\n            s.tlsName = this.tlsName;\n        }\n        this.servers.push(s);\n    }\n    selectServer() {\n        // allow using select without breaking the order of the servers\n        if (this.firstSelect) {\n            this.firstSelect = false;\n            return this.currentServer;\n        }\n        const t = this.servers.shift();\n        if (t) {\n            this.servers.push(t);\n            this.currentServer = t;\n        }\n        return t;\n    }\n    removeCurrentServer() {\n        this.removeServer(this.currentServer);\n    }\n    removeServer(server) {\n        if (server) {\n            const index = this.servers.indexOf(server);\n            this.servers.splice(index, 1);\n        }\n    }\n    length() {\n        return this.servers.length;\n    }\n    next() {\n        return this.servers.length ? this.servers[0] : undefined;\n    }\n    getServers() {\n        return this.servers;\n    }\n    update(info, encrypted) {\n        const added = [];\n        let deleted = [];\n        const urlParseFn = (0, transport_1.getUrlParseFn)();\n        const discovered = new Map();\n        if (info.connect_urls && info.connect_urls.length > 0) {\n            info.connect_urls.forEach((hp) => {\n                hp = urlParseFn ? urlParseFn(hp, encrypted) : hp;\n                const s = new ServerImpl(hp, true);\n                discovered.set(hp, s);\n            });\n        }\n        // remove gossiped servers that are no longer reported\n        const toDelete = [];\n        this.servers.forEach((s, index) => {\n            const u = s.listen;\n            if (s.gossiped && this.currentServer.listen !== u &&\n                discovered.get(u) === undefined) {\n                // server was removed\n                toDelete.push(index);\n            }\n            // remove this entry from reported\n            discovered.delete(u);\n        });\n        // perform the deletion\n        toDelete.reverse();\n        toDelete.forEach((index) => {\n            const removed = this.servers.splice(index, 1);\n            deleted = deleted.concat(removed[0].listen);\n        });\n        // remaining servers are new\n        discovered.forEach((v, k) => {\n            this.servers.push(v);\n            added.push(k);\n        });\n        return { added, deleted };\n    }\n}\nexports.Servers = Servers;\n//# sourceMappingURL=servers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9zZXJ2ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsd0JBQXdCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxnRkFBYTtBQUN6QyxlQUFlLG1CQUFPLENBQUMsc0VBQVE7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsOEVBQVk7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVMsS0FBSyxFQUFFO0FBQzNDLGtCQUFrQixLQUFLO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWUsSUFBSSxjQUFjO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE1BQU0sS0FBSyxpQ0FBaUM7QUFDdkYsa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsR0FBRywrQkFBK0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL25hdHMtYmFzZS1jbGllbnQvc2VydmVycy5qcz9mMWZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlcnMgPSBleHBvcnRzLlNlcnZlckltcGwgPSBleHBvcnRzLmhvc3RQb3J0ID0gZXhwb3J0cy5pc0lQVjRPckhvc3RuYW1lID0gdm9pZCAwO1xuLypcbiAqIENvcHlyaWdodCAyMDE4LTIwMjIgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0XCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGlwcGFyc2VyXzEgPSByZXF1aXJlKFwiLi9pcHBhcnNlclwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5mdW5jdGlvbiBpc0lQVjRPckhvc3RuYW1lKGhwKSB7XG4gICAgaWYgKGhwLmluZGV4T2YoXCIuXCIpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhwLmluZGV4T2YoXCJbXCIpICE9PSAtMSB8fCBocC5pbmRleE9mKFwiOjpcIikgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gaWYgd2UgaGF2ZSBhIHBsYWluIGhvc3RuYW1lIG9yIGhvc3Q6cG9ydFxuICAgIGlmIChocC5zcGxpdChcIjpcIikubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNJUFY0T3JIb3N0bmFtZSA9IGlzSVBWNE9ySG9zdG5hbWU7XG5mdW5jdGlvbiBpc0lQVjYoaHApIHtcbiAgICByZXR1cm4gIWlzSVBWNE9ySG9zdG5hbWUoaHApO1xufVxuZnVuY3Rpb24gZmlsdGVySXB2Nk1hcHBlZFRvSXB2NChocCkge1xuICAgIGNvbnN0IHByZWZpeCA9IFwiOjpGRkZGOlwiO1xuICAgIGNvbnN0IGlkeCA9IGhwLnRvVXBwZXJDYXNlKCkuaW5kZXhPZihwcmVmaXgpO1xuICAgIGlmIChpZHggIT09IC0xICYmIGhwLmluZGV4T2YoXCIuXCIpICE9PSAtMSkge1xuICAgICAgICAvLyB3ZSBoYXZlIHNvbWV0aGluZyBsaWtlOiA6OkZGRkY6MTI3LjAuMC4xIG9yIFs6OkZGRkY6MTI3LjAuMC4xXTo0MjIyXG4gICAgICAgIGxldCBpcCA9IGhwLnN1YnN0cmluZyhpZHggKyBwcmVmaXgubGVuZ3RoKTtcbiAgICAgICAgaXAgPSBpcC5yZXBsYWNlKFwiW1wiLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGlwLnJlcGxhY2UoXCJdXCIsIFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gaHA7XG59XG5mdW5jdGlvbiBob3N0UG9ydCh1KSB7XG4gICAgdSA9IHUudHJpbSgpO1xuICAgIC8vIHJlbW92ZSBhbnkgcHJvdG9jb2wgdGhhdCBtYXkgaGF2ZSBiZWVuIHByb3ZpZGVkXG4gICAgaWYgKHUubWF0Y2goL14oLio6XFwvXFwvKSguKikvbSkpIHtcbiAgICAgICAgdSA9IHUucmVwbGFjZSgvXiguKjpcXC9cXC8pKC4qKS9nbSwgXCIkMlwiKTtcbiAgICB9XG4gICAgLy8gaW4gd2ViIGVudmlyb25tZW50cywgVVJMIG1heSBub3QgYmUgYSBsaXZpbmcgc3RhbmRhcmRcbiAgICAvLyB0aGF0IG1lYW5zIHRoYXQgcHJvdG9jb2xzIG90aGVyIHRoYW4gSFRUUC9TIGFyZSBub3RcbiAgICAvLyBwYXJzYWJsZSBjb3JyZWN0bHkuXG4gICAgLy8gdGhlIHRoaXJkIGNvbXBsaWNhdGlvbiBpcyB0aGF0IHdlIG1heSBoYXZlIGJlZW4gZ2l2ZW5cbiAgICAvLyBhbiBJUHY2IG9yIHdvcnNlIElQdjYgbWFwcGluZyBhbiBJcHY0XG4gICAgdSA9IGZpbHRlcklwdjZNYXBwZWRUb0lwdjQodSk7XG4gICAgLy8gd2Ugb25seSB3cmFwIGNhc2VzIHdoZXJlIHRoZXkgZ2F2ZSB1cyBhIHBsYWluIGlwdjZcbiAgICAvLyBhbmQgd2UgYXJlIG5vdCBhbHJlYWR5IGJyYWNrZXRlZFxuICAgIGlmIChpc0lQVjYodSkgJiYgdS5pbmRleE9mKFwiW1wiKSA9PT0gLTEpIHtcbiAgICAgICAgdSA9IGBbJHt1fV1gO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBoYXZlIGlwdjYsIHdlIGV4cGVjdCBwb3J0IGFmdGVyICddOicgb3RoZXJ3aXNlIGFmdGVyICc6J1xuICAgIGNvbnN0IG9wID0gaXNJUFY2KHUpID8gdS5tYXRjaCgvKF06KShcXGQrKS8pIDogdS5tYXRjaCgvKDopKFxcZCspLyk7XG4gICAgY29uc3QgcG9ydCA9IG9wICYmIG9wLmxlbmd0aCA9PT0gMyAmJiBvcFsxXSAmJiBvcFsyXVxuICAgICAgICA/IHBhcnNlSW50KG9wWzJdKVxuICAgICAgICA6IGNvcmVfMS5ERUZBVUxUX1BPUlQ7XG4gICAgLy8gdGhlIG5leHQgY29tcGxpY2F0aW9uIGlzIHRoYXQgbmV3IFVSTCgpIG1heVxuICAgIC8vIGVhdCBwb3J0cyB3aGljaCBtYXRjaCB0aGUgcHJvdG9jb2wgLSBzbyBmb3IgZXhhbXBsZVxuICAgIC8vIHBvcnQgODAgbWF5IGJlIGVsaW1pbmF0ZWQgLSBzbyB3ZSBmbGlwIHRoZSBwcm90b2NvbFxuICAgIC8vIHNvIHRoYXQgaXQgYWx3YXlzIHlpZWxkcyBhIHZhbHVlXG4gICAgY29uc3QgcHJvdG9jb2wgPSBwb3J0ID09PSA4MCA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiO1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7cHJvdG9jb2x9Oi8vJHt1fWApO1xuICAgIHVybC5wb3J0ID0gYCR7cG9ydH1gO1xuICAgIGxldCBob3N0bmFtZSA9IHVybC5ob3N0bmFtZTtcbiAgICAvLyBpZiB3ZSBhcmUgYnJhY2tldGVkLCB3ZSBuZWVkIHRvIHJpcCBpdCBvdXRcbiAgICBpZiAoaG9zdG5hbWUuY2hhckF0KDApID09PSBcIltcIikge1xuICAgICAgICBob3N0bmFtZSA9IGhvc3RuYW1lLnN1YnN0cmluZygxLCBob3N0bmFtZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuID0gdXJsLmhvc3Q7XG4gICAgcmV0dXJuIHsgbGlzdGVuLCBob3N0bmFtZSwgcG9ydCB9O1xufVxuZXhwb3J0cy5ob3N0UG9ydCA9IGhvc3RQb3J0O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcnZlckltcGwge1xuICAgIGNvbnN0cnVjdG9yKHUsIGdvc3NpcGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5zcmMgPSB1O1xuICAgICAgICB0aGlzLnRsc05hbWUgPSBcIlwiO1xuICAgICAgICBjb25zdCB2ID0gaG9zdFBvcnQodSk7XG4gICAgICAgIHRoaXMubGlzdGVuID0gdi5saXN0ZW47XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2Lmhvc3RuYW1lO1xuICAgICAgICB0aGlzLnBvcnQgPSB2LnBvcnQ7XG4gICAgICAgIHRoaXMuZGlkQ29ubmVjdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlY29ubmVjdHMgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb25uZWN0ID0gMDtcbiAgICAgICAgdGhpcy5nb3NzaXBlZCA9IGdvc3NpcGVkO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuO1xuICAgIH1cbiAgICByZXNvbHZlKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghb3B0cy5mbikge1xuICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCByZXNvbHZlIC0gdHJhbnNwb3J0IGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCAtIHRvIHJlc29sdmVzIG9yIHdlIGdldCBhIGNpcmMgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IFtdO1xuICAgICAgICAgICAgaWYgKCgwLCBpcHBhcnNlcl8xLmlzSVApKHRoaXMuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWRkIC0gdG8gcmVzb2x2ZXMgb3Igd2UgZ2V0IGEgY2lyYyByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzb2x2ZSB0aGUgaG9zdG5hbWUgdG8gaXBzXG4gICAgICAgICAgICAgICAgY29uc3QgaXBzID0geWllbGQgb3B0cy5mbih0aGlzLmhvc3RuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0cy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgcmVzb2x2ZSAke3RoaXMuaG9zdG5hbWV9ID0gJHtpcHMuam9pbihcIixcIil9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXAgb2YgaXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxldHRpbmcgVVJMIGhhbmRsZSB0aGUgZGV0YWlscyBvZiByZXByZXNlbnRpbmcgSVBWNiBpcCB3aXRoIGEgcG9ydCwgZXRjXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhcmVmdWwgdG8gbWFrZSBzdXJlIHRoZSBwcm90b2NvbCBkb2Vzbid0IGxpbmUgd2l0aCBzdGFuZGFyZCBwb3J0cyBvciB0aGV5XG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBzd2FsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvdG8gPSB0aGlzLnBvcnQgPT09IDgwID8gXCJodHRwc1wiIDogXCJodHRwXCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlwdjYgd29uJ3QgYmUgYnJhY2tldGVkIGhlcmUsIGJlY2F1c2UgaXQgY2FtZSBmcm9tIHJlc29sdmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtwcm90b306Ly8ke2lzSVBWNihpcCkgPyBcIltcIiArIGlwICsgXCJdXCIgOiBpcH1gKTtcbiAgICAgICAgICAgICAgICAgICAgdXJsLnBvcnQgPSBgJHt0aGlzLnBvcnR9YDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3MgPSBuZXcgU2VydmVySW1wbCh1cmwuaG9zdCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBzcy50bHNOYW1lID0gdGhpcy5ob3N0bmFtZTtcbiAgICAgICAgICAgICAgICAgICAgYnVmLnB1c2goc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLnJhbmRvbWl6ZSkge1xuICAgICAgICAgICAgICAgICgwLCB1dGlsXzEuc2h1ZmZsZSkoYnVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXMgPSBidWY7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlckltcGwgPSBTZXJ2ZXJJbXBsO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcnZlcnMge1xuICAgIGNvbnN0cnVjdG9yKGxpc3RlbnMgPSBbXSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuZmlyc3RTZWxlY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLnNlcnZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy50bHNOYW1lID0gXCJcIjtcbiAgICAgICAgdGhpcy5yYW5kb21pemUgPSBvcHRzLnJhbmRvbWl6ZSB8fCBmYWxzZTtcbiAgICAgICAgY29uc3QgdXJsUGFyc2VGbiA9ICgwLCB0cmFuc3BvcnRfMS5nZXRVcmxQYXJzZUZuKSgpO1xuICAgICAgICBpZiAobGlzdGVucykge1xuICAgICAgICAgICAgbGlzdGVucy5mb3JFYWNoKChocCkgPT4ge1xuICAgICAgICAgICAgICAgIGhwID0gdXJsUGFyc2VGbiA/IHVybFBhcnNlRm4oaHApIDogaHA7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzLnB1c2gobmV3IFNlcnZlckltcGwoaHApKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucmFuZG9taXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzID0gKDAsIHV0aWxfMS5zaHVmZmxlKSh0aGlzLnNlcnZlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNlcnZlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFNlcnZlcihgJHtjb3JlXzEuREVGQVVMVF9IT1NUfTokeygwLCB0cmFuc3BvcnRfMS5kZWZhdWx0UG9ydCkoKX1gLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U2VydmVyID0gdGhpcy5zZXJ2ZXJzWzBdO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHVwZGF0ZVRMU05hbWUoKSB7XG4gICAgICAgIGNvbnN0IGNzID0gdGhpcy5nZXRDdXJyZW50U2VydmVyKCk7XG4gICAgICAgIGlmICghKDAsIGlwcGFyc2VyXzEuaXNJUCkoY3MuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnRsc05hbWUgPSBjcy5ob3N0bmFtZTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVycy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHMuZ29zc2lwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcy50bHNOYW1lID0gdGhpcy50bHNOYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEN1cnJlbnRTZXJ2ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTZXJ2ZXI7XG4gICAgfVxuICAgIGFkZFNlcnZlcih1LCBpbXBsaWNpdCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHVybFBhcnNlRm4gPSAoMCwgdHJhbnNwb3J0XzEuZ2V0VXJsUGFyc2VGbikoKTtcbiAgICAgICAgdSA9IHVybFBhcnNlRm4gPyB1cmxQYXJzZUZuKHUpIDogdTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBTZXJ2ZXJJbXBsKHUsIGltcGxpY2l0KTtcbiAgICAgICAgaWYgKCgwLCBpcHBhcnNlcl8xLmlzSVApKHMuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICBzLnRsc05hbWUgPSB0aGlzLnRsc05hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXJ2ZXJzLnB1c2gocyk7XG4gICAgfVxuICAgIHNlbGVjdFNlcnZlcigpIHtcbiAgICAgICAgLy8gYWxsb3cgdXNpbmcgc2VsZWN0IHdpdGhvdXQgYnJlYWtpbmcgdGhlIG9yZGVyIG9mIHRoZSBzZXJ2ZXJzXG4gICAgICAgIGlmICh0aGlzLmZpcnN0U2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmZpcnN0U2VsZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2VydmVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnNlcnZlcnMuc2hpZnQoKTtcbiAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmVycy5wdXNoKHQpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2VydmVyID0gdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgcmVtb3ZlQ3VycmVudFNlcnZlcigpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTZXJ2ZXIodGhpcy5jdXJyZW50U2VydmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlU2VydmVyKHNlcnZlcikge1xuICAgICAgICBpZiAoc2VydmVyKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc2VydmVycy5pbmRleE9mKHNlcnZlcik7XG4gICAgICAgICAgICB0aGlzLnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZlcnMubGVuZ3RoO1xuICAgIH1cbiAgICBuZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJzLmxlbmd0aCA/IHRoaXMuc2VydmVyc1swXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0U2VydmVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmVycztcbiAgICB9XG4gICAgdXBkYXRlKGluZm8sIGVuY3J5cHRlZCkge1xuICAgICAgICBjb25zdCBhZGRlZCA9IFtdO1xuICAgICAgICBsZXQgZGVsZXRlZCA9IFtdO1xuICAgICAgICBjb25zdCB1cmxQYXJzZUZuID0gKDAsIHRyYW5zcG9ydF8xLmdldFVybFBhcnNlRm4pKCk7XG4gICAgICAgIGNvbnN0IGRpc2NvdmVyZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChpbmZvLmNvbm5lY3RfdXJscyAmJiBpbmZvLmNvbm5lY3RfdXJscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbmZvLmNvbm5lY3RfdXJscy5mb3JFYWNoKChocCkgPT4ge1xuICAgICAgICAgICAgICAgIGhwID0gdXJsUGFyc2VGbiA/IHVybFBhcnNlRm4oaHAsIGVuY3J5cHRlZCkgOiBocDtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gbmV3IFNlcnZlckltcGwoaHAsIHRydWUpO1xuICAgICAgICAgICAgICAgIGRpc2NvdmVyZWQuc2V0KGhwLCBzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBnb3NzaXBlZCBzZXJ2ZXJzIHRoYXQgYXJlIG5vIGxvbmdlciByZXBvcnRlZFxuICAgICAgICBjb25zdCB0b0RlbGV0ZSA9IFtdO1xuICAgICAgICB0aGlzLnNlcnZlcnMuZm9yRWFjaCgocywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBzLmxpc3RlbjtcbiAgICAgICAgICAgIGlmIChzLmdvc3NpcGVkICYmIHRoaXMuY3VycmVudFNlcnZlci5saXN0ZW4gIT09IHUgJiZcbiAgICAgICAgICAgICAgICBkaXNjb3ZlcmVkLmdldCh1KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VydmVyIHdhcyByZW1vdmVkXG4gICAgICAgICAgICAgICAgdG9EZWxldGUucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhpcyBlbnRyeSBmcm9tIHJlcG9ydGVkXG4gICAgICAgICAgICBkaXNjb3ZlcmVkLmRlbGV0ZSh1KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHBlcmZvcm0gdGhlIGRlbGV0aW9uXG4gICAgICAgIHRvRGVsZXRlLnJldmVyc2UoKTtcbiAgICAgICAgdG9EZWxldGUuZm9yRWFjaCgoaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWQgPSB0aGlzLnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZWQgPSBkZWxldGVkLmNvbmNhdChyZW1vdmVkWzBdLmxpc3Rlbik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZW1haW5pbmcgc2VydmVycyBhcmUgbmV3XG4gICAgICAgIGRpc2NvdmVyZWQuZm9yRWFjaCgodiwgaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXJzLnB1c2godik7XG4gICAgICAgICAgICBhZGRlZC5wdXNoKGspO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgYWRkZWQsIGRlbGV0ZWQgfTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlcnMgPSBTZXJ2ZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/servers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/service.js":
/*!***********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/service.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServiceImpl = exports.ServiceGroupImpl = exports.ServiceMsgImpl = exports.ServiceApiPrefix = void 0;\n/*\n * Copyright 2022-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst headers_1 = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/nats/lib/nats-base-client/headers.js\");\nconst codec_1 = __webpack_require__(/*! ./codec */ \"(rsc)/./node_modules/nats/lib/nats-base-client/codec.js\");\nconst nuid_1 = __webpack_require__(/*! ./nuid */ \"(rsc)/./node_modules/nats/lib/nats-base-client/nuid.js\");\nconst queued_iterator_1 = __webpack_require__(/*! ./queued_iterator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\");\nconst jsutil_1 = __webpack_require__(/*! ../jetstream/jsutil */ \"(rsc)/./node_modules/nats/lib/jetstream/jsutil.js\");\nconst semver_1 = __webpack_require__(/*! ./semver */ \"(rsc)/./node_modules/nats/lib/nats-base-client/semver.js\");\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\n/**\n * Services have common backplane subject pattern:\n *\n * `$SRV.PING|STATS|INFO` - pings or retrieves status for all services\n * `$SRV.PING|STATS|INFO.<name>` - pings or retrieves status for all services having the specified name\n * `$SRV.PING|STATS|INFO.<name>.<id>` - pings or retrieves status of a particular service\n *\n * Note that <name> and <id> are upper-cased.\n */\nexports.ServiceApiPrefix = \"$SRV\";\nclass ServiceMsgImpl {\n    constructor(msg) {\n        this.msg = msg;\n    }\n    get data() {\n        return this.msg.data;\n    }\n    get sid() {\n        return this.msg.sid;\n    }\n    get subject() {\n        return this.msg.subject;\n    }\n    get reply() {\n        return this.msg.reply || \"\";\n    }\n    get headers() {\n        return this.msg.headers;\n    }\n    respond(data, opts) {\n        return this.msg.respond(data, opts);\n    }\n    respondError(code, description, data, opts) {\n        var _a, _b;\n        opts = opts || {};\n        opts.headers = opts.headers || (0, headers_1.headers)();\n        (_a = opts.headers) === null || _a === void 0 ? void 0 : _a.set(core_1.ServiceErrorCodeHeader, `${code}`);\n        (_b = opts.headers) === null || _b === void 0 ? void 0 : _b.set(core_1.ServiceErrorHeader, description);\n        return this.msg.respond(data, opts);\n    }\n    json(reviver) {\n        return this.msg.json(reviver);\n    }\n    string() {\n        return this.msg.string();\n    }\n}\nexports.ServiceMsgImpl = ServiceMsgImpl;\nclass ServiceGroupImpl {\n    constructor(parent, name = \"\", queue = \"\") {\n        if (name !== \"\") {\n            validInternalToken(\"service group\", name);\n        }\n        let root = \"\";\n        if (parent instanceof ServiceImpl) {\n            this.srv = parent;\n            root = \"\";\n        }\n        else if (parent instanceof ServiceGroupImpl) {\n            const sg = parent;\n            this.srv = sg.srv;\n            if (queue === \"\" && sg.queue !== \"\") {\n                queue = sg.queue;\n            }\n            root = sg.subject;\n        }\n        else {\n            throw new Error(\"unknown ServiceGroup type\");\n        }\n        this.subject = this.calcSubject(root, name);\n        this.queue = queue;\n    }\n    calcSubject(root, name = \"\") {\n        if (name === \"\") {\n            return root;\n        }\n        return root !== \"\" ? `${root}.${name}` : name;\n    }\n    addEndpoint(name = \"\", opts) {\n        opts = opts || { subject: name };\n        const args = typeof opts === \"function\"\n            ? { handler: opts, subject: name }\n            : opts;\n        (0, jsutil_1.validateName)(\"endpoint\", name);\n        let { subject, handler, metadata, queue } = args;\n        subject = subject || name;\n        queue = queue || this.queue;\n        validSubjectName(\"endpoint subject\", subject);\n        subject = this.calcSubject(this.subject, subject);\n        const ne = { name, subject, queue, handler, metadata };\n        return this.srv._addEndpoint(ne);\n    }\n    addGroup(name = \"\", queue = \"\") {\n        return new ServiceGroupImpl(this, name, queue);\n    }\n}\nexports.ServiceGroupImpl = ServiceGroupImpl;\nfunction validSubjectName(context, subj) {\n    if (subj === \"\") {\n        throw new Error(`${context} cannot be empty`);\n    }\n    if (subj.indexOf(\" \") !== -1) {\n        throw new Error(`${context} cannot contain spaces: '${subj}'`);\n    }\n    const tokens = subj.split(\".\");\n    tokens.forEach((v, idx) => {\n        if (v === \">\" && idx !== tokens.length - 1) {\n            throw new Error(`${context} cannot have internal '>': '${subj}'`);\n        }\n    });\n}\nfunction validInternalToken(context, subj) {\n    if (subj.indexOf(\" \") !== -1) {\n        throw new Error(`${context} cannot contain spaces: '${subj}'`);\n    }\n    const tokens = subj.split(\".\");\n    tokens.forEach((v) => {\n        if (v === \">\") {\n            throw new Error(`${context} name cannot contain internal '>': '${subj}'`);\n        }\n    });\n}\nclass ServiceImpl {\n    /**\n     * @param verb\n     * @param name\n     * @param id\n     * @param prefix - this is only supplied by tooling when building control subject that crosses an account\n     */\n    static controlSubject(verb, name = \"\", id = \"\", prefix) {\n        // the prefix is used as is, because it is an\n        // account boundary permission\n        const pre = prefix !== null && prefix !== void 0 ? prefix : exports.ServiceApiPrefix;\n        if (name === \"\" && id === \"\") {\n            return `${pre}.${verb}`;\n        }\n        (0, jsutil_1.validateName)(\"control subject name\", name);\n        if (id !== \"\") {\n            (0, jsutil_1.validateName)(\"control subject id\", id);\n            return `${pre}.${verb}.${name}.${id}`;\n        }\n        return `${pre}.${verb}.${name}`;\n    }\n    constructor(nc, config = { name: \"\", version: \"\" }) {\n        this.nc = nc;\n        this.config = Object.assign({}, config);\n        if (!this.config.queue) {\n            this.config.queue = \"q\";\n        }\n        // this will throw if no name\n        (0, jsutil_1.validateName)(\"name\", this.config.name);\n        (0, jsutil_1.validateName)(\"queue\", this.config.queue);\n        // this will throw if not semver\n        (0, semver_1.parseSemVer)(this.config.version);\n        this._id = nuid_1.nuid.next();\n        this.internal = [];\n        this._done = (0, util_1.deferred)();\n        this._stopped = false;\n        this.handlers = [];\n        this.started = new Date().toISOString();\n        // initialize the stats\n        this.reset();\n        // close if the connection closes\n        this.nc.closed()\n            .then(() => {\n            this.close().catch();\n        })\n            .catch((err) => {\n            this.close(err).catch();\n        });\n    }\n    get subjects() {\n        return this.handlers.filter((s) => {\n            return s.internal === false;\n        }).map((s) => {\n            return s.subject;\n        });\n    }\n    get id() {\n        return this._id;\n    }\n    get name() {\n        return this.config.name;\n    }\n    get description() {\n        var _a;\n        return (_a = this.config.description) !== null && _a !== void 0 ? _a : \"\";\n    }\n    get version() {\n        return this.config.version;\n    }\n    get metadata() {\n        return this.config.metadata;\n    }\n    errorToHeader(err) {\n        const h = (0, headers_1.headers)();\n        if (err instanceof core_1.ServiceError) {\n            const se = err;\n            h.set(core_1.ServiceErrorHeader, se.message);\n            h.set(core_1.ServiceErrorCodeHeader, `${se.code}`);\n        }\n        else {\n            h.set(core_1.ServiceErrorHeader, err.message);\n            h.set(core_1.ServiceErrorCodeHeader, \"500\");\n        }\n        return h;\n    }\n    setupHandler(h, internal = false) {\n        // internals don't use a queue\n        const queue = internal ? \"\" : (h.queue ? h.queue : this.config.queue);\n        const { name, subject, handler } = h;\n        const sv = h;\n        sv.internal = internal;\n        if (internal) {\n            this.internal.push(sv);\n        }\n        sv.stats = new NamedEndpointStatsImpl(name, subject, queue);\n        sv.queue = queue;\n        const callback = handler\n            ? (err, msg) => {\n                if (err) {\n                    this.close(err);\n                    return;\n                }\n                const start = Date.now();\n                try {\n                    handler(err, new ServiceMsgImpl(msg));\n                }\n                catch (err) {\n                    sv.stats.countError(err);\n                    msg === null || msg === void 0 ? void 0 : msg.respond(encoders_1.Empty, { headers: this.errorToHeader(err) });\n                }\n                finally {\n                    sv.stats.countLatency(start);\n                }\n            }\n            : undefined;\n        sv.sub = this.nc.subscribe(subject, {\n            callback,\n            queue,\n        });\n        sv.sub.closed\n            .then(() => {\n            if (!this._stopped) {\n                this.close(new Error(`required subscription ${h.subject} stopped`))\n                    .catch();\n            }\n        })\n            .catch((err) => {\n            if (!this._stopped) {\n                const ne = new Error(`required subscription ${h.subject} errored: ${err.message}`);\n                ne.stack = err.stack;\n                this.close(ne).catch();\n            }\n        });\n        return sv;\n    }\n    info() {\n        return {\n            type: core_1.ServiceResponseType.INFO,\n            name: this.name,\n            id: this.id,\n            version: this.version,\n            description: this.description,\n            metadata: this.metadata,\n            endpoints: this.endpoints(),\n        };\n    }\n    endpoints() {\n        return this.handlers.map((v) => {\n            const { subject, metadata, name, queue } = v;\n            return { subject, metadata, name, queue_group: queue };\n        });\n    }\n    stats() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const endpoints = [];\n            for (const h of this.handlers) {\n                if (typeof this.config.statsHandler === \"function\") {\n                    try {\n                        h.stats.data = yield this.config.statsHandler(h);\n                    }\n                    catch (err) {\n                        h.stats.countError(err);\n                    }\n                }\n                endpoints.push(h.stats.stats(h.qi));\n            }\n            return {\n                type: core_1.ServiceResponseType.STATS,\n                name: this.name,\n                id: this.id,\n                version: this.version,\n                started: this.started,\n                metadata: this.metadata,\n                endpoints,\n            };\n        });\n    }\n    addInternalHandler(verb, handler) {\n        const v = `${verb}`.toUpperCase();\n        this._doAddInternalHandler(`${v}-all`, verb, handler);\n        this._doAddInternalHandler(`${v}-kind`, verb, handler, this.name);\n        this._doAddInternalHandler(`${v}`, verb, handler, this.name, this.id);\n    }\n    _doAddInternalHandler(name, verb, handler, kind = \"\", id = \"\") {\n        const endpoint = {};\n        endpoint.name = name;\n        endpoint.subject = ServiceImpl.controlSubject(verb, kind, id);\n        endpoint.handler = handler;\n        this.setupHandler(endpoint, true);\n    }\n    start() {\n        const jc = (0, codec_1.JSONCodec)();\n        const statsHandler = (err, msg) => {\n            if (err) {\n                this.close(err);\n                return Promise.reject(err);\n            }\n            return this.stats().then((s) => {\n                msg === null || msg === void 0 ? void 0 : msg.respond(jc.encode(s));\n                return Promise.resolve();\n            });\n        };\n        const infoHandler = (err, msg) => {\n            if (err) {\n                this.close(err);\n                return Promise.reject(err);\n            }\n            msg === null || msg === void 0 ? void 0 : msg.respond(jc.encode(this.info()));\n            return Promise.resolve();\n        };\n        const ping = jc.encode(this.ping());\n        const pingHandler = (err, msg) => {\n            if (err) {\n                this.close(err).then().catch();\n                return Promise.reject(err);\n            }\n            msg.respond(ping);\n            return Promise.resolve();\n        };\n        this.addInternalHandler(core_1.ServiceVerb.PING, pingHandler);\n        this.addInternalHandler(core_1.ServiceVerb.STATS, statsHandler);\n        this.addInternalHandler(core_1.ServiceVerb.INFO, infoHandler);\n        // now the actual service\n        this.handlers.forEach((h) => {\n            const { subject } = h;\n            if (typeof subject !== \"string\") {\n                return;\n            }\n            // this is expected in cases where main subject is just\n            // a root subject for multiple endpoints - user can disable\n            // listening to the root endpoint, by specifying null\n            if (h.handler === null) {\n                return;\n            }\n            this.setupHandler(h);\n        });\n        return Promise.resolve(this);\n    }\n    close(err) {\n        if (this._stopped) {\n            return this._done;\n        }\n        this._stopped = true;\n        let buf = [];\n        if (!this.nc.isClosed()) {\n            buf = this.handlers.concat(this.internal).map((h) => {\n                return h.sub.drain();\n            });\n        }\n        Promise.allSettled(buf)\n            .then(() => {\n            this._done.resolve(err ? err : null);\n        });\n        return this._done;\n    }\n    get stopped() {\n        return this._done;\n    }\n    get isStopped() {\n        return this._stopped;\n    }\n    stop(err) {\n        return this.close(err);\n    }\n    ping() {\n        return {\n            type: core_1.ServiceResponseType.PING,\n            name: this.name,\n            id: this.id,\n            version: this.version,\n            metadata: this.metadata,\n        };\n    }\n    reset() {\n        // pretend we restarted\n        this.started = new Date().toISOString();\n        if (this.handlers) {\n            for (const h of this.handlers) {\n                h.stats.reset(h.qi);\n            }\n        }\n    }\n    addGroup(name, queue) {\n        return new ServiceGroupImpl(this, name, queue);\n    }\n    addEndpoint(name, handler) {\n        const sg = new ServiceGroupImpl(this);\n        return sg.addEndpoint(name, handler);\n    }\n    _addEndpoint(e) {\n        const qi = new queued_iterator_1.QueuedIteratorImpl();\n        qi.noIterator = typeof e.handler === \"function\";\n        if (!qi.noIterator) {\n            e.handler = (err, msg) => {\n                err ? this.stop(err).catch() : qi.push(new ServiceMsgImpl(msg));\n            };\n            // close the service if the iterator closes\n            qi.iterClosed.then(() => {\n                this.close().catch();\n            });\n        }\n        // track the iterator for stats\n        const ss = this.setupHandler(e, false);\n        ss.qi = qi;\n        this.handlers.push(ss);\n        return qi;\n    }\n}\nexports.ServiceImpl = ServiceImpl;\nclass NamedEndpointStatsImpl {\n    constructor(name, subject, queue = \"\") {\n        this.name = name;\n        this.subject = subject;\n        this.average_processing_time = 0;\n        this.num_errors = 0;\n        this.num_requests = 0;\n        this.processing_time = 0;\n        this.queue = queue;\n    }\n    reset(qi) {\n        this.num_requests = 0;\n        this.processing_time = 0;\n        this.average_processing_time = 0;\n        this.num_errors = 0;\n        this.last_error = undefined;\n        this.data = undefined;\n        const qii = qi;\n        if (qii) {\n            qii.time = 0;\n            qii.processed = 0;\n        }\n    }\n    countLatency(start) {\n        this.num_requests++;\n        this.processing_time += (0, jsutil_1.nanos)(Date.now() - start);\n        this.average_processing_time = Math.round(this.processing_time / this.num_requests);\n    }\n    countError(err) {\n        this.num_errors++;\n        this.last_error = err.message;\n    }\n    _stats() {\n        const { name, subject, average_processing_time, num_errors, num_requests, processing_time, last_error, data, queue, } = this;\n        return {\n            name,\n            subject,\n            average_processing_time,\n            num_errors,\n            num_requests,\n            processing_time,\n            last_error,\n            data,\n            queue_group: queue,\n        };\n    }\n    stats(qi) {\n        const qii = qi;\n        if ((qii === null || qii === void 0 ? void 0 : qii.noIterator) === false) {\n            // grab stats in the iterator\n            this.processing_time = qii.time;\n            this.num_requests = qii.processed;\n            this.average_processing_time =\n                this.processing_time > 0 && this.num_requests > 0\n                    ? this.processing_time / this.num_requests\n                    : 0;\n        }\n        return this._stats();\n    }\n}\n//# sourceMappingURL=service.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9zZXJ2aWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyx3QkFBd0IsR0FBRyxzQkFBc0IsR0FBRyx3QkFBd0I7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzRUFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBVztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBUztBQUNqQyxlQUFlLG1CQUFPLENBQUMsc0VBQVE7QUFDL0IsMEJBQTBCLG1CQUFPLENBQUMsNEZBQW1CO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLDhFQUFxQjtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQywwRUFBVTtBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBWTtBQUN2QyxlQUFlLG1CQUFPLENBQUMsc0VBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsS0FBSztBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhHQUE4RztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L3NlcnZpY2UuanM/NTUzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2aWNlSW1wbCA9IGV4cG9ydHMuU2VydmljZUdyb3VwSW1wbCA9IGV4cG9ydHMuU2VydmljZU1zZ0ltcGwgPSBleHBvcnRzLlNlcnZpY2VBcGlQcmVmaXggPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IDIwMjItMjAyMyBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IGhlYWRlcnNfMSA9IHJlcXVpcmUoXCIuL2hlYWRlcnNcIik7XG5jb25zdCBjb2RlY18xID0gcmVxdWlyZShcIi4vY29kZWNcIik7XG5jb25zdCBudWlkXzEgPSByZXF1aXJlKFwiLi9udWlkXCIpO1xuY29uc3QgcXVldWVkX2l0ZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9xdWV1ZWRfaXRlcmF0b3JcIik7XG5jb25zdCBqc3V0aWxfMSA9IHJlcXVpcmUoXCIuLi9qZXRzdHJlYW0vanN1dGlsXCIpO1xuY29uc3Qgc2VtdmVyXzEgPSByZXF1aXJlKFwiLi9zZW12ZXJcIik7XG5jb25zdCBlbmNvZGVyc18xID0gcmVxdWlyZShcIi4vZW5jb2RlcnNcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuLyoqXG4gKiBTZXJ2aWNlcyBoYXZlIGNvbW1vbiBiYWNrcGxhbmUgc3ViamVjdCBwYXR0ZXJuOlxuICpcbiAqIGAkU1JWLlBJTkd8U1RBVFN8SU5GT2AgLSBwaW5ncyBvciByZXRyaWV2ZXMgc3RhdHVzIGZvciBhbGwgc2VydmljZXNcbiAqIGAkU1JWLlBJTkd8U1RBVFN8SU5GTy48bmFtZT5gIC0gcGluZ3Mgb3IgcmV0cmlldmVzIHN0YXR1cyBmb3IgYWxsIHNlcnZpY2VzIGhhdmluZyB0aGUgc3BlY2lmaWVkIG5hbWVcbiAqIGAkU1JWLlBJTkd8U1RBVFN8SU5GTy48bmFtZT4uPGlkPmAgLSBwaW5ncyBvciByZXRyaWV2ZXMgc3RhdHVzIG9mIGEgcGFydGljdWxhciBzZXJ2aWNlXG4gKlxuICogTm90ZSB0aGF0IDxuYW1lPiBhbmQgPGlkPiBhcmUgdXBwZXItY2FzZWQuXG4gKi9cbmV4cG9ydHMuU2VydmljZUFwaVByZWZpeCA9IFwiJFNSVlwiO1xuY2xhc3MgU2VydmljZU1zZ0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICB0aGlzLm1zZyA9IG1zZztcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5kYXRhO1xuICAgIH1cbiAgICBnZXQgc2lkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuc2lkO1xuICAgIH1cbiAgICBnZXQgc3ViamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLnN1YmplY3Q7XG4gICAgfVxuICAgIGdldCByZXBseSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLnJlcGx5IHx8IFwiXCI7XG4gICAgfVxuICAgIGdldCBoZWFkZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuaGVhZGVycztcbiAgICB9XG4gICAgcmVzcG9uZChkYXRhLCBvcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1zZy5yZXNwb25kKGRhdGEsIG9wdHMpO1xuICAgIH1cbiAgICByZXNwb25kRXJyb3IoY29kZSwgZGVzY3JpcHRpb24sIGRhdGEsIG9wdHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMuaGVhZGVycyA9IG9wdHMuaGVhZGVycyB8fCAoMCwgaGVhZGVyc18xLmhlYWRlcnMpKCk7XG4gICAgICAgIChfYSA9IG9wdHMuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldChjb3JlXzEuU2VydmljZUVycm9yQ29kZUhlYWRlciwgYCR7Y29kZX1gKTtcbiAgICAgICAgKF9iID0gb3B0cy5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2V0KGNvcmVfMS5TZXJ2aWNlRXJyb3JIZWFkZXIsIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXNnLnJlc3BvbmQoZGF0YSwgb3B0cyk7XG4gICAgfVxuICAgIGpzb24ocmV2aXZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuanNvbihyZXZpdmVyKTtcbiAgICB9XG4gICAgc3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tc2cuc3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2aWNlTXNnSW1wbCA9IFNlcnZpY2VNc2dJbXBsO1xuY2xhc3MgU2VydmljZUdyb3VwSW1wbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBuYW1lID0gXCJcIiwgcXVldWUgPSBcIlwiKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB2YWxpZEludGVybmFsVG9rZW4oXCJzZXJ2aWNlIGdyb3VwXCIsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByb290ID0gXCJcIjtcbiAgICAgICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFNlcnZpY2VJbXBsKSB7XG4gICAgICAgICAgICB0aGlzLnNydiA9IHBhcmVudDtcbiAgICAgICAgICAgIHJvb3QgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcmVudCBpbnN0YW5jZW9mIFNlcnZpY2VHcm91cEltcGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHNnID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5zcnYgPSBzZy5zcnY7XG4gICAgICAgICAgICBpZiAocXVldWUgPT09IFwiXCIgJiYgc2cucXVldWUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZSA9IHNnLnF1ZXVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdCA9IHNnLnN1YmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIFNlcnZpY2VHcm91cCB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViamVjdCA9IHRoaXMuY2FsY1N1YmplY3Qocm9vdCwgbmFtZSk7XG4gICAgICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICB9XG4gICAgY2FsY1N1YmplY3Qocm9vdCwgbmFtZSA9IFwiXCIpIHtcbiAgICAgICAgaWYgKG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb290ICE9PSBcIlwiID8gYCR7cm9vdH0uJHtuYW1lfWAgOiBuYW1lO1xuICAgIH1cbiAgICBhZGRFbmRwb2ludChuYW1lID0gXCJcIiwgb3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7IHN1YmplY3Q6IG5hbWUgfTtcbiAgICAgICAgY29uc3QgYXJncyA9IHR5cGVvZiBvcHRzID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8geyBoYW5kbGVyOiBvcHRzLCBzdWJqZWN0OiBuYW1lIH1cbiAgICAgICAgICAgIDogb3B0cztcbiAgICAgICAgKDAsIGpzdXRpbF8xLnZhbGlkYXRlTmFtZSkoXCJlbmRwb2ludFwiLCBuYW1lKTtcbiAgICAgICAgbGV0IHsgc3ViamVjdCwgaGFuZGxlciwgbWV0YWRhdGEsIHF1ZXVlIH0gPSBhcmdzO1xuICAgICAgICBzdWJqZWN0ID0gc3ViamVjdCB8fCBuYW1lO1xuICAgICAgICBxdWV1ZSA9IHF1ZXVlIHx8IHRoaXMucXVldWU7XG4gICAgICAgIHZhbGlkU3ViamVjdE5hbWUoXCJlbmRwb2ludCBzdWJqZWN0XCIsIHN1YmplY3QpO1xuICAgICAgICBzdWJqZWN0ID0gdGhpcy5jYWxjU3ViamVjdCh0aGlzLnN1YmplY3QsIHN1YmplY3QpO1xuICAgICAgICBjb25zdCBuZSA9IHsgbmFtZSwgc3ViamVjdCwgcXVldWUsIGhhbmRsZXIsIG1ldGFkYXRhIH07XG4gICAgICAgIHJldHVybiB0aGlzLnNydi5fYWRkRW5kcG9pbnQobmUpO1xuICAgIH1cbiAgICBhZGRHcm91cChuYW1lID0gXCJcIiwgcXVldWUgPSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VydmljZUdyb3VwSW1wbCh0aGlzLCBuYW1lLCBxdWV1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2aWNlR3JvdXBJbXBsID0gU2VydmljZUdyb3VwSW1wbDtcbmZ1bmN0aW9uIHZhbGlkU3ViamVjdE5hbWUoY29udGV4dCwgc3Viaikge1xuICAgIGlmIChzdWJqID09PSBcIlwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fSBjYW5ub3QgYmUgZW1wdHlgKTtcbiAgICB9XG4gICAgaWYgKHN1YmouaW5kZXhPZihcIiBcIikgIT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb250ZXh0fSBjYW5ub3QgY29udGFpbiBzcGFjZXM6ICcke3N1Ymp9J2ApO1xuICAgIH1cbiAgICBjb25zdCB0b2tlbnMgPSBzdWJqLnNwbGl0KFwiLlwiKTtcbiAgICB0b2tlbnMuZm9yRWFjaCgodiwgaWR4KSA9PiB7XG4gICAgICAgIGlmICh2ID09PSBcIj5cIiAmJiBpZHggIT09IHRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29udGV4dH0gY2Fubm90IGhhdmUgaW50ZXJuYWwgJz4nOiAnJHtzdWJqfSdgKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gdmFsaWRJbnRlcm5hbFRva2VuKGNvbnRleHQsIHN1YmopIHtcbiAgICBpZiAoc3Viai5pbmRleE9mKFwiIFwiKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9IGNhbm5vdCBjb250YWluIHNwYWNlczogJyR7c3Vian0nYCk7XG4gICAgfVxuICAgIGNvbnN0IHRva2VucyA9IHN1Ymouc3BsaXQoXCIuXCIpO1xuICAgIHRva2Vucy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIGlmICh2ID09PSBcIj5cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbnRleHR9IG5hbWUgY2Fubm90IGNvbnRhaW4gaW50ZXJuYWwgJz4nOiAnJHtzdWJqfSdgKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuY2xhc3MgU2VydmljZUltcGwge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2ZXJiXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcGFyYW0gaWRcbiAgICAgKiBAcGFyYW0gcHJlZml4IC0gdGhpcyBpcyBvbmx5IHN1cHBsaWVkIGJ5IHRvb2xpbmcgd2hlbiBidWlsZGluZyBjb250cm9sIHN1YmplY3QgdGhhdCBjcm9zc2VzIGFuIGFjY291bnRcbiAgICAgKi9cbiAgICBzdGF0aWMgY29udHJvbFN1YmplY3QodmVyYiwgbmFtZSA9IFwiXCIsIGlkID0gXCJcIiwgcHJlZml4KSB7XG4gICAgICAgIC8vIHRoZSBwcmVmaXggaXMgdXNlZCBhcyBpcywgYmVjYXVzZSBpdCBpcyBhblxuICAgICAgICAvLyBhY2NvdW50IGJvdW5kYXJ5IHBlcm1pc3Npb25cbiAgICAgICAgY29uc3QgcHJlID0gcHJlZml4ICE9PSBudWxsICYmIHByZWZpeCAhPT0gdm9pZCAwID8gcHJlZml4IDogZXhwb3J0cy5TZXJ2aWNlQXBpUHJlZml4O1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJcIiAmJiBpZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgcmV0dXJuIGAke3ByZX0uJHt2ZXJifWA7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIGpzdXRpbF8xLnZhbGlkYXRlTmFtZSkoXCJjb250cm9sIHN1YmplY3QgbmFtZVwiLCBuYW1lKTtcbiAgICAgICAgaWYgKGlkICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAoMCwganN1dGlsXzEudmFsaWRhdGVOYW1lKShcImNvbnRyb2wgc3ViamVjdCBpZFwiLCBpZCk7XG4gICAgICAgICAgICByZXR1cm4gYCR7cHJlfS4ke3ZlcmJ9LiR7bmFtZX0uJHtpZH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtwcmV9LiR7dmVyYn0uJHtuYW1lfWA7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG5jLCBjb25maWcgPSB7IG5hbWU6IFwiXCIsIHZlcnNpb246IFwiXCIgfSkge1xuICAgICAgICB0aGlzLm5jID0gbmM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5xdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcucXVldWUgPSBcInFcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgaWYgbm8gbmFtZVxuICAgICAgICAoMCwganN1dGlsXzEudmFsaWRhdGVOYW1lKShcIm5hbWVcIiwgdGhpcy5jb25maWcubmFtZSk7XG4gICAgICAgICgwLCBqc3V0aWxfMS52YWxpZGF0ZU5hbWUpKFwicXVldWVcIiwgdGhpcy5jb25maWcucXVldWUpO1xuICAgICAgICAvLyB0aGlzIHdpbGwgdGhyb3cgaWYgbm90IHNlbXZlclxuICAgICAgICAoMCwgc2VtdmVyXzEucGFyc2VTZW1WZXIpKHRoaXMuY29uZmlnLnZlcnNpb24pO1xuICAgICAgICB0aGlzLl9pZCA9IG51aWRfMS5udWlkLm5leHQoKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbCA9IFtdO1xuICAgICAgICB0aGlzLl9kb25lID0gKDAsIHV0aWxfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSB0aGUgc3RhdHNcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAvLyBjbG9zZSBpZiB0aGUgY29ubmVjdGlvbiBjbG9zZXNcbiAgICAgICAgdGhpcy5uYy5jbG9zZWQoKVxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpLmNhdGNoKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbG9zZShlcnIpLmNhdGNoKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgc3ViamVjdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXJzLmZpbHRlcigocykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHMuaW50ZXJuYWwgPT09IGZhbHNlO1xuICAgICAgICB9KS5tYXAoKHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzLnN1YmplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5uYW1lO1xuICAgIH1cbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY29uZmlnLmRlc2NyaXB0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBcIlwiO1xuICAgIH1cbiAgICBnZXQgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnZlcnNpb247XG4gICAgfVxuICAgIGdldCBtZXRhZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLm1ldGFkYXRhO1xuICAgIH1cbiAgICBlcnJvclRvSGVhZGVyKGVycikge1xuICAgICAgICBjb25zdCBoID0gKDAsIGhlYWRlcnNfMS5oZWFkZXJzKSgpO1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgY29yZV8xLlNlcnZpY2VFcnJvcikge1xuICAgICAgICAgICAgY29uc3Qgc2UgPSBlcnI7XG4gICAgICAgICAgICBoLnNldChjb3JlXzEuU2VydmljZUVycm9ySGVhZGVyLCBzZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIGguc2V0KGNvcmVfMS5TZXJ2aWNlRXJyb3JDb2RlSGVhZGVyLCBgJHtzZS5jb2RlfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaC5zZXQoY29yZV8xLlNlcnZpY2VFcnJvckhlYWRlciwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgaC5zZXQoY29yZV8xLlNlcnZpY2VFcnJvckNvZGVIZWFkZXIsIFwiNTAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoO1xuICAgIH1cbiAgICBzZXR1cEhhbmRsZXIoaCwgaW50ZXJuYWwgPSBmYWxzZSkge1xuICAgICAgICAvLyBpbnRlcm5hbHMgZG9uJ3QgdXNlIGEgcXVldWVcbiAgICAgICAgY29uc3QgcXVldWUgPSBpbnRlcm5hbCA/IFwiXCIgOiAoaC5xdWV1ZSA/IGgucXVldWUgOiB0aGlzLmNvbmZpZy5xdWV1ZSk7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgc3ViamVjdCwgaGFuZGxlciB9ID0gaDtcbiAgICAgICAgY29uc3Qgc3YgPSBoO1xuICAgICAgICBzdi5pbnRlcm5hbCA9IGludGVybmFsO1xuICAgICAgICBpZiAoaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWwucHVzaChzdik7XG4gICAgICAgIH1cbiAgICAgICAgc3Yuc3RhdHMgPSBuZXcgTmFtZWRFbmRwb2ludFN0YXRzSW1wbChuYW1lLCBzdWJqZWN0LCBxdWV1ZSk7XG4gICAgICAgIHN2LnF1ZXVlID0gcXVldWU7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gaGFuZGxlclxuICAgICAgICAgICAgPyAoZXJyLCBtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihlcnIsIG5ldyBTZXJ2aWNlTXNnSW1wbChtc2cpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzdi5zdGF0cy5jb3VudEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9PT0gbnVsbCB8fCBtc2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1zZy5yZXNwb25kKGVuY29kZXJzXzEuRW1wdHksIHsgaGVhZGVyczogdGhpcy5lcnJvclRvSGVhZGVyKGVycikgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBzdi5zdGF0cy5jb3VudExhdGVuY3koc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBzdi5zdWIgPSB0aGlzLm5jLnN1YnNjcmliZShzdWJqZWN0LCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIHF1ZXVlLFxuICAgICAgICB9KTtcbiAgICAgICAgc3Yuc3ViLmNsb3NlZFxuICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZShuZXcgRXJyb3IoYHJlcXVpcmVkIHN1YnNjcmlwdGlvbiAke2guc3ViamVjdH0gc3RvcHBlZGApKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3N0b3BwZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZSA9IG5ldyBFcnJvcihgcmVxdWlyZWQgc3Vic2NyaXB0aW9uICR7aC5zdWJqZWN0fSBlcnJvcmVkOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgIG5lLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UobmUpLmNhdGNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3Y7XG4gICAgfVxuICAgIGluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBjb3JlXzEuU2VydmljZVJlc3BvbnNlVHlwZS5JTkZPLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgICAgZW5kcG9pbnRzOiB0aGlzLmVuZHBvaW50cygpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbmRwb2ludHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXJzLm1hcCgodikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzdWJqZWN0LCBtZXRhZGF0YSwgbmFtZSwgcXVldWUgfSA9IHY7XG4gICAgICAgICAgICByZXR1cm4geyBzdWJqZWN0LCBtZXRhZGF0YSwgbmFtZSwgcXVldWVfZ3JvdXA6IHF1ZXVlIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBoIG9mIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY29uZmlnLnN0YXRzSGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoLnN0YXRzLmRhdGEgPSB5aWVsZCB0aGlzLmNvbmZpZy5zdGF0c0hhbmRsZXIoaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaC5zdGF0cy5jb3VudEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5kcG9pbnRzLnB1c2goaC5zdGF0cy5zdGF0cyhoLnFpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IGNvcmVfMS5TZXJ2aWNlUmVzcG9uc2VUeXBlLlNUQVRTLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgc3RhcnRlZDogdGhpcy5zdGFydGVkLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGVuZHBvaW50cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRJbnRlcm5hbEhhbmRsZXIodmVyYiwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCB2ID0gYCR7dmVyYn1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuX2RvQWRkSW50ZXJuYWxIYW5kbGVyKGAke3Z9LWFsbGAsIHZlcmIsIGhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9kb0FkZEludGVybmFsSGFuZGxlcihgJHt2fS1raW5kYCwgdmVyYiwgaGFuZGxlciwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhpcy5fZG9BZGRJbnRlcm5hbEhhbmRsZXIoYCR7dn1gLCB2ZXJiLCBoYW5kbGVyLCB0aGlzLm5hbWUsIHRoaXMuaWQpO1xuICAgIH1cbiAgICBfZG9BZGRJbnRlcm5hbEhhbmRsZXIobmFtZSwgdmVyYiwgaGFuZGxlciwga2luZCA9IFwiXCIsIGlkID0gXCJcIikge1xuICAgICAgICBjb25zdCBlbmRwb2ludCA9IHt9O1xuICAgICAgICBlbmRwb2ludC5uYW1lID0gbmFtZTtcbiAgICAgICAgZW5kcG9pbnQuc3ViamVjdCA9IFNlcnZpY2VJbXBsLmNvbnRyb2xTdWJqZWN0KHZlcmIsIGtpbmQsIGlkKTtcbiAgICAgICAgZW5kcG9pbnQuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMuc2V0dXBIYW5kbGVyKGVuZHBvaW50LCB0cnVlKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IGpjID0gKDAsIGNvZGVjXzEuSlNPTkNvZGVjKSgpO1xuICAgICAgICBjb25zdCBzdGF0c0hhbmRsZXIgPSAoZXJyLCBtc2cpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0cygpLnRoZW4oKHMpID0+IHtcbiAgICAgICAgICAgICAgICBtc2cgPT09IG51bGwgfHwgbXNnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtc2cucmVzcG9uZChqYy5lbmNvZGUocykpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbmZvSGFuZGxlciA9IChlcnIsIG1zZykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1zZyA9PT0gbnVsbCB8fCBtc2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1zZy5yZXNwb25kKGpjLmVuY29kZSh0aGlzLmluZm8oKSkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwaW5nID0gamMuZW5jb2RlKHRoaXMucGluZygpKTtcbiAgICAgICAgY29uc3QgcGluZ0hhbmRsZXIgPSAoZXJyLCBtc2cpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKGVycikudGhlbigpLmNhdGNoKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtc2cucmVzcG9uZChwaW5nKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEhhbmRsZXIoY29yZV8xLlNlcnZpY2VWZXJiLlBJTkcsIHBpbmdIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5hZGRJbnRlcm5hbEhhbmRsZXIoY29yZV8xLlNlcnZpY2VWZXJiLlNUQVRTLCBzdGF0c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmFkZEludGVybmFsSGFuZGxlcihjb3JlXzEuU2VydmljZVZlcmIuSU5GTywgaW5mb0hhbmRsZXIpO1xuICAgICAgICAvLyBub3cgdGhlIGFjdHVhbCBzZXJ2aWNlXG4gICAgICAgIHRoaXMuaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzdWJqZWN0IH0gPSBoO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdWJqZWN0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBleHBlY3RlZCBpbiBjYXNlcyB3aGVyZSBtYWluIHN1YmplY3QgaXMganVzdFxuICAgICAgICAgICAgLy8gYSByb290IHN1YmplY3QgZm9yIG11bHRpcGxlIGVuZHBvaW50cyAtIHVzZXIgY2FuIGRpc2FibGVcbiAgICAgICAgICAgIC8vIGxpc3RlbmluZyB0byB0aGUgcm9vdCBlbmRwb2ludCwgYnkgc3BlY2lmeWluZyBudWxsXG4gICAgICAgICAgICBpZiAoaC5oYW5kbGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXR1cEhhbmRsZXIoaCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xuICAgIH1cbiAgICBjbG9zZShlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0b3BwZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb25lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBsZXQgYnVmID0gW107XG4gICAgICAgIGlmICghdGhpcy5uYy5pc0Nsb3NlZCgpKSB7XG4gICAgICAgICAgICBidWYgPSB0aGlzLmhhbmRsZXJzLmNvbmNhdCh0aGlzLmludGVybmFsKS5tYXAoKGgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaC5zdWIuZHJhaW4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFByb21pc2UuYWxsU2V0dGxlZChidWYpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9kb25lLnJlc29sdmUoZXJyID8gZXJyIDogbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fZG9uZTtcbiAgICB9XG4gICAgZ2V0IHN0b3BwZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb25lO1xuICAgIH1cbiAgICBnZXQgaXNTdG9wcGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcbiAgICB9XG4gICAgc3RvcChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2UoZXJyKTtcbiAgICB9XG4gICAgcGluZygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IGNvcmVfMS5TZXJ2aWNlUmVzcG9uc2VUeXBlLlBJTkcsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHZlcnNpb246IHRoaXMudmVyc2lvbixcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgLy8gcHJldGVuZCB3ZSByZXN0YXJ0ZWRcbiAgICAgICAgdGhpcy5zdGFydGVkID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5oYW5kbGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBoIG9mIHRoaXMuaGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBoLnN0YXRzLnJlc2V0KGgucWkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEdyb3VwKG5hbWUsIHF1ZXVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VydmljZUdyb3VwSW1wbCh0aGlzLCBuYW1lLCBxdWV1ZSk7XG4gICAgfVxuICAgIGFkZEVuZHBvaW50KG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBuZXcgU2VydmljZUdyb3VwSW1wbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNnLmFkZEVuZHBvaW50KG5hbWUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICBfYWRkRW5kcG9pbnQoZSkge1xuICAgICAgICBjb25zdCBxaSA9IG5ldyBxdWV1ZWRfaXRlcmF0b3JfMS5RdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgcWkubm9JdGVyYXRvciA9IHR5cGVvZiBlLmhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIjtcbiAgICAgICAgaWYgKCFxaS5ub0l0ZXJhdG9yKSB7XG4gICAgICAgICAgICBlLmhhbmRsZXIgPSAoZXJyLCBtc2cpID0+IHtcbiAgICAgICAgICAgICAgICBlcnIgPyB0aGlzLnN0b3AoZXJyKS5jYXRjaCgpIDogcWkucHVzaChuZXcgU2VydmljZU1zZ0ltcGwobXNnKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gY2xvc2UgdGhlIHNlcnZpY2UgaWYgdGhlIGl0ZXJhdG9yIGNsb3Nlc1xuICAgICAgICAgICAgcWkuaXRlckNsb3NlZC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCkuY2F0Y2goKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRyYWNrIHRoZSBpdGVyYXRvciBmb3Igc3RhdHNcbiAgICAgICAgY29uc3Qgc3MgPSB0aGlzLnNldHVwSGFuZGxlcihlLCBmYWxzZSk7XG4gICAgICAgIHNzLnFpID0gcWk7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMucHVzaChzcyk7XG4gICAgICAgIHJldHVybiBxaTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZpY2VJbXBsID0gU2VydmljZUltcGw7XG5jbGFzcyBOYW1lZEVuZHBvaW50U3RhdHNJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBzdWJqZWN0LCBxdWV1ZSA9IFwiXCIpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICAgICAgdGhpcy5hdmVyYWdlX3Byb2Nlc3NpbmdfdGltZSA9IDA7XG4gICAgICAgIHRoaXMubnVtX2Vycm9ycyA9IDA7XG4gICAgICAgIHRoaXMubnVtX3JlcXVlc3RzID0gMDtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nX3RpbWUgPSAwO1xuICAgICAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgfVxuICAgIHJlc2V0KHFpKSB7XG4gICAgICAgIHRoaXMubnVtX3JlcXVlc3RzID0gMDtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nX3RpbWUgPSAwO1xuICAgICAgICB0aGlzLmF2ZXJhZ2VfcHJvY2Vzc2luZ190aW1lID0gMDtcbiAgICAgICAgdGhpcy5udW1fZXJyb3JzID0gMDtcbiAgICAgICAgdGhpcy5sYXN0X2Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHFpaSA9IHFpO1xuICAgICAgICBpZiAocWlpKSB7XG4gICAgICAgICAgICBxaWkudGltZSA9IDA7XG4gICAgICAgICAgICBxaWkucHJvY2Vzc2VkID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb3VudExhdGVuY3koc3RhcnQpIHtcbiAgICAgICAgdGhpcy5udW1fcmVxdWVzdHMrKztcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nX3RpbWUgKz0gKDAsIGpzdXRpbF8xLm5hbm9zKShEYXRlLm5vdygpIC0gc3RhcnQpO1xuICAgICAgICB0aGlzLmF2ZXJhZ2VfcHJvY2Vzc2luZ190aW1lID0gTWF0aC5yb3VuZCh0aGlzLnByb2Nlc3NpbmdfdGltZSAvIHRoaXMubnVtX3JlcXVlc3RzKTtcbiAgICB9XG4gICAgY291bnRFcnJvcihlcnIpIHtcbiAgICAgICAgdGhpcy5udW1fZXJyb3JzKys7XG4gICAgICAgIHRoaXMubGFzdF9lcnJvciA9IGVyci5tZXNzYWdlO1xuICAgIH1cbiAgICBfc3RhdHMoKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgc3ViamVjdCwgYXZlcmFnZV9wcm9jZXNzaW5nX3RpbWUsIG51bV9lcnJvcnMsIG51bV9yZXF1ZXN0cywgcHJvY2Vzc2luZ190aW1lLCBsYXN0X2Vycm9yLCBkYXRhLCBxdWV1ZSwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgc3ViamVjdCxcbiAgICAgICAgICAgIGF2ZXJhZ2VfcHJvY2Vzc2luZ190aW1lLFxuICAgICAgICAgICAgbnVtX2Vycm9ycyxcbiAgICAgICAgICAgIG51bV9yZXF1ZXN0cyxcbiAgICAgICAgICAgIHByb2Nlc3NpbmdfdGltZSxcbiAgICAgICAgICAgIGxhc3RfZXJyb3IsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcXVldWVfZ3JvdXA6IHF1ZXVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0cyhxaSkge1xuICAgICAgICBjb25zdCBxaWkgPSBxaTtcbiAgICAgICAgaWYgKChxaWkgPT09IG51bGwgfHwgcWlpID09PSB2b2lkIDAgPyB2b2lkIDAgOiBxaWkubm9JdGVyYXRvcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBncmFiIHN0YXRzIGluIHRoZSBpdGVyYXRvclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nX3RpbWUgPSBxaWkudGltZTtcbiAgICAgICAgICAgIHRoaXMubnVtX3JlcXVlc3RzID0gcWlpLnByb2Nlc3NlZDtcbiAgICAgICAgICAgIHRoaXMuYXZlcmFnZV9wcm9jZXNzaW5nX3RpbWUgPVxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ190aW1lID4gMCAmJiB0aGlzLm51bV9yZXF1ZXN0cyA+IDBcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnByb2Nlc3NpbmdfdGltZSAvIHRoaXMubnVtX3JlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHMoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2aWNlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/service.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/serviceclient.js":
/*!*****************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/serviceclient.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServiceClientImpl = void 0;\n/*\n * Copyright 2022-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst codec_1 = __webpack_require__(/*! ./codec */ \"(rsc)/./node_modules/nats/lib/nats-base-client/codec.js\");\nconst queued_iterator_1 = __webpack_require__(/*! ./queued_iterator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nconst service_1 = __webpack_require__(/*! ./service */ \"(rsc)/./node_modules/nats/lib/nats-base-client/service.js\");\nconst core_2 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nclass ServiceClientImpl {\n    constructor(nc, opts = {\n        strategy: core_2.RequestStrategy.JitterTimer,\n        maxWait: 2000,\n    }, prefix) {\n        this.nc = nc;\n        this.prefix = prefix;\n        this.opts = opts;\n    }\n    ping(name = \"\", id = \"\") {\n        return this.q(core_1.ServiceVerb.PING, name, id);\n    }\n    stats(name = \"\", id = \"\") {\n        return this.q(core_1.ServiceVerb.STATS, name, id);\n    }\n    info(name = \"\", id = \"\") {\n        return this.q(core_1.ServiceVerb.INFO, name, id);\n    }\n    q(v, name = \"\", id = \"\") {\n        return __awaiter(this, void 0, void 0, function* () {\n            const iter = new queued_iterator_1.QueuedIteratorImpl();\n            const jc = (0, codec_1.JSONCodec)();\n            const subj = service_1.ServiceImpl.controlSubject(v, name, id, this.prefix);\n            const responses = yield this.nc.requestMany(subj, encoders_1.Empty, this.opts);\n            (() => __awaiter(this, void 0, void 0, function* () {\n                var _a, e_1, _b, _c;\n                try {\n                    for (var _d = true, responses_1 = __asyncValues(responses), responses_1_1; responses_1_1 = yield responses_1.next(), _a = responses_1_1.done, !_a; _d = true) {\n                        _c = responses_1_1.value;\n                        _d = false;\n                        const m = _c;\n                        try {\n                            const s = jc.decode(m.data);\n                            iter.push(s);\n                        }\n                        catch (err) {\n                            // @ts-ignore: pushing fn\n                            iter.push(() => {\n                                iter.stop(err);\n                            });\n                        }\n                    }\n                }\n                catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                finally {\n                    try {\n                        if (!_d && !_a && (_b = responses_1.return)) yield _b.call(responses_1);\n                    }\n                    finally { if (e_1) throw e_1.error; }\n                }\n                //@ts-ignore: push a fn\n                iter.push(() => {\n                    iter.stop();\n                });\n            }))().catch((err) => {\n                iter.stop(err);\n            });\n            return iter;\n        });\n    }\n}\nexports.ServiceClientImpl = ServiceClientImpl;\n//# sourceMappingURL=serviceclient.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9zZXJ2aWNlY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsOEVBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsd0VBQVM7QUFDakMsMEJBQTBCLG1CQUFPLENBQUMsNEZBQW1CO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQyxzRUFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQyw0RUFBVztBQUNyQyxlQUFlLG1CQUFPLENBQUMsc0VBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Ysd0VBQXdFO0FBQ3ZLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L3NlcnZpY2VjbGllbnQuanM/NmIxMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fYXN5bmNWYWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNWYWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VydmljZUNsaWVudEltcGwgPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IDIwMjItMjAyMyBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZW5jb2RlcnNfMSA9IHJlcXVpcmUoXCIuL2VuY29kZXJzXCIpO1xuY29uc3QgY29kZWNfMSA9IHJlcXVpcmUoXCIuL2NvZGVjXCIpO1xuY29uc3QgcXVldWVkX2l0ZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9xdWV1ZWRfaXRlcmF0b3JcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuY29uc3Qgc2VydmljZV8xID0gcmVxdWlyZShcIi4vc2VydmljZVwiKTtcbmNvbnN0IGNvcmVfMiA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5jbGFzcyBTZXJ2aWNlQ2xpZW50SW1wbCB7XG4gICAgY29uc3RydWN0b3IobmMsIG9wdHMgPSB7XG4gICAgICAgIHN0cmF0ZWd5OiBjb3JlXzIuUmVxdWVzdFN0cmF0ZWd5LkppdHRlclRpbWVyLFxuICAgICAgICBtYXhXYWl0OiAyMDAwLFxuICAgIH0sIHByZWZpeCkge1xuICAgICAgICB0aGlzLm5jID0gbmM7XG4gICAgICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIH1cbiAgICBwaW5nKG5hbWUgPSBcIlwiLCBpZCA9IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucShjb3JlXzEuU2VydmljZVZlcmIuUElORywgbmFtZSwgaWQpO1xuICAgIH1cbiAgICBzdGF0cyhuYW1lID0gXCJcIiwgaWQgPSBcIlwiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnEoY29yZV8xLlNlcnZpY2VWZXJiLlNUQVRTLCBuYW1lLCBpZCk7XG4gICAgfVxuICAgIGluZm8obmFtZSA9IFwiXCIsIGlkID0gXCJcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5xKGNvcmVfMS5TZXJ2aWNlVmVyYi5JTkZPLCBuYW1lLCBpZCk7XG4gICAgfVxuICAgIHEodiwgbmFtZSA9IFwiXCIsIGlkID0gXCJcIikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaXRlciA9IG5ldyBxdWV1ZWRfaXRlcmF0b3JfMS5RdWV1ZWRJdGVyYXRvckltcGwoKTtcbiAgICAgICAgICAgIGNvbnN0IGpjID0gKDAsIGNvZGVjXzEuSlNPTkNvZGVjKSgpO1xuICAgICAgICAgICAgY29uc3Qgc3ViaiA9IHNlcnZpY2VfMS5TZXJ2aWNlSW1wbC5jb250cm9sU3ViamVjdCh2LCBuYW1lLCBpZCwgdGhpcy5wcmVmaXgpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VzID0geWllbGQgdGhpcy5uYy5yZXF1ZXN0TWFueShzdWJqLCBlbmNvZGVyc18xLkVtcHR5LCB0aGlzLm9wdHMpO1xuICAgICAgICAgICAgKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9kID0gdHJ1ZSwgcmVzcG9uc2VzXzEgPSBfX2FzeW5jVmFsdWVzKHJlc3BvbnNlcyksIHJlc3BvbnNlc18xXzE7IHJlc3BvbnNlc18xXzEgPSB5aWVsZCByZXNwb25zZXNfMS5uZXh0KCksIF9hID0gcmVzcG9uc2VzXzFfMS5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSByZXNwb25zZXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG0gPSBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IGpjLmRlY29kZShtLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXIucHVzaChzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlOiBwdXNoaW5nIGZuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlci5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlci5zdG9wKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IHJlc3BvbnNlc18xLnJldHVybikpIHlpZWxkIF9iLmNhbGwocmVzcG9uc2VzXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlOiBwdXNoIGEgZm5cbiAgICAgICAgICAgICAgICBpdGVyLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpdGVyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pKSgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVyLnN0b3AoZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmljZUNsaWVudEltcGwgPSBTZXJ2aWNlQ2xpZW50SW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZpY2VjbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/serviceclient.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/sha256.js":
/*!**********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/sha256.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n// deno-fmt-ignore-file\n// deno-lint-ignore-file\n// This code was bundled using `deno bundle` and it's not recommended to edit it manually\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha256 = exports.SHA256 = exports.BYTES = void 0;\n// deno bundle https://deno.land/x/sha256@v1.0.2/mod.ts\n// The MIT License (MIT)\n//\n// Original work (c) Marco Paland (marco@paland.com) 2015-2018, PALANDesign Hannover, Germany\n//\n// Deno port Copyright (c) 2019 Noah Anabiik Schwarz\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nfunction getLengths(b64) {\n    const len = b64.length;\n    let validLen = b64.indexOf(\"=\");\n    if (validLen === -1) {\n        validLen = len;\n    }\n    const placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n    return [\n        validLen,\n        placeHoldersLen\n    ];\n}\nfunction init(lookup, revLookup, urlsafe = false) {\n    function _byteLength(validLen, placeHoldersLen) {\n        return Math.floor((validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen);\n    }\n    function tripletToBase64(num) {\n        return lookup[num >> 18 & 0x3f] + lookup[num >> 12 & 0x3f] + lookup[num >> 6 & 0x3f] + lookup[num & 0x3f];\n    }\n    function encodeChunk(buf, start, end) {\n        const out = new Array((end - start) / 3);\n        for (let i = start, curTriplet = 0; i < end; i += 3) {\n            out[curTriplet++] = tripletToBase64((buf[i] << 16) + (buf[i + 1] << 8) + buf[i + 2]);\n        }\n        return out.join(\"\");\n    }\n    return {\n        byteLength(b64) {\n            return _byteLength.apply(null, getLengths(b64));\n        },\n        toUint8Array(b64) {\n            const [validLen, placeHoldersLen] = getLengths(b64);\n            const buf = new Uint8Array(_byteLength(validLen, placeHoldersLen));\n            const len = placeHoldersLen ? validLen - 4 : validLen;\n            let tmp;\n            let curByte = 0;\n            let i;\n            for (i = 0; i < len; i += 4) {\n                tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n                buf[curByte++] = tmp >> 16 & 0xff;\n                buf[curByte++] = tmp >> 8 & 0xff;\n                buf[curByte++] = tmp & 0xff;\n            }\n            if (placeHoldersLen === 2) {\n                tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n                buf[curByte++] = tmp & 0xff;\n            }\n            else if (placeHoldersLen === 1) {\n                tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n                buf[curByte++] = tmp >> 8 & 0xff;\n                buf[curByte++] = tmp & 0xff;\n            }\n            return buf;\n        },\n        fromUint8Array(buf) {\n            const maxChunkLength = 16383;\n            const len = buf.length;\n            const extraBytes = len % 3;\n            const len2 = len - extraBytes;\n            const parts = new Array(Math.ceil(len2 / 16383) + (extraBytes ? 1 : 0));\n            let curChunk = 0;\n            let chunkEnd;\n            for (let i = 0; i < len2; i += maxChunkLength) {\n                chunkEnd = i + maxChunkLength;\n                parts[curChunk++] = encodeChunk(buf, i, chunkEnd > len2 ? len2 : chunkEnd);\n            }\n            let tmp;\n            if (extraBytes === 1) {\n                tmp = buf[len2];\n                parts[curChunk] = lookup[tmp >> 2] + lookup[tmp << 4 & 0x3f];\n                if (!urlsafe)\n                    parts[curChunk] += \"==\";\n            }\n            else if (extraBytes === 2) {\n                tmp = buf[len2] << 8 | buf[len2 + 1] & 0xff;\n                parts[curChunk] = lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3f] + lookup[tmp << 2 & 0x3f];\n                if (!urlsafe)\n                    parts[curChunk] += \"=\";\n            }\n            return parts.join(\"\");\n        }\n    };\n}\nconst lookup = [];\nconst revLookup = [];\nconst code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\nfor (let i = 0, l = code.length; i < l; ++i) {\n    lookup[i] = code[i];\n    revLookup[code.charCodeAt(i)] = i;\n}\nconst { byteLength, toUint8Array, fromUint8Array } = init(lookup, revLookup, true);\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\nfunction toHexString(buf) {\n    return buf.reduce((hex, __byte) => `${hex}${__byte < 16 ? \"0\" : \"\"}${__byte.toString(16)}`, \"\");\n}\nfunction fromHexString(hex) {\n    const len = hex.length;\n    if (len % 2 || !/^[0-9a-fA-F]+$/.test(hex)) {\n        throw new TypeError(\"Invalid hex string.\");\n    }\n    hex = hex.toLowerCase();\n    const buf = new Uint8Array(Math.floor(len / 2));\n    const end = len / 2;\n    for (let i = 0; i < end; ++i) {\n        buf[i] = parseInt(hex.substr(i * 2, 2), 16);\n    }\n    return buf;\n}\nfunction decode(buf, encoding = \"utf8\") {\n    if (/^utf-?8$/i.test(encoding)) {\n        return decoder.decode(buf);\n    }\n    else if (/^base64$/i.test(encoding)) {\n        return fromUint8Array(buf);\n    }\n    else if (/^hex(?:adecimal)?$/i.test(encoding)) {\n        return toHexString(buf);\n    }\n    else {\n        throw new TypeError(\"Unsupported string encoding.\");\n    }\n}\nfunction encode(str, encoding = \"utf8\") {\n    if (/^utf-?8$/i.test(encoding)) {\n        return encoder.encode(str);\n    }\n    else if (/^base64$/i.test(encoding)) {\n        return toUint8Array(str);\n    }\n    else if (/^hex(?:adecimal)?$/i.test(encoding)) {\n        return fromHexString(str);\n    }\n    else {\n        throw new TypeError(\"Unsupported string encoding.\");\n    }\n}\nconst BYTES = 32;\nexports.BYTES = BYTES;\nclass SHA256 {\n    constructor() {\n        this.hashSize = 32;\n        this._buf = new Uint8Array(64);\n        this._K = new Uint32Array([\n            0x428a2f98,\n            0x71374491,\n            0xb5c0fbcf,\n            0xe9b5dba5,\n            0x3956c25b,\n            0x59f111f1,\n            0x923f82a4,\n            0xab1c5ed5,\n            0xd807aa98,\n            0x12835b01,\n            0x243185be,\n            0x550c7dc3,\n            0x72be5d74,\n            0x80deb1fe,\n            0x9bdc06a7,\n            0xc19bf174,\n            0xe49b69c1,\n            0xefbe4786,\n            0x0fc19dc6,\n            0x240ca1cc,\n            0x2de92c6f,\n            0x4a7484aa,\n            0x5cb0a9dc,\n            0x76f988da,\n            0x983e5152,\n            0xa831c66d,\n            0xb00327c8,\n            0xbf597fc7,\n            0xc6e00bf3,\n            0xd5a79147,\n            0x06ca6351,\n            0x14292967,\n            0x27b70a85,\n            0x2e1b2138,\n            0x4d2c6dfc,\n            0x53380d13,\n            0x650a7354,\n            0x766a0abb,\n            0x81c2c92e,\n            0x92722c85,\n            0xa2bfe8a1,\n            0xa81a664b,\n            0xc24b8b70,\n            0xc76c51a3,\n            0xd192e819,\n            0xd6990624,\n            0xf40e3585,\n            0x106aa070,\n            0x19a4c116,\n            0x1e376c08,\n            0x2748774c,\n            0x34b0bcb5,\n            0x391c0cb3,\n            0x4ed8aa4a,\n            0x5b9cca4f,\n            0x682e6ff3,\n            0x748f82ee,\n            0x78a5636f,\n            0x84c87814,\n            0x8cc70208,\n            0x90befffa,\n            0xa4506ceb,\n            0xbef9a3f7,\n            0xc67178f2\n        ]);\n        this.init();\n    }\n    init() {\n        this._H = new Uint32Array([\n            0x6a09e667,\n            0xbb67ae85,\n            0x3c6ef372,\n            0xa54ff53a,\n            0x510e527f,\n            0x9b05688c,\n            0x1f83d9ab,\n            0x5be0cd19\n        ]);\n        this._bufIdx = 0;\n        this._count = new Uint32Array(2);\n        this._buf.fill(0);\n        this._finalized = false;\n        return this;\n    }\n    update(msg, inputEncoding) {\n        if (msg === null) {\n            throw new TypeError(\"msg must be a string or Uint8Array.\");\n        }\n        else if (typeof msg === \"string\") {\n            msg = encode(msg, inputEncoding);\n        }\n        for (let i = 0, len = msg.length; i < len; i++) {\n            this._buf[this._bufIdx++] = msg[i];\n            if (this._bufIdx === 64) {\n                this._transform();\n                this._bufIdx = 0;\n            }\n        }\n        const c = this._count;\n        if ((c[0] += msg.length << 3) < msg.length << 3) {\n            c[1]++;\n        }\n        c[1] += msg.length >>> 29;\n        return this;\n    }\n    digest(outputEncoding) {\n        if (this._finalized) {\n            throw new Error(\"digest has already been called.\");\n        }\n        this._finalized = true;\n        const b = this._buf;\n        let idx = this._bufIdx;\n        b[idx++] = 0x80;\n        while (idx !== 56) {\n            if (idx === 64) {\n                this._transform();\n                idx = 0;\n            }\n            b[idx++] = 0;\n        }\n        const c = this._count;\n        b[56] = c[1] >>> 24 & 0xff;\n        b[57] = c[1] >>> 16 & 0xff;\n        b[58] = c[1] >>> 8 & 0xff;\n        b[59] = c[1] >>> 0 & 0xff;\n        b[60] = c[0] >>> 24 & 0xff;\n        b[61] = c[0] >>> 16 & 0xff;\n        b[62] = c[0] >>> 8 & 0xff;\n        b[63] = c[0] >>> 0 & 0xff;\n        this._transform();\n        const hash = new Uint8Array(32);\n        for (let i = 0; i < 8; i++) {\n            hash[(i << 2) + 0] = this._H[i] >>> 24 & 0xff;\n            hash[(i << 2) + 1] = this._H[i] >>> 16 & 0xff;\n            hash[(i << 2) + 2] = this._H[i] >>> 8 & 0xff;\n            hash[(i << 2) + 3] = this._H[i] >>> 0 & 0xff;\n        }\n        this.init();\n        return outputEncoding ? decode(hash, outputEncoding) : hash;\n    }\n    _transform() {\n        const h = this._H;\n        let h0 = h[0];\n        let h1 = h[1];\n        let h2 = h[2];\n        let h3 = h[3];\n        let h4 = h[4];\n        let h5 = h[5];\n        let h6 = h[6];\n        let h7 = h[7];\n        const w = new Uint32Array(16);\n        let i;\n        for (i = 0; i < 16; i++) {\n            w[i] = this._buf[(i << 2) + 3] | this._buf[(i << 2) + 2] << 8 | this._buf[(i << 2) + 1] << 16 | this._buf[i << 2] << 24;\n        }\n        for (i = 0; i < 64; i++) {\n            let tmp;\n            if (i < 16) {\n                tmp = w[i];\n            }\n            else {\n                let a = w[i + 1 & 15];\n                let b = w[i + 14 & 15];\n                tmp = w[i & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i & 15] + w[i + 9 & 15] | 0;\n            }\n            tmp = tmp + h7 + (h4 >>> 6 ^ h4 >>> 11 ^ h4 >>> 25 ^ h4 << 26 ^ h4 << 21 ^ h4 << 7) + (h6 ^ h4 & (h5 ^ h6)) + this._K[i] | 0;\n            h7 = h6;\n            h6 = h5;\n            h5 = h4;\n            h4 = h3 + tmp;\n            h3 = h2;\n            h2 = h1;\n            h1 = h0;\n            h0 = tmp + (h1 & h2 ^ h3 & (h1 ^ h2)) + (h1 >>> 2 ^ h1 >>> 13 ^ h1 >>> 22 ^ h1 << 30 ^ h1 << 19 ^ h1 << 10) | 0;\n        }\n        h[0] = h[0] + h0 | 0;\n        h[1] = h[1] + h1 | 0;\n        h[2] = h[2] + h2 | 0;\n        h[3] = h[3] + h3 | 0;\n        h[4] = h[4] + h4 | 0;\n        h[5] = h[5] + h5 | 0;\n        h[6] = h[6] + h6 | 0;\n        h[7] = h[7] + h7 | 0;\n    }\n}\nexports.SHA256 = SHA256;\nfunction sha256(msg, inputEncoding, outputEncoding) {\n    return new SHA256().update(msg, inputEncoding).digest(outputEncoding);\n}\nexports.sha256 = sha256;\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC9zaGEyNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYyxHQUFHLGNBQWMsR0FBRyxhQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBMkM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUksRUFBRSx1QkFBdUIsRUFBRSxvQkFBb0I7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L3NoYTI1Ni5qcz9mZDQ3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gZGVuby1mbXQtaWdub3JlLWZpbGVcbi8vIGRlbm8tbGludC1pZ25vcmUtZmlsZVxuLy8gVGhpcyBjb2RlIHdhcyBidW5kbGVkIHVzaW5nIGBkZW5vIGJ1bmRsZWAgYW5kIGl0J3Mgbm90IHJlY29tbWVuZGVkIHRvIGVkaXQgaXQgbWFudWFsbHlcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjU2ID0gZXhwb3J0cy5TSEEyNTYgPSBleHBvcnRzLkJZVEVTID0gdm9pZCAwO1xuLy8gZGVubyBidW5kbGUgaHR0cHM6Ly9kZW5vLmxhbmQveC9zaGEyNTZAdjEuMC4yL21vZC50c1xuLy8gVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4vL1xuLy8gT3JpZ2luYWwgd29yayAoYykgTWFyY28gUGFsYW5kIChtYXJjb0BwYWxhbmQuY29tKSAyMDE1LTIwMTgsIFBBTEFORGVzaWduIEhhbm5vdmVyLCBHZXJtYW55XG4vL1xuLy8gRGVubyBwb3J0IENvcHlyaWdodCAoYykgMjAxOSBOb2FoIEFuYWJpaWsgU2Nod2FyelxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5mdW5jdGlvbiBnZXRMZW5ndGhzKGI2NCkge1xuICAgIGNvbnN0IGxlbiA9IGI2NC5sZW5ndGg7XG4gICAgbGV0IHZhbGlkTGVuID0gYjY0LmluZGV4T2YoXCI9XCIpO1xuICAgIGlmICh2YWxpZExlbiA9PT0gLTEpIHtcbiAgICAgICAgdmFsaWRMZW4gPSBsZW47XG4gICAgfVxuICAgIGNvbnN0IHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW4gPyAwIDogNCAtIHZhbGlkTGVuICUgNDtcbiAgICByZXR1cm4gW1xuICAgICAgICB2YWxpZExlbixcbiAgICAgICAgcGxhY2VIb2xkZXJzTGVuXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGluaXQobG9va3VwLCByZXZMb29rdXAsIHVybHNhZmUgPSBmYWxzZSkge1xuICAgIGZ1bmN0aW9uIF9ieXRlTGVuZ3RoKHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzTGVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0KG51bSkge1xuICAgICAgICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M2ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M2ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzZl0gKyBsb29rdXBbbnVtICYgMHgzZl07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZUNodW5rKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgQXJyYXkoKGVuZCAtIHN0YXJ0KSAvIDMpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQsIGN1clRyaXBsZXQgPSAwOyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICAgICAgICAgIG91dFtjdXJUcmlwbGV0KytdID0gdHJpcGxldFRvQmFzZTY0KChidWZbaV0gPDwgMTYpICsgKGJ1ZltpICsgMV0gPDwgOCkgKyBidWZbaSArIDJdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0LmpvaW4oXCJcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGJ5dGVMZW5ndGgoYjY0KSB7XG4gICAgICAgICAgICByZXR1cm4gX2J5dGVMZW5ndGguYXBwbHkobnVsbCwgZ2V0TGVuZ3RocyhiNjQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9VaW50OEFycmF5KGI2NCkge1xuICAgICAgICAgICAgY29uc3QgW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dID0gZ2V0TGVuZ3RocyhiNjQpO1xuICAgICAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoX2J5dGVMZW5ndGgodmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gcGxhY2VIb2xkZXJzTGVuID8gdmFsaWRMZW4gLSA0IDogdmFsaWRMZW47XG4gICAgICAgICAgICBsZXQgdG1wO1xuICAgICAgICAgICAgbGV0IGN1ckJ5dGUgPSAwO1xuICAgICAgICAgICAgbGV0IGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgICAgICAgICAgICAgYnVmW2N1ckJ5dGUrK10gPSB0bXAgPj4gMTYgJiAweGZmO1xuICAgICAgICAgICAgICAgIGJ1ZltjdXJCeXRlKytdID0gdG1wID4+IDggJiAweGZmO1xuICAgICAgICAgICAgICAgIGJ1ZltjdXJCeXRlKytdID0gdG1wICYgMHhmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICAgICAgICAgICAgICB0bXAgPSByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0O1xuICAgICAgICAgICAgICAgIGJ1ZltjdXJCeXRlKytdID0gdG1wICYgMHhmZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTAgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0IHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMjtcbiAgICAgICAgICAgICAgICBidWZbY3VyQnl0ZSsrXSA9IHRtcCA+PiA4ICYgMHhmZjtcbiAgICAgICAgICAgICAgICBidWZbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4ZmY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9LFxuICAgICAgICBmcm9tVWludDhBcnJheShidWYpIHtcbiAgICAgICAgICAgIGNvbnN0IG1heENodW5rTGVuZ3RoID0gMTYzODM7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZXh0cmFCeXRlcyA9IGxlbiAlIDM7XG4gICAgICAgICAgICBjb25zdCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlcztcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbmV3IEFycmF5KE1hdGguY2VpbChsZW4yIC8gMTYzODMpICsgKGV4dHJhQnl0ZXMgPyAxIDogMCkpO1xuICAgICAgICAgICAgbGV0IGN1ckNodW5rID0gMDtcbiAgICAgICAgICAgIGxldCBjaHVua0VuZDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNodW5rRW5kID0gaSArIG1heENodW5rTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHBhcnRzW2N1ckNodW5rKytdID0gZW5jb2RlQ2h1bmsoYnVmLCBpLCBjaHVua0VuZCA+IGxlbjIgPyBsZW4yIDogY2h1bmtFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRtcDtcbiAgICAgICAgICAgIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gYnVmW2xlbjJdO1xuICAgICAgICAgICAgICAgIHBhcnRzW2N1ckNodW5rXSA9IGxvb2t1cFt0bXAgPj4gMl0gKyBsb29rdXBbdG1wIDw8IDQgJiAweDNmXTtcbiAgICAgICAgICAgICAgICBpZiAoIXVybHNhZmUpXG4gICAgICAgICAgICAgICAgICAgIHBhcnRzW2N1ckNodW5rXSArPSBcIj09XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgdG1wID0gYnVmW2xlbjJdIDw8IDggfCBidWZbbGVuMiArIDFdICYgMHhmZjtcbiAgICAgICAgICAgICAgICBwYXJ0c1tjdXJDaHVua10gPSBsb29rdXBbdG1wID4+IDEwXSArIGxvb2t1cFt0bXAgPj4gNCAmIDB4M2ZdICsgbG9va3VwW3RtcCA8PCAyICYgMHgzZl07XG4gICAgICAgICAgICAgICAgaWYgKCF1cmxzYWZlKVxuICAgICAgICAgICAgICAgICAgICBwYXJ0c1tjdXJDaHVua10gKz0gXCI9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jb25zdCBsb29rdXAgPSBbXTtcbmNvbnN0IHJldkxvb2t1cCA9IFtdO1xuY29uc3QgY29kZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktX1wiO1xuZm9yIChsZXQgaSA9IDAsIGwgPSBjb2RlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpO1xufVxuY29uc3QgeyBieXRlTGVuZ3RoLCB0b1VpbnQ4QXJyYXksIGZyb21VaW50OEFycmF5IH0gPSBpbml0KGxvb2t1cCwgcmV2TG9va3VwLCB0cnVlKTtcbmNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIHRvSGV4U3RyaW5nKGJ1Zikge1xuICAgIHJldHVybiBidWYucmVkdWNlKChoZXgsIF9fYnl0ZSkgPT4gYCR7aGV4fSR7X19ieXRlIDwgMTYgPyBcIjBcIiA6IFwiXCJ9JHtfX2J5dGUudG9TdHJpbmcoMTYpfWAsIFwiXCIpO1xufVxuZnVuY3Rpb24gZnJvbUhleFN0cmluZyhoZXgpIHtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyIHx8ICEvXlswLTlhLWZBLUZdKyQvLnRlc3QoaGV4KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBoZXggc3RyaW5nLlwiKTtcbiAgICB9XG4gICAgaGV4ID0gaGV4LnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoTWF0aC5mbG9vcihsZW4gLyAyKSk7XG4gICAgY29uc3QgZW5kID0gbGVuIC8gMjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICAgIGJ1ZltpXSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG5mdW5jdGlvbiBkZWNvZGUoYnVmLCBlbmNvZGluZyA9IFwidXRmOFwiKSB7XG4gICAgaWYgKC9edXRmLT84JC9pLnRlc3QoZW5jb2RpbmcpKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShidWYpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXmJhc2U2NCQvaS50ZXN0KGVuY29kaW5nKSkge1xuICAgICAgICByZXR1cm4gZnJvbVVpbnQ4QXJyYXkoYnVmKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL15oZXgoPzphZGVjaW1hbCk/JC9pLnRlc3QoZW5jb2RpbmcpKSB7XG4gICAgICAgIHJldHVybiB0b0hleFN0cmluZyhidWYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuc3VwcG9ydGVkIHN0cmluZyBlbmNvZGluZy5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5jb2RlKHN0ciwgZW5jb2RpbmcgPSBcInV0ZjhcIikge1xuICAgIGlmICgvXnV0Zi0/OCQvaS50ZXN0KGVuY29kaW5nKSkge1xuICAgICAgICByZXR1cm4gZW5jb2Rlci5lbmNvZGUoc3RyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL15iYXNlNjQkL2kudGVzdChlbmNvZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRvVWludDhBcnJheShzdHIpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXmhleCg/OmFkZWNpbWFsKT8kL2kudGVzdChlbmNvZGluZykpIHtcbiAgICAgICAgcmV0dXJuIGZyb21IZXhTdHJpbmcoc3RyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbnN1cHBvcnRlZCBzdHJpbmcgZW5jb2RpbmcuXCIpO1xuICAgIH1cbn1cbmNvbnN0IEJZVEVTID0gMzI7XG5leHBvcnRzLkJZVEVTID0gQllURVM7XG5jbGFzcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmhhc2hTaXplID0gMzI7XG4gICAgICAgIHRoaXMuX2J1ZiA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICAgICAgdGhpcy5fSyA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgICAgICAgICAweDQyOGEyZjk4LFxuICAgICAgICAgICAgMHg3MTM3NDQ5MSxcbiAgICAgICAgICAgIDB4YjVjMGZiY2YsXG4gICAgICAgICAgICAweGU5YjVkYmE1LFxuICAgICAgICAgICAgMHgzOTU2YzI1YixcbiAgICAgICAgICAgIDB4NTlmMTExZjEsXG4gICAgICAgICAgICAweDkyM2Y4MmE0LFxuICAgICAgICAgICAgMHhhYjFjNWVkNSxcbiAgICAgICAgICAgIDB4ZDgwN2FhOTgsXG4gICAgICAgICAgICAweDEyODM1YjAxLFxuICAgICAgICAgICAgMHgyNDMxODViZSxcbiAgICAgICAgICAgIDB4NTUwYzdkYzMsXG4gICAgICAgICAgICAweDcyYmU1ZDc0LFxuICAgICAgICAgICAgMHg4MGRlYjFmZSxcbiAgICAgICAgICAgIDB4OWJkYzA2YTcsXG4gICAgICAgICAgICAweGMxOWJmMTc0LFxuICAgICAgICAgICAgMHhlNDliNjljMSxcbiAgICAgICAgICAgIDB4ZWZiZTQ3ODYsXG4gICAgICAgICAgICAweDBmYzE5ZGM2LFxuICAgICAgICAgICAgMHgyNDBjYTFjYyxcbiAgICAgICAgICAgIDB4MmRlOTJjNmYsXG4gICAgICAgICAgICAweDRhNzQ4NGFhLFxuICAgICAgICAgICAgMHg1Y2IwYTlkYyxcbiAgICAgICAgICAgIDB4NzZmOTg4ZGEsXG4gICAgICAgICAgICAweDk4M2U1MTUyLFxuICAgICAgICAgICAgMHhhODMxYzY2ZCxcbiAgICAgICAgICAgIDB4YjAwMzI3YzgsXG4gICAgICAgICAgICAweGJmNTk3ZmM3LFxuICAgICAgICAgICAgMHhjNmUwMGJmMyxcbiAgICAgICAgICAgIDB4ZDVhNzkxNDcsXG4gICAgICAgICAgICAweDA2Y2E2MzUxLFxuICAgICAgICAgICAgMHgxNDI5Mjk2NyxcbiAgICAgICAgICAgIDB4MjdiNzBhODUsXG4gICAgICAgICAgICAweDJlMWIyMTM4LFxuICAgICAgICAgICAgMHg0ZDJjNmRmYyxcbiAgICAgICAgICAgIDB4NTMzODBkMTMsXG4gICAgICAgICAgICAweDY1MGE3MzU0LFxuICAgICAgICAgICAgMHg3NjZhMGFiYixcbiAgICAgICAgICAgIDB4ODFjMmM5MmUsXG4gICAgICAgICAgICAweDkyNzIyYzg1LFxuICAgICAgICAgICAgMHhhMmJmZThhMSxcbiAgICAgICAgICAgIDB4YTgxYTY2NGIsXG4gICAgICAgICAgICAweGMyNGI4YjcwLFxuICAgICAgICAgICAgMHhjNzZjNTFhMyxcbiAgICAgICAgICAgIDB4ZDE5MmU4MTksXG4gICAgICAgICAgICAweGQ2OTkwNjI0LFxuICAgICAgICAgICAgMHhmNDBlMzU4NSxcbiAgICAgICAgICAgIDB4MTA2YWEwNzAsXG4gICAgICAgICAgICAweDE5YTRjMTE2LFxuICAgICAgICAgICAgMHgxZTM3NmMwOCxcbiAgICAgICAgICAgIDB4Mjc0ODc3NGMsXG4gICAgICAgICAgICAweDM0YjBiY2I1LFxuICAgICAgICAgICAgMHgzOTFjMGNiMyxcbiAgICAgICAgICAgIDB4NGVkOGFhNGEsXG4gICAgICAgICAgICAweDViOWNjYTRmLFxuICAgICAgICAgICAgMHg2ODJlNmZmMyxcbiAgICAgICAgICAgIDB4NzQ4ZjgyZWUsXG4gICAgICAgICAgICAweDc4YTU2MzZmLFxuICAgICAgICAgICAgMHg4NGM4NzgxNCxcbiAgICAgICAgICAgIDB4OGNjNzAyMDgsXG4gICAgICAgICAgICAweDkwYmVmZmZhLFxuICAgICAgICAgICAgMHhhNDUwNmNlYixcbiAgICAgICAgICAgIDB4YmVmOWEzZjcsXG4gICAgICAgICAgICAweGM2NzE3OGYyXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5fSCA9IG5ldyBVaW50MzJBcnJheShbXG4gICAgICAgICAgICAweDZhMDllNjY3LFxuICAgICAgICAgICAgMHhiYjY3YWU4NSxcbiAgICAgICAgICAgIDB4M2M2ZWYzNzIsXG4gICAgICAgICAgICAweGE1NGZmNTNhLFxuICAgICAgICAgICAgMHg1MTBlNTI3ZixcbiAgICAgICAgICAgIDB4OWIwNTY4OGMsXG4gICAgICAgICAgICAweDFmODNkOWFiLFxuICAgICAgICAgICAgMHg1YmUwY2QxOVxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5fYnVmSWR4ID0gMDtcbiAgICAgICAgdGhpcy5fY291bnQgPSBuZXcgVWludDMyQXJyYXkoMik7XG4gICAgICAgIHRoaXMuX2J1Zi5maWxsKDApO1xuICAgICAgICB0aGlzLl9maW5hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZShtc2csIGlucHV0RW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKG1zZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1zZyBtdXN0IGJlIGEgc3RyaW5nIG9yIFVpbnQ4QXJyYXkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtc2cgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIG1zZyA9IGVuY29kZShtc2csIGlucHV0RW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtc2cubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2J1Zlt0aGlzLl9idWZJZHgrK10gPSBtc2dbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5fYnVmSWR4ID09PSA2NCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZklkeCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IHRoaXMuX2NvdW50O1xuICAgICAgICBpZiAoKGNbMF0gKz0gbXNnLmxlbmd0aCA8PCAzKSA8IG1zZy5sZW5ndGggPDwgMykge1xuICAgICAgICAgICAgY1sxXSsrO1xuICAgICAgICB9XG4gICAgICAgIGNbMV0gKz0gbXNnLmxlbmd0aCA+Pj4gMjk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3Qob3V0cHV0RW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbmFsaXplZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlnZXN0IGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBiID0gdGhpcy5fYnVmO1xuICAgICAgICBsZXQgaWR4ID0gdGhpcy5fYnVmSWR4O1xuICAgICAgICBiW2lkeCsrXSA9IDB4ODA7XG4gICAgICAgIHdoaWxlIChpZHggIT09IDU2KSB7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSA2NCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIGlkeCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiW2lkeCsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYyA9IHRoaXMuX2NvdW50O1xuICAgICAgICBiWzU2XSA9IGNbMV0gPj4+IDI0ICYgMHhmZjtcbiAgICAgICAgYls1N10gPSBjWzFdID4+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGJbNThdID0gY1sxXSA+Pj4gOCAmIDB4ZmY7XG4gICAgICAgIGJbNTldID0gY1sxXSA+Pj4gMCAmIDB4ZmY7XG4gICAgICAgIGJbNjBdID0gY1swXSA+Pj4gMjQgJiAweGZmO1xuICAgICAgICBiWzYxXSA9IGNbMF0gPj4+IDE2ICYgMHhmZjtcbiAgICAgICAgYls2Ml0gPSBjWzBdID4+PiA4ICYgMHhmZjtcbiAgICAgICAgYls2M10gPSBjWzBdID4+PiAwICYgMHhmZjtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtKCk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBoYXNoWyhpIDw8IDIpICsgMF0gPSB0aGlzLl9IW2ldID4+PiAyNCAmIDB4ZmY7XG4gICAgICAgICAgICBoYXNoWyhpIDw8IDIpICsgMV0gPSB0aGlzLl9IW2ldID4+PiAxNiAmIDB4ZmY7XG4gICAgICAgICAgICBoYXNoWyhpIDw8IDIpICsgMl0gPSB0aGlzLl9IW2ldID4+PiA4ICYgMHhmZjtcbiAgICAgICAgICAgIGhhc2hbKGkgPDwgMikgKyAzXSA9IHRoaXMuX0hbaV0gPj4+IDAgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICByZXR1cm4gb3V0cHV0RW5jb2RpbmcgPyBkZWNvZGUoaGFzaCwgb3V0cHV0RW5jb2RpbmcpIDogaGFzaDtcbiAgICB9XG4gICAgX3RyYW5zZm9ybSgpIHtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuX0g7XG4gICAgICAgIGxldCBoMCA9IGhbMF07XG4gICAgICAgIGxldCBoMSA9IGhbMV07XG4gICAgICAgIGxldCBoMiA9IGhbMl07XG4gICAgICAgIGxldCBoMyA9IGhbM107XG4gICAgICAgIGxldCBoNCA9IGhbNF07XG4gICAgICAgIGxldCBoNSA9IGhbNV07XG4gICAgICAgIGxldCBoNiA9IGhbNl07XG4gICAgICAgIGxldCBoNyA9IGhbN107XG4gICAgICAgIGNvbnN0IHcgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIHdbaV0gPSB0aGlzLl9idWZbKGkgPDwgMikgKyAzXSB8IHRoaXMuX2J1ZlsoaSA8PCAyKSArIDJdIDw8IDggfCB0aGlzLl9idWZbKGkgPDwgMikgKyAxXSA8PCAxNiB8IHRoaXMuX2J1ZltpIDw8IDJdIDw8IDI0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgdG1wO1xuICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICAgICAgICAgIHRtcCA9IHdbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYSA9IHdbaSArIDEgJiAxNV07XG4gICAgICAgICAgICAgICAgbGV0IGIgPSB3W2kgKyAxNCAmIDE1XTtcbiAgICAgICAgICAgICAgICB0bXAgPSB3W2kgJiAxNV0gPSAoYSA+Pj4gNyBeIGEgPj4+IDE4IF4gYSA+Pj4gMyBeIGEgPDwgMjUgXiBhIDw8IDE0KSArIChiID4+PiAxNyBeIGIgPj4+IDE5IF4gYiA+Pj4gMTAgXiBiIDw8IDE1IF4gYiA8PCAxMykgKyB3W2kgJiAxNV0gKyB3W2kgKyA5ICYgMTVdIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRtcCA9IHRtcCArIGg3ICsgKGg0ID4+PiA2IF4gaDQgPj4+IDExIF4gaDQgPj4+IDI1IF4gaDQgPDwgMjYgXiBoNCA8PCAyMSBeIGg0IDw8IDcpICsgKGg2IF4gaDQgJiAoaDUgXiBoNikpICsgdGhpcy5fS1tpXSB8IDA7XG4gICAgICAgICAgICBoNyA9IGg2O1xuICAgICAgICAgICAgaDYgPSBoNTtcbiAgICAgICAgICAgIGg1ID0gaDQ7XG4gICAgICAgICAgICBoNCA9IGgzICsgdG1wO1xuICAgICAgICAgICAgaDMgPSBoMjtcbiAgICAgICAgICAgIGgyID0gaDE7XG4gICAgICAgICAgICBoMSA9IGgwO1xuICAgICAgICAgICAgaDAgPSB0bXAgKyAoaDEgJiBoMiBeIGgzICYgKGgxIF4gaDIpKSArIChoMSA+Pj4gMiBeIGgxID4+PiAxMyBeIGgxID4+PiAyMiBeIGgxIDw8IDMwIF4gaDEgPDwgMTkgXiBoMSA8PCAxMCkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIGhbMF0gPSBoWzBdICsgaDAgfCAwO1xuICAgICAgICBoWzFdID0gaFsxXSArIGgxIHwgMDtcbiAgICAgICAgaFsyXSA9IGhbMl0gKyBoMiB8IDA7XG4gICAgICAgIGhbM10gPSBoWzNdICsgaDMgfCAwO1xuICAgICAgICBoWzRdID0gaFs0XSArIGg0IHwgMDtcbiAgICAgICAgaFs1XSA9IGhbNV0gKyBoNSB8IDA7XG4gICAgICAgIGhbNl0gPSBoWzZdICsgaDYgfCAwO1xuICAgICAgICBoWzddID0gaFs3XSArIGg3IHwgMDtcbiAgICB9XG59XG5leHBvcnRzLlNIQTI1NiA9IFNIQTI1NjtcbmZ1bmN0aW9uIHNoYTI1Nihtc2csIGlucHV0RW5jb2RpbmcsIG91dHB1dEVuY29kaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBTSEEyNTYoKS51cGRhdGUobXNnLCBpbnB1dEVuY29kaW5nKS5kaWdlc3Qob3V0cHV0RW5jb2RpbmcpO1xufVxuZXhwb3J0cy5zaGEyNTYgPSBzaGEyNTY7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/sha256.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/transport.js":
/*!*************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/transport.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extractProtocolMessage = exports.protoLen = exports.LF = exports.CR = exports.CRLF = exports.CR_LF_LEN = exports.CR_LF = exports.getResolveFn = exports.newTransport = exports.getUrlParseFn = exports.defaultPort = exports.setTransportFactory = void 0;\n/*\n * Copyright 2020-2021 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nconst databuffer_1 = __webpack_require__(/*! ./databuffer */ \"(rsc)/./node_modules/nats/lib/nats-base-client/databuffer.js\");\nlet transportConfig;\nfunction setTransportFactory(config) {\n    transportConfig = config;\n}\nexports.setTransportFactory = setTransportFactory;\nfunction defaultPort() {\n    return transportConfig !== undefined &&\n        transportConfig.defaultPort !== undefined\n        ? transportConfig.defaultPort\n        : core_1.DEFAULT_PORT;\n}\nexports.defaultPort = defaultPort;\nfunction getUrlParseFn() {\n    return transportConfig !== undefined && transportConfig.urlParseFn\n        ? transportConfig.urlParseFn\n        : undefined;\n}\nexports.getUrlParseFn = getUrlParseFn;\nfunction newTransport() {\n    if (!transportConfig || typeof transportConfig.factory !== \"function\") {\n        throw new Error(\"transport fn is not set\");\n    }\n    return transportConfig.factory();\n}\nexports.newTransport = newTransport;\nfunction getResolveFn() {\n    return transportConfig !== undefined && transportConfig.dnsResolveFn\n        ? transportConfig.dnsResolveFn\n        : undefined;\n}\nexports.getResolveFn = getResolveFn;\nexports.CR_LF = \"\\r\\n\";\nexports.CR_LF_LEN = exports.CR_LF.length;\nexports.CRLF = databuffer_1.DataBuffer.fromAscii(exports.CR_LF);\nexports.CR = new Uint8Array(exports.CRLF)[0]; // 13\nexports.LF = new Uint8Array(exports.CRLF)[1]; // 10\nfunction protoLen(ba) {\n    for (let i = 0; i < ba.length; i++) {\n        const n = i + 1;\n        if (ba.byteLength > n && ba[i] === exports.CR && ba[n] === exports.LF) {\n            return n + 1;\n        }\n    }\n    return 0;\n}\nexports.protoLen = protoLen;\nfunction extractProtocolMessage(a) {\n    // protocol messages are ascii, so Uint8Array\n    const len = protoLen(a);\n    if (len > 0) {\n        const ba = new Uint8Array(a);\n        const out = ba.slice(0, len);\n        return encoders_1.TD.decode(out);\n    }\n    return \"\";\n}\nexports.extractProtocolMessage = extractProtocolMessage;\n//# sourceMappingURL=transport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC90cmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsZ0JBQWdCLEdBQUcsVUFBVSxHQUFHLFVBQVUsR0FBRyxZQUFZLEdBQUcsaUJBQWlCLEdBQUcsYUFBYSxHQUFHLG9CQUFvQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLDJCQUEyQjtBQUN4UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsOEVBQVk7QUFDdkMsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYixpQkFBaUI7QUFDakIsWUFBWTtBQUNaLFVBQVUsb0NBQW9DO0FBQzlDLFVBQVUsb0NBQW9DO0FBQzlDO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L3RyYW5zcG9ydC5qcz84OTdmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRyYWN0UHJvdG9jb2xNZXNzYWdlID0gZXhwb3J0cy5wcm90b0xlbiA9IGV4cG9ydHMuTEYgPSBleHBvcnRzLkNSID0gZXhwb3J0cy5DUkxGID0gZXhwb3J0cy5DUl9MRl9MRU4gPSBleHBvcnRzLkNSX0xGID0gZXhwb3J0cy5nZXRSZXNvbHZlRm4gPSBleHBvcnRzLm5ld1RyYW5zcG9ydCA9IGV4cG9ydHMuZ2V0VXJsUGFyc2VGbiA9IGV4cG9ydHMuZGVmYXVsdFBvcnQgPSBleHBvcnRzLnNldFRyYW5zcG9ydEZhY3RvcnkgPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAtMjAyMSBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgZW5jb2RlcnNfMSA9IHJlcXVpcmUoXCIuL2VuY29kZXJzXCIpO1xuY29uc3QgY29yZV8xID0gcmVxdWlyZShcIi4vY29yZVwiKTtcbmNvbnN0IGRhdGFidWZmZXJfMSA9IHJlcXVpcmUoXCIuL2RhdGFidWZmZXJcIik7XG5sZXQgdHJhbnNwb3J0Q29uZmlnO1xuZnVuY3Rpb24gc2V0VHJhbnNwb3J0RmFjdG9yeShjb25maWcpIHtcbiAgICB0cmFuc3BvcnRDb25maWcgPSBjb25maWc7XG59XG5leHBvcnRzLnNldFRyYW5zcG9ydEZhY3RvcnkgPSBzZXRUcmFuc3BvcnRGYWN0b3J5O1xuZnVuY3Rpb24gZGVmYXVsdFBvcnQoKSB7XG4gICAgcmV0dXJuIHRyYW5zcG9ydENvbmZpZyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHRyYW5zcG9ydENvbmZpZy5kZWZhdWx0UG9ydCAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gdHJhbnNwb3J0Q29uZmlnLmRlZmF1bHRQb3J0XG4gICAgICAgIDogY29yZV8xLkRFRkFVTFRfUE9SVDtcbn1cbmV4cG9ydHMuZGVmYXVsdFBvcnQgPSBkZWZhdWx0UG9ydDtcbmZ1bmN0aW9uIGdldFVybFBhcnNlRm4oKSB7XG4gICAgcmV0dXJuIHRyYW5zcG9ydENvbmZpZyAhPT0gdW5kZWZpbmVkICYmIHRyYW5zcG9ydENvbmZpZy51cmxQYXJzZUZuXG4gICAgICAgID8gdHJhbnNwb3J0Q29uZmlnLnVybFBhcnNlRm5cbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLmdldFVybFBhcnNlRm4gPSBnZXRVcmxQYXJzZUZuO1xuZnVuY3Rpb24gbmV3VHJhbnNwb3J0KCkge1xuICAgIGlmICghdHJhbnNwb3J0Q29uZmlnIHx8IHR5cGVvZiB0cmFuc3BvcnRDb25maWcuZmFjdG9yeSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyYW5zcG9ydCBmbiBpcyBub3Qgc2V0XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0Q29uZmlnLmZhY3RvcnkoKTtcbn1cbmV4cG9ydHMubmV3VHJhbnNwb3J0ID0gbmV3VHJhbnNwb3J0O1xuZnVuY3Rpb24gZ2V0UmVzb2x2ZUZuKCkge1xuICAgIHJldHVybiB0cmFuc3BvcnRDb25maWcgIT09IHVuZGVmaW5lZCAmJiB0cmFuc3BvcnRDb25maWcuZG5zUmVzb2x2ZUZuXG4gICAgICAgID8gdHJhbnNwb3J0Q29uZmlnLmRuc1Jlc29sdmVGblxuICAgICAgICA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMuZ2V0UmVzb2x2ZUZuID0gZ2V0UmVzb2x2ZUZuO1xuZXhwb3J0cy5DUl9MRiA9IFwiXFxyXFxuXCI7XG5leHBvcnRzLkNSX0xGX0xFTiA9IGV4cG9ydHMuQ1JfTEYubGVuZ3RoO1xuZXhwb3J0cy5DUkxGID0gZGF0YWJ1ZmZlcl8xLkRhdGFCdWZmZXIuZnJvbUFzY2lpKGV4cG9ydHMuQ1JfTEYpO1xuZXhwb3J0cy5DUiA9IG5ldyBVaW50OEFycmF5KGV4cG9ydHMuQ1JMRilbMF07IC8vIDEzXG5leHBvcnRzLkxGID0gbmV3IFVpbnQ4QXJyYXkoZXhwb3J0cy5DUkxGKVsxXTsgLy8gMTBcbmZ1bmN0aW9uIHByb3RvTGVuKGJhKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBuID0gaSArIDE7XG4gICAgICAgIGlmIChiYS5ieXRlTGVuZ3RoID4gbiAmJiBiYVtpXSA9PT0gZXhwb3J0cy5DUiAmJiBiYVtuXSA9PT0gZXhwb3J0cy5MRikge1xuICAgICAgICAgICAgcmV0dXJuIG4gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuZXhwb3J0cy5wcm90b0xlbiA9IHByb3RvTGVuO1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sTWVzc2FnZShhKSB7XG4gICAgLy8gcHJvdG9jb2wgbWVzc2FnZXMgYXJlIGFzY2lpLCBzbyBVaW50OEFycmF5XG4gICAgY29uc3QgbGVuID0gcHJvdG9MZW4oYSk7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgY29uc3QgYmEgPSBuZXcgVWludDhBcnJheShhKTtcbiAgICAgICAgY29uc3Qgb3V0ID0gYmEuc2xpY2UoMCwgbGVuKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZXJzXzEuVEQuZGVjb2RlKG91dCk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xufVxuZXhwb3J0cy5leHRyYWN0UHJvdG9jb2xNZXNzYWdlID0gZXh0cmFjdFByb3RvY29sTWVzc2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zcG9ydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/typedsub.js":
/*!************************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/typedsub.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/*\n * Copyright 2021 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TypedSubscription = exports.checkFn = void 0;\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst queued_iterator_1 = __webpack_require__(/*! ./queued_iterator */ \"(rsc)/./node_modules/nats/lib/nats-base-client/queued_iterator.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nfunction checkFn(fn, name, required = false) {\n    if (required === true && !fn) {\n        throw core_1.NatsError.errorForCode(core_1.ErrorCode.ApiError, new Error(`${name} is not a function`));\n    }\n    if (fn && typeof fn !== \"function\") {\n        throw core_1.NatsError.errorForCode(core_1.ErrorCode.ApiError, new Error(`${name} is not a function`));\n    }\n}\nexports.checkFn = checkFn;\n/**\n * TypedSubscription wraps a subscription to provide payload specific\n * subscription semantics. That is messages are a transport\n * for user data, and the data is presented as application specific\n * data to the client.\n */\nclass TypedSubscription extends queued_iterator_1.QueuedIteratorImpl {\n    constructor(nc, subject, opts) {\n        super();\n        checkFn(opts.adapter, \"adapter\", true);\n        this.adapter = opts.adapter;\n        if (opts.callback) {\n            checkFn(opts.callback, \"callback\");\n        }\n        this.noIterator = typeof opts.callback === \"function\";\n        if (opts.ingestionFilterFn) {\n            checkFn(opts.ingestionFilterFn, \"ingestionFilterFn\");\n            this.ingestionFilterFn = opts.ingestionFilterFn;\n        }\n        if (opts.protocolFilterFn) {\n            checkFn(opts.protocolFilterFn, \"protocolFilterFn\");\n            this.protocolFilterFn = opts.protocolFilterFn;\n        }\n        if (opts.dispatchedFn) {\n            checkFn(opts.dispatchedFn, \"dispatchedFn\");\n            this.dispatchedFn = opts.dispatchedFn;\n        }\n        if (opts.cleanupFn) {\n            checkFn(opts.cleanupFn, \"cleanupFn\");\n        }\n        let callback = (err, msg) => {\n            this.callback(err, msg);\n        };\n        if (opts.callback) {\n            const uh = opts.callback;\n            callback = (err, msg) => {\n                const [jer, tm] = this.adapter(err, msg);\n                if (jer) {\n                    uh(jer, null);\n                    return;\n                }\n                const { ingest } = this.ingestionFilterFn\n                    ? this.ingestionFilterFn(tm, this)\n                    : { ingest: true };\n                if (ingest) {\n                    const ok = this.protocolFilterFn ? this.protocolFilterFn(tm) : true;\n                    if (ok) {\n                        uh(jer, tm);\n                        if (this.dispatchedFn && tm) {\n                            this.dispatchedFn(tm);\n                        }\n                    }\n                }\n            };\n        }\n        const { max, queue, timeout } = opts;\n        const sopts = { queue, timeout, callback };\n        if (max && max > 0) {\n            sopts.max = max;\n        }\n        this.sub = nc.subscribe(subject, sopts);\n        if (opts.cleanupFn) {\n            this.sub.cleanupFn = opts.cleanupFn;\n        }\n        if (!this.noIterator) {\n            this.iterClosed.then(() => {\n                this.unsubscribe();\n            });\n        }\n        this.subIterDone = (0, util_1.deferred)();\n        Promise.all([this.sub.closed, this.iterClosed])\n            .then(() => {\n            this.subIterDone.resolve();\n        })\n            .catch(() => {\n            this.subIterDone.resolve();\n        });\n        ((s) => __awaiter(this, void 0, void 0, function* () {\n            yield s.closed;\n            this.stop();\n        }))(this.sub).then().catch();\n    }\n    unsubscribe(max) {\n        this.sub.unsubscribe(max);\n    }\n    drain() {\n        return this.sub.drain();\n    }\n    isDraining() {\n        return this.sub.isDraining();\n    }\n    isClosed() {\n        return this.sub.isClosed();\n    }\n    callback(e, msg) {\n        this.sub.cancelTimeout();\n        const [err, tm] = this.adapter(e, msg);\n        if (err) {\n            this.stop(err);\n        }\n        if (tm) {\n            this.push(tm);\n        }\n    }\n    getSubject() {\n        return this.sub.getSubject();\n    }\n    getReceived() {\n        return this.sub.getReceived();\n    }\n    getProcessed() {\n        return this.sub.getProcessed();\n    }\n    getPending() {\n        return this.sub.getPending();\n    }\n    getID() {\n        return this.sub.getID();\n    }\n    getMax() {\n        return this.sub.getMax();\n    }\n    get closed() {\n        return this.sub.closed;\n    }\n}\nexports.TypedSubscription = TypedSubscription;\n//# sourceMappingURL=typedsub.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC90eXBlZHN1Yi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLGVBQWU7QUFDM0MsZUFBZSxtQkFBTyxDQUFDLHNFQUFRO0FBQy9CLDBCQUEwQixtQkFBTyxDQUFDLDRGQUFtQjtBQUNyRCxlQUFlLG1CQUFPLENBQUMsc0VBQVE7QUFDL0I7QUFDQTtBQUNBLG9GQUFvRixNQUFNO0FBQzFGO0FBQ0E7QUFDQSxvRkFBb0YsTUFBTTtBQUMxRjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0Qyx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9uYXRzL2xpYi9uYXRzLWJhc2UtY2xpZW50L3R5cGVkc3ViLmpzPzUxNTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlZFN1YnNjcmlwdGlvbiA9IGV4cG9ydHMuY2hlY2tGbiA9IHZvaWQgMDtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBxdWV1ZWRfaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL3F1ZXVlZF9pdGVyYXRvclwiKTtcbmNvbnN0IGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5mdW5jdGlvbiBjaGVja0ZuKGZuLCBuYW1lLCByZXF1aXJlZCA9IGZhbHNlKSB7XG4gICAgaWYgKHJlcXVpcmVkID09PSB0cnVlICYmICFmbikge1xuICAgICAgICB0aHJvdyBjb3JlXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLkFwaUVycm9yLCBuZXcgRXJyb3IoYCR7bmFtZX0gaXMgbm90IGEgZnVuY3Rpb25gKSk7XG4gICAgfVxuICAgIGlmIChmbiAmJiB0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBjb3JlXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLkFwaUVycm9yLCBuZXcgRXJyb3IoYCR7bmFtZX0gaXMgbm90IGEgZnVuY3Rpb25gKSk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja0ZuID0gY2hlY2tGbjtcbi8qKlxuICogVHlwZWRTdWJzY3JpcHRpb24gd3JhcHMgYSBzdWJzY3JpcHRpb24gdG8gcHJvdmlkZSBwYXlsb2FkIHNwZWNpZmljXG4gKiBzdWJzY3JpcHRpb24gc2VtYW50aWNzLiBUaGF0IGlzIG1lc3NhZ2VzIGFyZSBhIHRyYW5zcG9ydFxuICogZm9yIHVzZXIgZGF0YSwgYW5kIHRoZSBkYXRhIGlzIHByZXNlbnRlZCBhcyBhcHBsaWNhdGlvbiBzcGVjaWZpY1xuICogZGF0YSB0byB0aGUgY2xpZW50LlxuICovXG5jbGFzcyBUeXBlZFN1YnNjcmlwdGlvbiBleHRlbmRzIHF1ZXVlZF9pdGVyYXRvcl8xLlF1ZXVlZEl0ZXJhdG9ySW1wbCB7XG4gICAgY29uc3RydWN0b3IobmMsIHN1YmplY3QsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY2hlY2tGbihvcHRzLmFkYXB0ZXIsIFwiYWRhcHRlclwiLCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gb3B0cy5hZGFwdGVyO1xuICAgICAgICBpZiAob3B0cy5jYWxsYmFjaykge1xuICAgICAgICAgICAgY2hlY2tGbihvcHRzLmNhbGxiYWNrLCBcImNhbGxiYWNrXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9JdGVyYXRvciA9IHR5cGVvZiBvcHRzLmNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGlmIChvcHRzLmluZ2VzdGlvbkZpbHRlckZuKSB7XG4gICAgICAgICAgICBjaGVja0ZuKG9wdHMuaW5nZXN0aW9uRmlsdGVyRm4sIFwiaW5nZXN0aW9uRmlsdGVyRm5cIik7XG4gICAgICAgICAgICB0aGlzLmluZ2VzdGlvbkZpbHRlckZuID0gb3B0cy5pbmdlc3Rpb25GaWx0ZXJGbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5wcm90b2NvbEZpbHRlckZuKSB7XG4gICAgICAgICAgICBjaGVja0ZuKG9wdHMucHJvdG9jb2xGaWx0ZXJGbiwgXCJwcm90b2NvbEZpbHRlckZuXCIpO1xuICAgICAgICAgICAgdGhpcy5wcm90b2NvbEZpbHRlckZuID0gb3B0cy5wcm90b2NvbEZpbHRlckZuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmRpc3BhdGNoZWRGbikge1xuICAgICAgICAgICAgY2hlY2tGbihvcHRzLmRpc3BhdGNoZWRGbiwgXCJkaXNwYXRjaGVkRm5cIik7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoZWRGbiA9IG9wdHMuZGlzcGF0Y2hlZEZuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmNsZWFudXBGbikge1xuICAgICAgICAgICAgY2hlY2tGbihvcHRzLmNsZWFudXBGbiwgXCJjbGVhbnVwRm5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhbGxiYWNrID0gKGVyciwgbXNnKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKGVyciwgbXNnKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IHVoID0gb3B0cy5jYWxsYmFjaztcbiAgICAgICAgICAgIGNhbGxiYWNrID0gKGVyciwgbXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2plciwgdG1dID0gdGhpcy5hZGFwdGVyKGVyciwgbXNnKTtcbiAgICAgICAgICAgICAgICBpZiAoamVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHVoKGplciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpbmdlc3QgfSA9IHRoaXMuaW5nZXN0aW9uRmlsdGVyRm5cbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmluZ2VzdGlvbkZpbHRlckZuKHRtLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICA6IHsgaW5nZXN0OiB0cnVlIH07XG4gICAgICAgICAgICAgICAgaWYgKGluZ2VzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvayA9IHRoaXMucHJvdG9jb2xGaWx0ZXJGbiA/IHRoaXMucHJvdG9jb2xGaWx0ZXJGbih0bSkgOiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVoKGplciwgdG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGF0Y2hlZEZuICYmIHRtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGVkRm4odG0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG1heCwgcXVldWUsIHRpbWVvdXQgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHNvcHRzID0geyBxdWV1ZSwgdGltZW91dCwgY2FsbGJhY2sgfTtcbiAgICAgICAgaWYgKG1heCAmJiBtYXggPiAwKSB7XG4gICAgICAgICAgICBzb3B0cy5tYXggPSBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWIgPSBuYy5zdWJzY3JpYmUoc3ViamVjdCwgc29wdHMpO1xuICAgICAgICBpZiAob3B0cy5jbGVhbnVwRm4pIHtcbiAgICAgICAgICAgIHRoaXMuc3ViLmNsZWFudXBGbiA9IG9wdHMuY2xlYW51cEZuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5ub0l0ZXJhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLml0ZXJDbG9zZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJJdGVyRG9uZSA9ICgwLCB1dGlsXzEuZGVmZXJyZWQpKCk7XG4gICAgICAgIFByb21pc2UuYWxsKFt0aGlzLnN1Yi5jbG9zZWQsIHRoaXMuaXRlckNsb3NlZF0pXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1Ykl0ZXJEb25lLnJlc29sdmUoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1Ykl0ZXJEb25lLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgICgocykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgcy5jbG9zZWQ7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgfSkpKHRoaXMuc3ViKS50aGVuKCkuY2F0Y2goKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmUobWF4KSB7XG4gICAgICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKG1heCk7XG4gICAgfVxuICAgIGRyYWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZHJhaW4oKTtcbiAgICB9XG4gICAgaXNEcmFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViLmlzRHJhaW5pbmcoKTtcbiAgICB9XG4gICAgaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5pc0Nsb3NlZCgpO1xuICAgIH1cbiAgICBjYWxsYmFjayhlLCBtc2cpIHtcbiAgICAgICAgdGhpcy5zdWIuY2FuY2VsVGltZW91dCgpO1xuICAgICAgICBjb25zdCBbZXJyLCB0bV0gPSB0aGlzLmFkYXB0ZXIoZSwgbXNnKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgdGhpcy5zdG9wKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRtKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2godG0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFN1YmplY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5nZXRTdWJqZWN0KCk7XG4gICAgfVxuICAgIGdldFJlY2VpdmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0UmVjZWl2ZWQoKTtcbiAgICB9XG4gICAgZ2V0UHJvY2Vzc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0UHJvY2Vzc2VkKCk7XG4gICAgfVxuICAgIGdldFBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5nZXRQZW5kaW5nKCk7XG4gICAgfVxuICAgIGdldElEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0SUQoKTtcbiAgICB9XG4gICAgZ2V0TWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIuZ2V0TWF4KCk7XG4gICAgfVxuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Yi5jbG9zZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5UeXBlZFN1YnNjcmlwdGlvbiA9IFR5cGVkU3Vic2NyaXB0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZWRzdWIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/typedsub.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/types.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Empty = exports.NatsError = void 0;\nvar core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nObject.defineProperty(exports, \"NatsError\", ({ enumerable: true, get: function () { return core_1.NatsError; } }));\nvar encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nObject.defineProperty(exports, \"Empty\", ({ enumerable: true, get: function () { return encoders_1.Empty; } }));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsaUJBQWlCO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxzRUFBUTtBQUM3Qiw2Q0FBNEMsRUFBRSxxQ0FBcUMsNEJBQTRCLEVBQUM7QUFDaEgsaUJBQWlCLG1CQUFPLENBQUMsOEVBQVk7QUFDckMseUNBQXdDLEVBQUUscUNBQXFDLDRCQUE0QixFQUFDO0FBQzVHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC90eXBlcy5qcz83NWM4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FbXB0eSA9IGV4cG9ydHMuTmF0c0Vycm9yID0gdm9pZCAwO1xudmFyIGNvcmVfMSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYXRzRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvcmVfMS5OYXRzRXJyb3I7IH0gfSk7XG52YXIgZW5jb2RlcnNfMSA9IHJlcXVpcmUoXCIuL2VuY29kZXJzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRW1wdHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZXJzXzEuRW1wdHk7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/nats-base-client/util.js":
/*!********************************************************!*\
  !*** ./node_modules/nats/lib/nats-base-client/util.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.backoff = exports.jitter = exports.SimpleMutex = exports.Perf = exports.collect = exports.shuffle = exports.debugDeferred = exports.deferred = exports.deadline = exports.delay = exports.timeout = exports.render = exports.extend = void 0;\n/*\n * Copyright 2018-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// deno-lint-ignore-file no-explicit-any\nconst encoders_1 = __webpack_require__(/*! ./encoders */ \"(rsc)/./node_modules/nats/lib/nats-base-client/encoders.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/nats/lib/nats-base-client/core.js\");\nfunction extend(a, ...b) {\n    for (let i = 0; i < b.length; i++) {\n        const o = b[i];\n        Object.keys(o).forEach(function (k) {\n            a[k] = o[k];\n        });\n    }\n    return a;\n}\nexports.extend = extend;\nfunction render(frame) {\n    const cr = \"␍\";\n    const lf = \"␊\";\n    return encoders_1.TD.decode(frame)\n        .replace(/\\n/g, lf)\n        .replace(/\\r/g, cr);\n}\nexports.render = render;\nfunction timeout(ms, asyncTraces = true) {\n    // by generating the stack here to help identify what timed out\n    const err = asyncTraces ? core_1.NatsError.errorForCode(core_1.ErrorCode.Timeout) : null;\n    let methods;\n    let timer;\n    const p = new Promise((_resolve, reject) => {\n        const cancel = () => {\n            if (timer) {\n                clearTimeout(timer);\n            }\n        };\n        methods = { cancel };\n        // @ts-ignore: node is not a number\n        timer = setTimeout(() => {\n            if (err === null) {\n                reject(core_1.NatsError.errorForCode(core_1.ErrorCode.Timeout));\n            }\n            else {\n                reject(err);\n            }\n        }, ms);\n    });\n    // noinspection JSUnusedAssignment\n    return Object.assign(p, methods);\n}\nexports.timeout = timeout;\nfunction delay(ms = 0) {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve();\n        }, ms);\n    });\n}\nexports.delay = delay;\nfunction deadline(p, millis = 1000) {\n    const err = new Error(`deadline exceeded`);\n    const d = deferred();\n    const timer = setTimeout(() => d.reject(err), millis);\n    return Promise.race([p, d]).finally(() => clearTimeout(timer));\n}\nexports.deadline = deadline;\n/**\n * Returns a Promise that has a resolve/reject methods that can\n * be used to resolve and defer the Deferred.\n */\nfunction deferred() {\n    let methods = {};\n    const p = new Promise((resolve, reject) => {\n        methods = { resolve, reject };\n    });\n    return Object.assign(p, methods);\n}\nexports.deferred = deferred;\nfunction debugDeferred() {\n    let methods = {};\n    const p = new Promise((resolve, reject) => {\n        methods = {\n            resolve: (v) => {\n                console.trace(\"resolve\", v);\n                resolve(v);\n            },\n            reject: (err) => {\n                console.trace(\"reject\");\n                reject(err);\n            },\n        };\n    });\n    return Object.assign(p, methods);\n}\nexports.debugDeferred = debugDeferred;\nfunction shuffle(a) {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n}\nexports.shuffle = shuffle;\nfunction collect(iter) {\n    var _a, iter_1, iter_1_1;\n    var _b, e_1, _c, _d;\n    return __awaiter(this, void 0, void 0, function* () {\n        const buf = [];\n        try {\n            for (_a = true, iter_1 = __asyncValues(iter); iter_1_1 = yield iter_1.next(), _b = iter_1_1.done, !_b; _a = true) {\n                _d = iter_1_1.value;\n                _a = false;\n                const v = _d;\n                buf.push(v);\n            }\n        }\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\n        finally {\n            try {\n                if (!_a && !_b && (_c = iter_1.return)) yield _c.call(iter_1);\n            }\n            finally { if (e_1) throw e_1.error; }\n        }\n        return buf;\n    });\n}\nexports.collect = collect;\nclass Perf {\n    constructor() {\n        this.timers = new Map();\n        this.measures = new Map();\n    }\n    mark(key) {\n        this.timers.set(key, performance.now());\n    }\n    measure(key, startKey, endKey) {\n        const s = this.timers.get(startKey);\n        if (s === undefined) {\n            throw new Error(`${startKey} is not defined`);\n        }\n        const e = this.timers.get(endKey);\n        if (e === undefined) {\n            throw new Error(`${endKey} is not defined`);\n        }\n        this.measures.set(key, e - s);\n    }\n    getEntries() {\n        const values = [];\n        this.measures.forEach((v, k) => {\n            values.push({ name: k, duration: v });\n        });\n        return values;\n    }\n}\nexports.Perf = Perf;\nclass SimpleMutex {\n    /**\n     * @param max number of concurrent operations\n     */\n    constructor(max = 1) {\n        this.max = max;\n        this.current = 0;\n        this.waiting = [];\n    }\n    /**\n     * Returns a promise that resolves when the mutex is acquired\n     */\n    lock() {\n        // increment the count\n        this.current++;\n        // if we have runners, resolve it\n        if (this.current <= this.max) {\n            return Promise.resolve();\n        }\n        // otherwise defer it\n        const d = deferred();\n        this.waiting.push(d);\n        return d;\n    }\n    /**\n     * Release an acquired mutex - must be called\n     */\n    unlock() {\n        // decrement the count\n        this.current--;\n        // if we have deferred, resolve one\n        const d = this.waiting.pop();\n        d === null || d === void 0 ? void 0 : d.resolve();\n    }\n}\nexports.SimpleMutex = SimpleMutex;\n/**\n * Returns a new number between  .5*n and 1.5*n.\n * If the n is 0, returns 0.\n * @param n\n */\nfunction jitter(n) {\n    if (n === 0) {\n        return 0;\n    }\n    return Math.floor(n / 2 + Math.random() * n);\n}\nexports.jitter = jitter;\n/**\n * Returns a Backoff with the specified interval policy set.\n * @param policy\n */\nfunction backoff(policy = [0, 250, 250, 500, 500, 3000, 5000]) {\n    if (!Array.isArray(policy)) {\n        policy = [0, 250, 250, 500, 500, 3000, 5000];\n    }\n    const max = policy.length - 1;\n    return {\n        backoff(attempt) {\n            return jitter(attempt > max ? policy[max] : policy[attempt]);\n        },\n    };\n}\nexports.backoff = backoff;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvbmF0cy1iYXNlLWNsaWVudC91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRyxjQUFjLEdBQUcsbUJBQW1CLEdBQUcsWUFBWSxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcscUJBQXFCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsYUFBYSxHQUFHLGVBQWUsR0FBRyxjQUFjLEdBQUcsY0FBYztBQUMzTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBWTtBQUN2QyxlQUFlLG1CQUFPLENBQUMsc0VBQVE7QUFDL0I7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5REFBeUQ7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL25hdHMtYmFzZS1jbGllbnQvdXRpbC5qcz85ZGZjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19hc3luY1ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX19hc3luY1ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYWNrb2ZmID0gZXhwb3J0cy5qaXR0ZXIgPSBleHBvcnRzLlNpbXBsZU11dGV4ID0gZXhwb3J0cy5QZXJmID0gZXhwb3J0cy5jb2xsZWN0ID0gZXhwb3J0cy5zaHVmZmxlID0gZXhwb3J0cy5kZWJ1Z0RlZmVycmVkID0gZXhwb3J0cy5kZWZlcnJlZCA9IGV4cG9ydHMuZGVhZGxpbmUgPSBleHBvcnRzLmRlbGF5ID0gZXhwb3J0cy50aW1lb3V0ID0gZXhwb3J0cy5yZW5kZXIgPSBleHBvcnRzLmV4dGVuZCA9IHZvaWQgMDtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOC0yMDIzIFRoZSBOQVRTIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vLyBkZW5vLWxpbnQtaWdub3JlLWZpbGUgbm8tZXhwbGljaXQtYW55XG5jb25zdCBlbmNvZGVyc18xID0gcmVxdWlyZShcIi4vZW5jb2RlcnNcIik7XG5jb25zdCBjb3JlXzEgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuZnVuY3Rpb24gZXh0ZW5kKGEsIC4uLmIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbyA9IGJbaV07XG4gICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGFba10gPSBvW2tdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbmZ1bmN0aW9uIHJlbmRlcihmcmFtZSkge1xuICAgIGNvbnN0IGNyID0gXCLikI1cIjtcbiAgICBjb25zdCBsZiA9IFwi4pCKXCI7XG4gICAgcmV0dXJuIGVuY29kZXJzXzEuVEQuZGVjb2RlKGZyYW1lKVxuICAgICAgICAucmVwbGFjZSgvXFxuL2csIGxmKVxuICAgICAgICAucmVwbGFjZSgvXFxyL2csIGNyKTtcbn1cbmV4cG9ydHMucmVuZGVyID0gcmVuZGVyO1xuZnVuY3Rpb24gdGltZW91dChtcywgYXN5bmNUcmFjZXMgPSB0cnVlKSB7XG4gICAgLy8gYnkgZ2VuZXJhdGluZyB0aGUgc3RhY2sgaGVyZSB0byBoZWxwIGlkZW50aWZ5IHdoYXQgdGltZWQgb3V0XG4gICAgY29uc3QgZXJyID0gYXN5bmNUcmFjZXMgPyBjb3JlXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLlRpbWVvdXQpIDogbnVsbDtcbiAgICBsZXQgbWV0aG9kcztcbiAgICBsZXQgdGltZXI7XG4gICAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1ldGhvZHMgPSB7IGNhbmNlbCB9O1xuICAgICAgICAvLyBAdHMtaWdub3JlOiBub2RlIGlzIG5vdCBhIG51bWJlclxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChjb3JlXzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShjb3JlXzEuRXJyb3JDb2RlLlRpbWVvdXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBtcyk7XG4gICAgfSk7XG4gICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkQXNzaWdubWVudFxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHAsIG1ldGhvZHMpO1xufVxuZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dDtcbmZ1bmN0aW9uIGRlbGF5KG1zID0gMCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgbXMpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWxheSA9IGRlbGF5O1xuZnVuY3Rpb24gZGVhZGxpbmUocCwgbWlsbGlzID0gMTAwMCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihgZGVhZGxpbmUgZXhjZWVkZWRgKTtcbiAgICBjb25zdCBkID0gZGVmZXJyZWQoKTtcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gZC5yZWplY3QoZXJyKSwgbWlsbGlzKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtwLCBkXSkuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpKTtcbn1cbmV4cG9ydHMuZGVhZGxpbmUgPSBkZWFkbGluZTtcbi8qKlxuICogUmV0dXJucyBhIFByb21pc2UgdGhhdCBoYXMgYSByZXNvbHZlL3JlamVjdCBtZXRob2RzIHRoYXQgY2FuXG4gKiBiZSB1c2VkIHRvIHJlc29sdmUgYW5kIGRlZmVyIHRoZSBEZWZlcnJlZC5cbiAqL1xuZnVuY3Rpb24gZGVmZXJyZWQoKSB7XG4gICAgbGV0IG1ldGhvZHMgPSB7fTtcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBtZXRob2RzID0geyByZXNvbHZlLCByZWplY3QgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwLCBtZXRob2RzKTtcbn1cbmV4cG9ydHMuZGVmZXJyZWQgPSBkZWZlcnJlZDtcbmZ1bmN0aW9uIGRlYnVnRGVmZXJyZWQoKSB7XG4gICAgbGV0IG1ldGhvZHMgPSB7fTtcbiAgICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBtZXRob2RzID0ge1xuICAgICAgICAgICAgcmVzb2x2ZTogKHYpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLnRyYWNlKFwicmVzb2x2ZVwiLCB2KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHYpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlamVjdDogKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoXCJyZWplY3RcIik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHAsIG1ldGhvZHMpO1xufVxuZXhwb3J0cy5kZWJ1Z0RlZmVycmVkID0gZGVidWdEZWZlcnJlZDtcbmZ1bmN0aW9uIHNodWZmbGUoYSkge1xuICAgIGZvciAobGV0IGkgPSBhLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICBbYVtpXSwgYVtqXV0gPSBbYVtqXSwgYVtpXV07XG4gICAgfVxuICAgIHJldHVybiBhO1xufVxuZXhwb3J0cy5zaHVmZmxlID0gc2h1ZmZsZTtcbmZ1bmN0aW9uIGNvbGxlY3QoaXRlcikge1xuICAgIHZhciBfYSwgaXRlcl8xLCBpdGVyXzFfMTtcbiAgICB2YXIgX2IsIGVfMSwgX2MsIF9kO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfYSA9IHRydWUsIGl0ZXJfMSA9IF9fYXN5bmNWYWx1ZXMoaXRlcik7IGl0ZXJfMV8xID0geWllbGQgaXRlcl8xLm5leHQoKSwgX2IgPSBpdGVyXzFfMS5kb25lLCAhX2I7IF9hID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIF9kID0gaXRlcl8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgX2EgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gX2Q7XG4gICAgICAgICAgICAgICAgYnVmLnB1c2godik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2EgJiYgIV9iICYmIChfYyA9IGl0ZXJfMS5yZXR1cm4pKSB5aWVsZCBfYy5jYWxsKGl0ZXJfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9KTtcbn1cbmV4cG9ydHMuY29sbGVjdCA9IGNvbGxlY3Q7XG5jbGFzcyBQZXJmIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50aW1lcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubWVhc3VyZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIG1hcmsoa2V5KSB7XG4gICAgICAgIHRoaXMudGltZXJzLnNldChrZXksIHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9XG4gICAgbWVhc3VyZShrZXksIHN0YXJ0S2V5LCBlbmRLZXkpIHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMudGltZXJzLmdldChzdGFydEtleSk7XG4gICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzdGFydEtleX0gaXMgbm90IGRlZmluZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlID0gdGhpcy50aW1lcnMuZ2V0KGVuZEtleSk7XG4gICAgICAgIGlmIChlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtlbmRLZXl9IGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlcy5zZXQoa2V5LCBlIC0gcyk7XG4gICAgfVxuICAgIGdldEVudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICB0aGlzLm1lYXN1cmVzLmZvckVhY2goKHYsIGspID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHsgbmFtZTogaywgZHVyYXRpb246IHYgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbn1cbmV4cG9ydHMuUGVyZiA9IFBlcmY7XG5jbGFzcyBTaW1wbGVNdXRleCB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1heCBudW1iZXIgb2YgY29uY3VycmVudCBvcGVyYXRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWF4ID0gMSkge1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gMDtcbiAgICAgICAgdGhpcy53YWl0aW5nID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgbXV0ZXggaXMgYWNxdWlyZWRcbiAgICAgKi9cbiAgICBsb2NrKCkge1xuICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGNvdW50XG4gICAgICAgIHRoaXMuY3VycmVudCsrO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIHJ1bm5lcnMsIHJlc29sdmUgaXRcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudCA8PSB0aGlzLm1heCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSBkZWZlciBpdFxuICAgICAgICBjb25zdCBkID0gZGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy53YWl0aW5nLnB1c2goZCk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIGFuIGFjcXVpcmVkIG11dGV4IC0gbXVzdCBiZSBjYWxsZWRcbiAgICAgKi9cbiAgICB1bmxvY2soKSB7XG4gICAgICAgIC8vIGRlY3JlbWVudCB0aGUgY291bnRcbiAgICAgICAgdGhpcy5jdXJyZW50LS07XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgZGVmZXJyZWQsIHJlc29sdmUgb25lXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLndhaXRpbmcucG9wKCk7XG4gICAgICAgIGQgPT09IG51bGwgfHwgZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZC5yZXNvbHZlKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TaW1wbGVNdXRleCA9IFNpbXBsZU11dGV4O1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IG51bWJlciBiZXR3ZWVuICAuNSpuIGFuZCAxLjUqbi5cbiAqIElmIHRoZSBuIGlzIDAsIHJldHVybnMgMC5cbiAqIEBwYXJhbSBuXG4gKi9cbmZ1bmN0aW9uIGppdHRlcihuKSB7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKG4gLyAyICsgTWF0aC5yYW5kb20oKSAqIG4pO1xufVxuZXhwb3J0cy5qaXR0ZXIgPSBqaXR0ZXI7XG4vKipcbiAqIFJldHVybnMgYSBCYWNrb2ZmIHdpdGggdGhlIHNwZWNpZmllZCBpbnRlcnZhbCBwb2xpY3kgc2V0LlxuICogQHBhcmFtIHBvbGljeVxuICovXG5mdW5jdGlvbiBiYWNrb2ZmKHBvbGljeSA9IFswLCAyNTAsIDI1MCwgNTAwLCA1MDAsIDMwMDAsIDUwMDBdKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBvbGljeSkpIHtcbiAgICAgICAgcG9saWN5ID0gWzAsIDI1MCwgMjUwLCA1MDAsIDUwMCwgMzAwMCwgNTAwMF07XG4gICAgfVxuICAgIGNvbnN0IG1heCA9IHBvbGljeS5sZW5ndGggLSAxO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJhY2tvZmYoYXR0ZW1wdCkge1xuICAgICAgICAgICAgcmV0dXJuIGppdHRlcihhdHRlbXB0ID4gbWF4ID8gcG9saWN5W21heF0gOiBwb2xpY3lbYXR0ZW1wdF0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnRzLmJhY2tvZmYgPSBiYWNrb2ZmO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/nats-base-client/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/src/connect.js":
/*!**********************************************!*\
  !*** ./node_modules/nats/lib/src/connect.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.connect = void 0;\n/*\n * Copyright 2020 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst node_transport_1 = __webpack_require__(/*! ./node_transport */ \"(rsc)/./node_modules/nats/lib/src/node_transport.js\");\nconst nats_base_client_1 = __webpack_require__(/*! ./nats-base-client */ \"(rsc)/./node_modules/nats/lib/src/nats-base-client.js\");\nfunction connect(opts = {}) {\n    (0, nats_base_client_1.setTransportFactory)({\n        factory: () => {\n            return new node_transport_1.NodeTransport();\n        },\n        dnsResolveFn: node_transport_1.nodeResolveHost,\n    });\n    return nats_base_client_1.NatsConnectionImpl.connect(opts);\n}\nexports.connect = connect;\n//# sourceMappingURL=connect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvc3JjL2Nvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDbkQsMkJBQTJCLG1CQUFPLENBQUMsaUZBQW9CO0FBQ3ZELDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL3NyYy9jb25uZWN0LmpzP2ZlNDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbm5lY3QgPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgVGhlIE5BVFMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG5vZGVfdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi9ub2RlX3RyYW5zcG9ydFwiKTtcbmNvbnN0IG5hdHNfYmFzZV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL25hdHMtYmFzZS1jbGllbnRcIik7XG5mdW5jdGlvbiBjb25uZWN0KG9wdHMgPSB7fSkge1xuICAgICgwLCBuYXRzX2Jhc2VfY2xpZW50XzEuc2V0VHJhbnNwb3J0RmFjdG9yeSkoe1xuICAgICAgICBmYWN0b3J5OiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IG5vZGVfdHJhbnNwb3J0XzEuTm9kZVRyYW5zcG9ydCgpO1xuICAgICAgICB9LFxuICAgICAgICBkbnNSZXNvbHZlRm46IG5vZGVfdHJhbnNwb3J0XzEubm9kZVJlc29sdmVIb3N0LFxuICAgIH0pO1xuICAgIHJldHVybiBuYXRzX2Jhc2VfY2xpZW50XzEuTmF0c0Nvbm5lY3Rpb25JbXBsLmNvbm5lY3Qob3B0cyk7XG59XG5leHBvcnRzLmNvbm5lY3QgPSBjb25uZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/src/connect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/src/mod.js":
/*!******************************************!*\
  !*** ./node_modules/nats/lib/src/mod.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.connect = void 0;\n/*\n * Copyright 2020-2022 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nif (typeof TextEncoder === \"undefined\") {\n    const { TextEncoder, TextDecoder } = __webpack_require__(/*! util */ \"util\");\n    global.TextEncoder = TextEncoder;\n    global.TextDecoder = TextDecoder;\n}\nif (typeof globalThis.crypto === \"undefined\") {\n    const c = __webpack_require__(/*! crypto */ \"crypto\");\n    // this will patch to undefined if webcrypto is not available (node 14)\n    // views will toss if crypto is not available\n    global.crypto = c.webcrypto;\n}\nif (typeof globalThis.ReadableStream === \"undefined\") {\n    // @ts-ignore: node global\n    const chunks = process.versions.node.split(\".\");\n    const v = parseInt(chunks[0]);\n    if (v >= 16) {\n        // this won't mess up fetch\n        const streams = __webpack_require__(/*! stream/web */ \"stream/web\");\n        // views will toss if ReadableStream is not available\n        global.ReadableStream = streams.ReadableStream;\n    }\n}\nvar connect_1 = __webpack_require__(/*! ./connect */ \"(rsc)/./node_modules/nats/lib/src/connect.js\");\nObject.defineProperty(exports, \"connect\", ({ enumerable: true, get: function () { return connect_1.connect; } }));\n__exportStar(__webpack_require__(/*! ../nats-base-client/mod */ \"(rsc)/./node_modules/nats/lib/nats-base-client/mod.js\"), exports);\n__exportStar(__webpack_require__(/*! ../jetstream/mod */ \"(rsc)/./node_modules/nats/lib/jetstream/mod.js\"), exports);\n//# sourceMappingURL=mod.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvc3JjL21vZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkIsRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLHNCQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFPLENBQUMsOEJBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQywrREFBVztBQUNuQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0csYUFBYSxtQkFBTyxDQUFDLHNGQUF5QjtBQUM5QyxhQUFhLG1CQUFPLENBQUMsd0VBQWtCO0FBQ3ZDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvc3JjL21vZC5qcz8yMTAwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbm5lY3QgPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAtMjAyMiBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaWYgKHR5cGVvZiBUZXh0RW5jb2RlciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbnN0IHsgVGV4dEVuY29kZXIsIFRleHREZWNvZGVyIH0gPSByZXF1aXJlKFwidXRpbFwiKTtcbiAgICBnbG9iYWwuVGV4dEVuY29kZXIgPSBUZXh0RW5jb2RlcjtcbiAgICBnbG9iYWwuVGV4dERlY29kZXIgPSBUZXh0RGVjb2Rlcjtcbn1cbmlmICh0eXBlb2YgZ2xvYmFsVGhpcy5jcnlwdG8gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25zdCBjID0gcmVxdWlyZShcImNyeXB0b1wiKTtcbiAgICAvLyB0aGlzIHdpbGwgcGF0Y2ggdG8gdW5kZWZpbmVkIGlmIHdlYmNyeXB0byBpcyBub3QgYXZhaWxhYmxlIChub2RlIDE0KVxuICAgIC8vIHZpZXdzIHdpbGwgdG9zcyBpZiBjcnlwdG8gaXMgbm90IGF2YWlsYWJsZVxuICAgIGdsb2JhbC5jcnlwdG8gPSBjLndlYmNyeXB0bztcbn1cbmlmICh0eXBlb2YgZ2xvYmFsVGhpcy5SZWFkYWJsZVN0cmVhbSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIEB0cy1pZ25vcmU6IG5vZGUgZ2xvYmFsXG4gICAgY29uc3QgY2h1bmtzID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KFwiLlwiKTtcbiAgICBjb25zdCB2ID0gcGFyc2VJbnQoY2h1bmtzWzBdKTtcbiAgICBpZiAodiA+PSAxNikge1xuICAgICAgICAvLyB0aGlzIHdvbid0IG1lc3MgdXAgZmV0Y2hcbiAgICAgICAgY29uc3Qgc3RyZWFtcyA9IHJlcXVpcmUoXCJzdHJlYW0vd2ViXCIpO1xuICAgICAgICAvLyB2aWV3cyB3aWxsIHRvc3MgaWYgUmVhZGFibGVTdHJlYW0gaXMgbm90IGF2YWlsYWJsZVxuICAgICAgICBnbG9iYWwuUmVhZGFibGVTdHJlYW0gPSBzdHJlYW1zLlJlYWRhYmxlU3RyZWFtO1xuICAgIH1cbn1cbnZhciBjb25uZWN0XzEgPSByZXF1aXJlKFwiLi9jb25uZWN0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29ubmVjdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdF8xLmNvbm5lY3Q7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4uL25hdHMtYmFzZS1jbGllbnQvbW9kXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi4vamV0c3RyZWFtL21vZFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/src/mod.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/src/nats-base-client.js":
/*!*******************************************************!*\
  !*** ./node_modules/nats/lib/src/nats-base-client.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/*\n * Copyright 2020 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n__exportStar(__webpack_require__(/*! ../nats-base-client/internal_mod */ \"(rsc)/./node_modules/nats/lib/nats-base-client/internal_mod.js\"), exports);\n__exportStar(__webpack_require__(/*! ../jetstream/internal_mod */ \"(rsc)/./node_modules/nats/lib/jetstream/internal_mod.js\"), exports);\n//# sourceMappingURL=nats-base-client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvc3JjL25hdHMtYmFzZS1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyx3R0FBa0M7QUFDdkQsYUFBYSxtQkFBTyxDQUFDLDBGQUEyQjtBQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL3NyYy9uYXRzLWJhc2UtY2xpZW50LmpzPzRiMTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L2ludGVybmFsX21vZFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4uL2pldHN0cmVhbS9pbnRlcm5hbF9tb2RcIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF0cy1iYXNlLWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/src/nats-base-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nats/lib/src/node_transport.js":
/*!*****************************************************!*\
  !*** ./node_modules/nats/lib/src/node_transport.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __awaiter = (void 0) && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __await = (void 0) && (void 0).__await || function(v) {\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\n};\nvar __asyncGenerator = (void 0) && (void 0).__asyncGenerator || function(thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i;\n    function awaitReturn(f) {\n        return function(v) {\n            return Promise.resolve(v).then(f, reject);\n        };\n    }\n    function verb(n, f) {\n        if (g[n]) {\n            i[n] = function(v) {\n                return new Promise(function(a, b) {\n                    q.push([\n                        n,\n                        v,\n                        a,\n                        b\n                    ]) > 1 || resume(n, v);\n                });\n            };\n            if (f) i[n] = f(i[n]);\n        }\n    }\n    function resume(n, v) {\n        try {\n            step(g[n](v));\n        } catch (e) {\n            settle(q[0][3], e);\n        }\n    }\n    function step(r) {\n        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n    }\n    function fulfill(value) {\n        resume(\"next\", value);\n    }\n    function reject(value) {\n        resume(\"throw\", value);\n    }\n    function settle(f, v) {\n        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.nodeResolveHost = exports.NodeTransport = void 0;\n/*\n * Copyright 2020-2023 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ const nats_base_client_1 = __webpack_require__(/*! ./nats-base-client */ \"(rsc)/./node_modules/nats/lib/src/nats-base-client.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst util_1 = __webpack_require__(/*! ../nats-base-client/util */ \"(rsc)/./node_modules/nats/lib/nats-base-client/util.js\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst { resolve } = __webpack_require__(/*! path */ \"path\");\nconst { readFile, existsSync } = __webpack_require__(/*! fs */ \"fs\");\nconst dns = __webpack_require__(/*! dns */ \"dns\");\nconst VERSION = \"2.19.0\";\nconst LANG = \"nats.js\";\nclass NodeTransport {\n    constructor(){\n        this.yields = [];\n        this.signal = (0, nats_base_client_1.deferred)();\n        this.closedNotification = (0, nats_base_client_1.deferred)();\n        this.connected = false;\n        this.tlsName = \"\";\n        this.done = false;\n        this.lang = LANG;\n        this.version = VERSION;\n    }\n    connect(hp, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.tlsName = hp.tlsName;\n            this.options = options;\n            try {\n                this.socket = yield this.dial(hp);\n                const info = yield this.peekInfo();\n                (0, nats_base_client_1.checkOptions)(info, options);\n                const { tls_required: tlsRequired, tls_available: tlsAvailable } = info;\n                const desired = tlsAvailable === true && options.tls !== null;\n                if (tlsRequired || desired) {\n                    this.socket = yield this.startTLS();\n                }\n                //@ts-ignore: this is possibly a TlsSocket\n                if (tlsRequired && this.socket.encrypted !== true) {\n                    throw new nats_base_client_1.NatsError(\"tls\", nats_base_client_1.ErrorCode.ServerOptionNotAvailable);\n                }\n                this.connected = true;\n                this.setupHandlers();\n                this.signal.resolve();\n                return Promise.resolve();\n            } catch (err) {\n                if (!err) {\n                    // this seems to be possible in Kubernetes\n                    // where an error is thrown, but it is undefined\n                    // when something like istio-init is booting up\n                    err = nats_base_client_1.NatsError.errorForCode(nats_base_client_1.ErrorCode.ConnectionRefused, new Error(\"node provided an undefined error!\"));\n                }\n                const { code } = err;\n                const perr = code === \"ECONNREFUSED\" ? nats_base_client_1.NatsError.errorForCode(nats_base_client_1.ErrorCode.ConnectionRefused, err) : err;\n                if (this.socket) {\n                    this.socket.destroy();\n                }\n                throw perr;\n            }\n        });\n    }\n    dial(hp) {\n        const d = (0, nats_base_client_1.deferred)();\n        let dialError;\n        const socket = (0, net_1.createConnection)(hp.port, hp.hostname, ()=>{\n            d.resolve(socket);\n            socket.removeAllListeners();\n        });\n        socket.on(\"error\", (err)=>{\n            dialError = err;\n        });\n        socket.on(\"close\", ()=>{\n            socket.removeAllListeners();\n            d.reject(dialError);\n        });\n        socket.setNoDelay(true);\n        return d;\n    }\n    get isClosed() {\n        return this.done;\n    }\n    close(err) {\n        return this._closed(err, false);\n    }\n    peekInfo() {\n        const d = (0, nats_base_client_1.deferred)();\n        let peekError;\n        this.socket.on(\"data\", (frame)=>{\n            this.yields.push(frame);\n            const t = nats_base_client_1.DataBuffer.concat(...this.yields);\n            const pm = (0, nats_base_client_1.extractProtocolMessage)(t);\n            if (pm !== \"\") {\n                try {\n                    const m = nats_base_client_1.INFO.exec(pm);\n                    if (!m) {\n                        throw new Error(\"unexpected response from server\");\n                    }\n                    const info = JSON.parse(m[1]);\n                    d.resolve(info);\n                } catch (err) {\n                    d.reject(err);\n                } finally{\n                    this.socket.removeAllListeners();\n                }\n            }\n        });\n        this.socket.on(\"error\", (err)=>{\n            peekError = err;\n        });\n        this.socket.on(\"close\", ()=>{\n            this.socket.removeAllListeners();\n            d.reject(peekError);\n        });\n        return d;\n    }\n    loadFile(fn) {\n        if (!fn) {\n            return Promise.resolve();\n        }\n        const d = (0, nats_base_client_1.deferred)();\n        try {\n            fn = resolve(fn);\n            if (!existsSync(fn)) {\n                d.reject(new Error(`${fn} doesn't exist`));\n            }\n            readFile(fn, (err, data)=>{\n                if (err) {\n                    return d.reject(err);\n                }\n                d.resolve(data);\n            });\n        } catch (err) {\n            d.reject(err);\n        }\n        return d;\n    }\n    loadClientCerts() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const tlsOpts = {};\n            const { certFile, cert, caFile, ca, keyFile, key } = this.options.tls;\n            try {\n                if (certFile) {\n                    const data = yield this.loadFile(certFile);\n                    if (data) {\n                        tlsOpts.cert = data;\n                    }\n                } else if (cert) {\n                    tlsOpts.cert = cert;\n                }\n                if (keyFile) {\n                    const data = yield this.loadFile(keyFile);\n                    if (data) {\n                        tlsOpts.key = data;\n                    }\n                } else if (key) {\n                    tlsOpts.key = key;\n                }\n                if (caFile) {\n                    const data = yield this.loadFile(caFile);\n                    if (data) {\n                        tlsOpts.ca = [\n                            data\n                        ];\n                    }\n                } else if (ca) {\n                    tlsOpts.ca = ca;\n                }\n                return Promise.resolve(tlsOpts);\n            } catch (err) {\n                return Promise.reject(err);\n            }\n        });\n    }\n    startTLS() {\n        return __awaiter(this, void 0, void 0, function*() {\n            let tlsError;\n            let tlsOpts = {\n                socket: this.socket,\n                servername: this.tlsName,\n                rejectUnauthorized: true\n            };\n            if (typeof this.options.tls === \"object\") {\n                try {\n                    const certOpts = (yield this.loadClientCerts()) || {};\n                    tlsOpts = (0, util_1.extend)(tlsOpts, this.options.tls, certOpts);\n                } catch (err) {\n                    return Promise.reject(new nats_base_client_1.NatsError(err.message, nats_base_client_1.ErrorCode.Tls, err));\n                }\n            }\n            const d = (0, nats_base_client_1.deferred)();\n            try {\n                const tlsSocket = (0, tls_1.connect)(tlsOpts, ()=>{\n                    tlsSocket.removeAllListeners();\n                    d.resolve(tlsSocket);\n                });\n                tlsSocket.on(\"error\", (err)=>{\n                    tlsError = err;\n                });\n                tlsSocket.on(\"secureConnect\", ()=>{\n                    // socket won't be authorized, if the user disabled it\n                    if (tlsOpts.rejectUnauthorized === false) {\n                        return;\n                    }\n                    if (!tlsSocket.authorized) {\n                        throw tlsSocket.authorizationError;\n                    }\n                });\n                tlsSocket.on(\"close\", ()=>{\n                    d.reject(tlsError);\n                    tlsSocket.removeAllListeners();\n                });\n            } catch (err) {\n                // tls throws errors on bad certs see nats.js#310\n                d.reject(nats_base_client_1.NatsError.errorForCode(nats_base_client_1.ErrorCode.Tls, err));\n            }\n            return d;\n        });\n    }\n    setupHandlers() {\n        let connError;\n        this.socket.on(\"data\", (frame)=>{\n            this.yields.push(frame);\n            return this.signal.resolve();\n        });\n        this.socket.on(\"error\", (err)=>{\n            connError = err;\n        });\n        this.socket.on(\"end\", ()=>{\n            var _a, _b;\n            if ((_a = this.socket) === null || _a === void 0 ? void 0 : _a.destroyed) {\n                return;\n            }\n            (_b = this.socket) === null || _b === void 0 ? void 0 : _b.write(new Uint8Array(0), ()=>{\n                var _a;\n                (_a = this.socket) === null || _a === void 0 ? void 0 : _a.end();\n            });\n        });\n        this.socket.on(\"close\", ()=>{\n            this._closed(connError, false);\n        });\n    }\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    iterate() {\n        return __asyncGenerator(this, arguments, function* iterate_1() {\n            const debug = this.options.debug;\n            while(true){\n                if (this.yields.length === 0) {\n                    yield __await(this.signal);\n                }\n                const yields = this.yields;\n                this.yields = [];\n                for(let i = 0; i < yields.length; i++){\n                    if (debug) {\n                        console.info(`> ${(0, nats_base_client_1.render)(yields[i])}`);\n                    }\n                    yield yield __await(yields[i]);\n                }\n                // yielding could have paused and microtask\n                // could have added messages. Prevent allocations\n                // if possible\n                if (this.done) {\n                    break;\n                } else if (this.yields.length === 0) {\n                    yields.length = 0;\n                    this.yields = yields;\n                    this.signal = (0, nats_base_client_1.deferred)();\n                }\n            }\n        });\n    }\n    discard() {\n    // ignored - this is not required, as there's no throttling\n    }\n    disconnect() {\n        this._closed(undefined, true).then().catch();\n    }\n    isEncrypted() {\n        return this.socket instanceof tls_1.TLSSocket;\n    }\n    _send(frame) {\n        if (this.isClosed || this.socket === undefined) {\n            return Promise.resolve();\n        }\n        if (this.options.debug) {\n            console.info(`< ${(0, nats_base_client_1.render)(frame)}`);\n        }\n        const d = (0, nats_base_client_1.deferred)();\n        try {\n            this.socket.write(frame, (err)=>{\n                if (err) {\n                    if (this.options.debug) {\n                        console.error(`!!! ${(0, nats_base_client_1.render)(frame)}: ${err}`);\n                    }\n                    return d.reject(err);\n                }\n                return d.resolve();\n            });\n        } catch (err) {\n            if (this.options.debug) {\n                console.error(`!!! ${(0, nats_base_client_1.render)(frame)}: ${err}`);\n            }\n            d.reject(err);\n        }\n        return d;\n    }\n    send(frame) {\n        const p = this._send(frame);\n        p.catch((_err)=>{\n        // we ignore write errors because client will\n        // fail on a read or when the heartbeat timer\n        // detects a stale connection\n        });\n    }\n    _closed(err, internal = true) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // if this connection didn't succeed, then ignore it.\n            if (!this.connected) return;\n            if (this.done) return;\n            this.closeError = err;\n            // only try to flush the outbound buffer if we got no error and\n            // the close is internal, if the transport closed, we are done.\n            if (!err && this.socket && internal) {\n                try {\n                    yield this._send(new TextEncoder().encode(\"\"));\n                } catch (err) {\n                    if (this.options.debug) {\n                        console.log(\"transport close terminated with an error\", err);\n                    }\n                }\n            }\n            try {\n                if (this.socket) {\n                    this.socket.removeAllListeners();\n                    this.socket.destroy();\n                    this.socket = undefined;\n                }\n            } catch (err) {\n                console.log(err);\n            }\n            this.done = true;\n            this.closedNotification.resolve(this.closeError);\n        });\n    }\n    closed() {\n        return this.closedNotification;\n    }\n}\nexports.NodeTransport = NodeTransport;\nfunction nodeResolveHost(s) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const a = (0, nats_base_client_1.deferred)();\n        const aaaa = (0, nats_base_client_1.deferred)();\n        dns.resolve4(s, (err, records)=>{\n            if (err) {\n                a.resolve(err);\n            } else {\n                a.resolve(records);\n            }\n        });\n        dns.resolve6(s, (err, records)=>{\n            if (err) {\n                aaaa.resolve(err);\n            } else {\n                aaaa.resolve(records);\n            }\n        });\n        const ips = [];\n        const da = yield a;\n        if (Array.isArray(da)) {\n            ips.push(...da);\n        }\n        const daaaa = yield aaaa;\n        if (Array.isArray(daaaa)) {\n            ips.push(...daaaa);\n        }\n        if (ips.length === 0) {\n            ips.push(s);\n        }\n        return ips;\n    });\n}\nexports.nodeResolveHost = nodeResolveHost; //# sourceMappingURL=node_transport.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmF0cy9saWIvc3JjL25vZGVfdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsWUFBWSxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFNBQVMsSUFBSyxTQUFVQyxPQUFPLEVBQUVDLFVBQVUsRUFBRUMsQ0FBQyxFQUFFQyxTQUFTO0lBQ25GLFNBQVNDLE1BQU1DLEtBQUs7UUFBSSxPQUFPQSxpQkFBaUJILElBQUlHLFFBQVEsSUFBSUgsRUFBRSxTQUFVSSxPQUFPO1lBQUlBLFFBQVFEO1FBQVE7SUFBSTtJQUMzRyxPQUFPLElBQUtILENBQUFBLEtBQU1BLENBQUFBLElBQUlLLE9BQU0sQ0FBQyxFQUFHLFNBQVVELE9BQU8sRUFBRUUsTUFBTTtRQUNyRCxTQUFTQyxVQUFVSixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsVUFBVVEsSUFBSSxDQUFDTjtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzFGLFNBQVNDLFNBQVNSLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxTQUFTLENBQUMsUUFBUSxDQUFDRTtZQUFTLEVBQUUsT0FBT08sR0FBRztnQkFBRUosT0FBT0k7WUFBSTtRQUFFO1FBQzdGLFNBQVNGLEtBQUtJLE1BQU07WUFBSUEsT0FBT0MsSUFBSSxHQUFHVCxRQUFRUSxPQUFPVCxLQUFLLElBQUlELE1BQU1VLE9BQU9ULEtBQUssRUFBRVcsSUFBSSxDQUFDUCxXQUFXSTtRQUFXO1FBQzdHSCxLQUFLLENBQUNQLFlBQVlBLFVBQVVjLEtBQUssQ0FBQ2pCLFNBQVNDLGNBQWMsRUFBRSxHQUFHVSxJQUFJO0lBQ3RFO0FBQ0o7QUFDQSxJQUFJTyxVQUFVLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsT0FBTyxJQUFLLFNBQVVDLENBQUM7SUFBSSxPQUFPLElBQUksWUFBWUQsVUFBVyxLQUFJLENBQUNDLENBQUMsR0FBR0EsR0FBRyxJQUFJLElBQUks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Z0JBQ0xrRixLQUFLaEssT0FBTyxDQUFDOEU7WUFDakIsT0FDSztnQkFDRGtGLEtBQUtoSyxPQUFPLENBQUNrSztZQUNqQjtRQUNKO1FBQ0EsTUFBTUUsTUFBTSxFQUFFO1FBQ2QsTUFBTUMsS0FBSyxNQUFNNUk7UUFDakIsSUFBSTZJLE1BQU1DLE9BQU8sQ0FBQ0YsS0FBSztZQUNuQkQsSUFBSXpJLElBQUksSUFBSTBJO1FBQ2hCO1FBQ0EsTUFBTUcsUUFBUSxNQUFNUjtRQUNwQixJQUFJTSxNQUFNQyxPQUFPLENBQUNDLFFBQVE7WUFDdEJKLElBQUl6SSxJQUFJLElBQUk2STtRQUNoQjtRQUNBLElBQUlKLElBQUluSSxNQUFNLEtBQUssR0FBRztZQUNsQm1JLElBQUl6SSxJQUFJLENBQUNvSTtRQUNiO1FBQ0EsT0FBT0s7SUFDWDtBQUNKO0FBQ0FoSSx1QkFBdUIsR0FBR0MsaUJBQzFCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vbm9kZV9tb2R1bGVzL25hdHMvbGliL3NyYy9ub2RlX3RyYW5zcG9ydC5qcz83ZDVmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19hd2FpdCA9ICh0aGlzICYmIHRoaXMuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub2RlUmVzb2x2ZUhvc3QgPSBleHBvcnRzLk5vZGVUcmFuc3BvcnQgPSB2b2lkIDA7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAtMjAyMyBUaGUgTkFUUyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgbmF0c19iYXNlX2NsaWVudF8xID0gcmVxdWlyZShcIi4vbmF0cy1iYXNlLWNsaWVudFwiKTtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi9uYXRzLWJhc2UtY2xpZW50L3V0aWxcIik7XG5jb25zdCB0bHNfMSA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCB7IHJlc29sdmUgfSA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgeyByZWFkRmlsZSwgZXhpc3RzU3luYyB9ID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgZG5zID0gcmVxdWlyZShcImRuc1wiKTtcbmNvbnN0IFZFUlNJT04gPSBcIjIuMTkuMFwiO1xuY29uc3QgTEFORyA9IFwibmF0cy5qc1wiO1xuY2xhc3MgTm9kZVRyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMueWllbGRzID0gW107XG4gICAgICAgIHRoaXMuc2lnbmFsID0gKDAsIG5hdHNfYmFzZV9jbGllbnRfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgdGhpcy5jbG9zZWROb3RpZmljYXRpb24gPSAoMCwgbmF0c19iYXNlX2NsaWVudF8xLmRlZmVycmVkKSgpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRsc05hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sYW5nID0gTEFORztcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gVkVSU0lPTjtcbiAgICB9XG4gICAgY29ubmVjdChocCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy50bHNOYW1lID0gaHAudGxzTmFtZTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0ID0geWllbGQgdGhpcy5kaWFsKGhwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0geWllbGQgdGhpcy5wZWVrSW5mbygpO1xuICAgICAgICAgICAgICAgICgwLCBuYXRzX2Jhc2VfY2xpZW50XzEuY2hlY2tPcHRpb25zKShpbmZvLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRsc19yZXF1aXJlZDogdGxzUmVxdWlyZWQsIHRsc19hdmFpbGFibGU6IHRsc0F2YWlsYWJsZSB9ID0gaW5mbztcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNpcmVkID0gdGxzQXZhaWxhYmxlID09PSB0cnVlICYmIG9wdGlvbnMudGxzICE9PSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0bHNSZXF1aXJlZCB8fCBkZXNpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0ID0geWllbGQgdGhpcy5zdGFydFRMUygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmU6IHRoaXMgaXMgcG9zc2libHkgYSBUbHNTb2NrZXRcbiAgICAgICAgICAgICAgICBpZiAodGxzUmVxdWlyZWQgJiYgdGhpcy5zb2NrZXQuZW5jcnlwdGVkICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBuYXRzX2Jhc2VfY2xpZW50XzEuTmF0c0Vycm9yKFwidGxzXCIsIG5hdHNfYmFzZV9jbGllbnRfMS5FcnJvckNvZGUuU2VydmVyT3B0aW9uTm90QXZhaWxhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBIYW5kbGVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmFsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBzZWVtcyB0byBiZSBwb3NzaWJsZSBpbiBLdWJlcm5ldGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdoZXJlIGFuIGVycm9yIGlzIHRocm93biwgYnV0IGl0IGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHNvbWV0aGluZyBsaWtlIGlzdGlvLWluaXQgaXMgYm9vdGluZyB1cFxuICAgICAgICAgICAgICAgICAgICBlcnIgPSBuYXRzX2Jhc2VfY2xpZW50XzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShuYXRzX2Jhc2VfY2xpZW50XzEuRXJyb3JDb2RlLkNvbm5lY3Rpb25SZWZ1c2VkLCBuZXcgRXJyb3IoXCJub2RlIHByb3ZpZGVkIGFuIHVuZGVmaW5lZCBlcnJvciFcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUgfSA9IGVycjtcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJyID0gY29kZSA9PT0gXCJFQ09OTlJFRlVTRURcIlxuICAgICAgICAgICAgICAgICAgICA/IG5hdHNfYmFzZV9jbGllbnRfMS5OYXRzRXJyb3IuZXJyb3JGb3JDb2RlKG5hdHNfYmFzZV9jbGllbnRfMS5FcnJvckNvZGUuQ29ubmVjdGlvblJlZnVzZWQsIGVycilcbiAgICAgICAgICAgICAgICAgICAgOiBlcnI7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgcGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpYWwoaHApIHtcbiAgICAgICAgY29uc3QgZCA9ICgwLCBuYXRzX2Jhc2VfY2xpZW50XzEuZGVmZXJyZWQpKCk7XG4gICAgICAgIGxldCBkaWFsRXJyb3I7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9ICgwLCBuZXRfMS5jcmVhdGVDb25uZWN0aW9uKShocC5wb3J0LCBocC5ob3N0bmFtZSwgKCkgPT4ge1xuICAgICAgICAgICAgZC5yZXNvbHZlKHNvY2tldCk7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzb2NrZXQub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBkaWFsRXJyb3IgPSBlcnI7XG4gICAgICAgIH0pO1xuICAgICAgICBzb2NrZXQub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBkLnJlamVjdChkaWFsRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgc29ja2V0LnNldE5vRGVsYXkodHJ1ZSk7XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBnZXQgaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbmU7XG4gICAgfVxuICAgIGNsb3NlKGVycikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkKGVyciwgZmFsc2UpO1xuICAgIH1cbiAgICBwZWVrSW5mbygpIHtcbiAgICAgICAgY29uc3QgZCA9ICgwLCBuYXRzX2Jhc2VfY2xpZW50XzEuZGVmZXJyZWQpKCk7XG4gICAgICAgIGxldCBwZWVrRXJyb3I7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZGF0YVwiLCAoZnJhbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMueWllbGRzLnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgY29uc3QgdCA9IG5hdHNfYmFzZV9jbGllbnRfMS5EYXRhQnVmZmVyLmNvbmNhdCguLi50aGlzLnlpZWxkcyk7XG4gICAgICAgICAgICBjb25zdCBwbSA9ICgwLCBuYXRzX2Jhc2VfY2xpZW50XzEuZXh0cmFjdFByb3RvY29sTWVzc2FnZSkodCk7XG4gICAgICAgICAgICBpZiAocG0gIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtID0gbmF0c19iYXNlX2NsaWVudF8xLklORk8uZXhlYyhwbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5leHBlY3RlZCByZXNwb25zZSBmcm9tIHNlcnZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0gSlNPTi5wYXJzZShtWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgZC5yZXNvbHZlKGluZm8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvY2tldC5vbihcImVycm9yXCIsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHBlZWtFcnJvciA9IGVycjtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiY2xvc2VcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBkLnJlamVjdChwZWVrRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuICAgIGxvYWRGaWxlKGZuKSB7XG4gICAgICAgIGlmICghZm4pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkID0gKDAsIG5hdHNfYmFzZV9jbGllbnRfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZuID0gcmVzb2x2ZShmbik7XG4gICAgICAgICAgICBpZiAoIWV4aXN0c1N5bmMoZm4pKSB7XG4gICAgICAgICAgICAgICAgZC5yZWplY3QobmV3IEVycm9yKGAke2ZufSBkb2Vzbid0IGV4aXN0YCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZEZpbGUoZm4sIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBsb2FkQ2xpZW50Q2VydHMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0bHNPcHRzID0ge307XG4gICAgICAgICAgICBjb25zdCB7IGNlcnRGaWxlLCBjZXJ0LCBjYUZpbGUsIGNhLCBrZXlGaWxlLCBrZXkgfSA9IHRoaXMub3B0aW9ucy50bHM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjZXJ0RmlsZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgdGhpcy5sb2FkRmlsZShjZXJ0RmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bHNPcHRzLmNlcnQgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGxzT3B0cy5jZXJ0ID0gY2VydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleUZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHRoaXMubG9hZEZpbGUoa2V5RmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bHNPcHRzLmtleSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRsc09wdHMua2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FGaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCB0aGlzLmxvYWRGaWxlKGNhRmlsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bHNPcHRzLmNhID0gW2RhdGFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRsc09wdHMuY2EgPSBjYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0bHNPcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0VExTKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHRsc0Vycm9yO1xuICAgICAgICAgICAgbGV0IHRsc09wdHMgPSB7XG4gICAgICAgICAgICAgICAgc29ja2V0OiB0aGlzLnNvY2tldCxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJuYW1lOiB0aGlzLnRsc05hbWUsXG4gICAgICAgICAgICAgICAgcmVqZWN0VW5hdXRob3JpemVkOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnRscyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlcnRPcHRzID0gKHlpZWxkIHRoaXMubG9hZENsaWVudENlcnRzKCkpIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICB0bHNPcHRzID0gKDAsIHV0aWxfMS5leHRlbmQpKHRsc09wdHMsIHRoaXMub3B0aW9ucy50bHMsIGNlcnRPcHRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IG5hdHNfYmFzZV9jbGllbnRfMS5OYXRzRXJyb3IoZXJyLm1lc3NhZ2UsIG5hdHNfYmFzZV9jbGllbnRfMS5FcnJvckNvZGUuVGxzLCBlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkID0gKDAsIG5hdHNfYmFzZV9jbGllbnRfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGxzU29ja2V0ID0gKDAsIHRsc18xLmNvbm5lY3QpKHRsc09wdHMsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGxzU29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICBkLnJlc29sdmUodGxzU29ja2V0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0bHNTb2NrZXQub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRsc0Vycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRsc1NvY2tldC5vbihcInNlY3VyZUNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBzb2NrZXQgd29uJ3QgYmUgYXV0aG9yaXplZCwgaWYgdGhlIHVzZXIgZGlzYWJsZWQgaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRsc09wdHMucmVqZWN0VW5hdXRob3JpemVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGxzU29ja2V0LmF1dGhvcml6ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRsc1NvY2tldC5hdXRob3JpemF0aW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0bHNTb2NrZXQub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGQucmVqZWN0KHRsc0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGxzU29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIHRscyB0aHJvd3MgZXJyb3JzIG9uIGJhZCBjZXJ0cyBzZWUgbmF0cy5qcyMzMTBcbiAgICAgICAgICAgICAgICBkLnJlamVjdChuYXRzX2Jhc2VfY2xpZW50XzEuTmF0c0Vycm9yLmVycm9yRm9yQ29kZShuYXRzX2Jhc2VfY2xpZW50XzEuRXJyb3JDb2RlLlRscywgZXJyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldHVwSGFuZGxlcnMoKSB7XG4gICAgICAgIGxldCBjb25uRXJyb3I7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZGF0YVwiLCAoZnJhbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMueWllbGRzLnB1c2goZnJhbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmFsLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgY29ubkVycm9yID0gZXJyO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLnNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IHRoaXMuc29ja2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud3JpdGUobmV3IFVpbnQ4QXJyYXkoMCksICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5zb2NrZXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZWQoY29ubkVycm9yLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlKCk7XG4gICAgfVxuICAgIGl0ZXJhdGUoKSB7XG4gICAgICAgIHJldHVybiBfX2FzeW5jR2VuZXJhdG9yKHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24qIGl0ZXJhdGVfMSgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlYnVnID0gdGhpcy5vcHRpb25zLmRlYnVnO1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy55aWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIF9fYXdhaXQodGhpcy5zaWduYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB5aWVsZHMgPSB0aGlzLnlpZWxkcztcbiAgICAgICAgICAgICAgICB0aGlzLnlpZWxkcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgeWllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKGA+ICR7KDAsIG5hdHNfYmFzZV9jbGllbnRfMS5yZW5kZXIpKHlpZWxkc1tpXSl9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh5aWVsZHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB5aWVsZGluZyBjb3VsZCBoYXZlIHBhdXNlZCBhbmQgbWljcm90YXNrXG4gICAgICAgICAgICAgICAgLy8gY291bGQgaGF2ZSBhZGRlZCBtZXNzYWdlcy4gUHJldmVudCBhbGxvY2F0aW9uc1xuICAgICAgICAgICAgICAgIC8vIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy55aWVsZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnlpZWxkcyA9IHlpZWxkcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaWduYWwgPSAoMCwgbmF0c19iYXNlX2NsaWVudF8xLmRlZmVycmVkKSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc2NhcmQoKSB7XG4gICAgICAgIC8vIGlnbm9yZWQgLSB0aGlzIGlzIG5vdCByZXF1aXJlZCwgYXMgdGhlcmUncyBubyB0aHJvdHRsaW5nXG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCh1bmRlZmluZWQsIHRydWUpLnRoZW4oKS5jYXRjaCgpO1xuICAgIH1cbiAgICBpc0VuY3J5cHRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0IGluc3RhbmNlb2YgdGxzXzEuVExTU29ja2V0O1xuICAgIH1cbiAgICBfc2VuZChmcmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCB8fCB0aGlzLnNvY2tldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKGA8ICR7KDAsIG5hdHNfYmFzZV9jbGllbnRfMS5yZW5kZXIpKGZyYW1lKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkID0gKDAsIG5hdHNfYmFzZV9jbGllbnRfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LndyaXRlKGZyYW1lLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGAhISEgJHsoMCwgbmF0c19iYXNlX2NsaWVudF8xLnJlbmRlcikoZnJhbWUpfTogJHtlcnJ9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkLnJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGAhISEgJHsoMCwgbmF0c19iYXNlX2NsaWVudF8xLnJlbmRlcikoZnJhbWUpfTogJHtlcnJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkO1xuICAgIH1cbiAgICBzZW5kKGZyYW1lKSB7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLl9zZW5kKGZyYW1lKTtcbiAgICAgICAgcC5jYXRjaCgoX2VycikgPT4ge1xuICAgICAgICAgICAgLy8gd2UgaWdub3JlIHdyaXRlIGVycm9ycyBiZWNhdXNlIGNsaWVudCB3aWxsXG4gICAgICAgICAgICAvLyBmYWlsIG9uIGEgcmVhZCBvciB3aGVuIHRoZSBoZWFydGJlYXQgdGltZXJcbiAgICAgICAgICAgIC8vIGRldGVjdHMgYSBzdGFsZSBjb25uZWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY2xvc2VkKGVyciwgaW50ZXJuYWwgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGNvbm5lY3Rpb24gZGlkbid0IHN1Y2NlZWQsIHRoZW4gaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy5kb25lKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VFcnJvciA9IGVycjtcbiAgICAgICAgICAgIC8vIG9ubHkgdHJ5IHRvIGZsdXNoIHRoZSBvdXRib3VuZCBidWZmZXIgaWYgd2UgZ290IG5vIGVycm9yIGFuZFxuICAgICAgICAgICAgLy8gdGhlIGNsb3NlIGlzIGludGVybmFsLCBpZiB0aGUgdHJhbnNwb3J0IGNsb3NlZCwgd2UgYXJlIGRvbmUuXG4gICAgICAgICAgICBpZiAoIWVyciAmJiB0aGlzLnNvY2tldCAmJiBpbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX3NlbmQobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKFwiXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInRyYW5zcG9ydCBjbG9zZSB0ZXJtaW5hdGVkIHdpdGggYW4gZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkTm90aWZpY2F0aW9uLnJlc29sdmUodGhpcy5jbG9zZUVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VkTm90aWZpY2F0aW9uO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9kZVRyYW5zcG9ydCA9IE5vZGVUcmFuc3BvcnQ7XG5mdW5jdGlvbiBub2RlUmVzb2x2ZUhvc3Qocykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGEgPSAoMCwgbmF0c19iYXNlX2NsaWVudF8xLmRlZmVycmVkKSgpO1xuICAgICAgICBjb25zdCBhYWFhID0gKDAsIG5hdHNfYmFzZV9jbGllbnRfMS5kZWZlcnJlZCkoKTtcbiAgICAgICAgZG5zLnJlc29sdmU0KHMsIChlcnIsIHJlY29yZHMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBhLnJlc29sdmUoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGEucmVzb2x2ZShyZWNvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRucy5yZXNvbHZlNihzLCAoZXJyLCByZWNvcmRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYWFhYS5yZXNvbHZlKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhYWFhLnJlc29sdmUocmVjb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpcHMgPSBbXTtcbiAgICAgICAgY29uc3QgZGEgPSB5aWVsZCBhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYSkpIHtcbiAgICAgICAgICAgIGlwcy5wdXNoKC4uLmRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYWFhYSA9IHlpZWxkIGFhYWE7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhYWFhKSkge1xuICAgICAgICAgICAgaXBzLnB1c2goLi4uZGFhYWEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBpcHMucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXBzO1xuICAgIH0pO1xufVxuZXhwb3J0cy5ub2RlUmVzb2x2ZUhvc3QgPSBub2RlUmVzb2x2ZUhvc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub2RlX3RyYW5zcG9ydC5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX19hd2FpdCIsInYiLCJfX2FzeW5jR2VuZXJhdG9yIiwiU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsIlR5cGVFcnJvciIsImciLCJpIiwicSIsInZlcmIiLCJhd2FpdFJldHVybiIsImYiLCJuIiwiYSIsImIiLCJwdXNoIiwicmVzdW1lIiwic2V0dGxlIiwiciIsImZ1bGZpbGwiLCJzaGlmdCIsImxlbmd0aCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsIm5vZGVSZXNvbHZlSG9zdCIsIk5vZGVUcmFuc3BvcnQiLCJuYXRzX2Jhc2VfY2xpZW50XzEiLCJyZXF1aXJlIiwibmV0XzEiLCJ1dGlsXzEiLCJ0bHNfMSIsInJlYWRGaWxlIiwiZXhpc3RzU3luYyIsImRucyIsIlZFUlNJT04iLCJMQU5HIiwiY29uc3RydWN0b3IiLCJ5aWVsZHMiLCJzaWduYWwiLCJkZWZlcnJlZCIsImNsb3NlZE5vdGlmaWNhdGlvbiIsImNvbm5lY3RlZCIsInRsc05hbWUiLCJsYW5nIiwidmVyc2lvbiIsImNvbm5lY3QiLCJocCIsIm9wdGlvbnMiLCJzb2NrZXQiLCJkaWFsIiwiaW5mbyIsInBlZWtJbmZvIiwiY2hlY2tPcHRpb25zIiwidGxzX3JlcXVpcmVkIiwidGxzUmVxdWlyZWQiLCJ0bHNfYXZhaWxhYmxlIiwidGxzQXZhaWxhYmxlIiwiZGVzaXJlZCIsInRscyIsInN0YXJ0VExTIiwiZW5jcnlwdGVkIiwiTmF0c0Vycm9yIiwiRXJyb3JDb2RlIiwiU2VydmVyT3B0aW9uTm90QXZhaWxhYmxlIiwic2V0dXBIYW5kbGVycyIsImVyciIsImVycm9yRm9yQ29kZSIsIkNvbm5lY3Rpb25SZWZ1c2VkIiwiRXJyb3IiLCJjb2RlIiwicGVyciIsImRlc3Ryb3kiLCJkIiwiZGlhbEVycm9yIiwiY3JlYXRlQ29ubmVjdGlvbiIsInBvcnQiLCJob3N0bmFtZSIsInJlbW92ZUFsbExpc3RlbmVycyIsIm9uIiwic2V0Tm9EZWxheSIsImlzQ2xvc2VkIiwiY2xvc2UiLCJfY2xvc2VkIiwicGVla0Vycm9yIiwiZnJhbWUiLCJ0IiwiRGF0YUJ1ZmZlciIsImNvbmNhdCIsInBtIiwiZXh0cmFjdFByb3RvY29sTWVzc2FnZSIsIm0iLCJJTkZPIiwiZXhlYyIsIkpTT04iLCJwYXJzZSIsImxvYWRGaWxlIiwiZm4iLCJkYXRhIiwibG9hZENsaWVudENlcnRzIiwidGxzT3B0cyIsImNlcnRGaWxlIiwiY2VydCIsImNhRmlsZSIsImNhIiwia2V5RmlsZSIsImtleSIsInRsc0Vycm9yIiwic2VydmVybmFtZSIsInJlamVjdFVuYXV0aG9yaXplZCIsImNlcnRPcHRzIiwiZXh0ZW5kIiwibWVzc2FnZSIsIlRscyIsInRsc1NvY2tldCIsImF1dGhvcml6ZWQiLCJhdXRob3JpemF0aW9uRXJyb3IiLCJjb25uRXJyb3IiLCJfYSIsIl9iIiwiZGVzdHJveWVkIiwid3JpdGUiLCJVaW50OEFycmF5IiwiZW5kIiwiaXRlcmF0ZSIsImFyZ3VtZW50cyIsIml0ZXJhdGVfMSIsImRlYnVnIiwiY29uc29sZSIsInJlbmRlciIsImRpc2NhcmQiLCJkaXNjb25uZWN0IiwidW5kZWZpbmVkIiwiY2F0Y2giLCJpc0VuY3J5cHRlZCIsIlRMU1NvY2tldCIsIl9zZW5kIiwiZXJyb3IiLCJzZW5kIiwicCIsIl9lcnIiLCJpbnRlcm5hbCIsImNsb3NlRXJyb3IiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImxvZyIsImNsb3NlZCIsInMiLCJhYWFhIiwicmVzb2x2ZTQiLCJyZWNvcmRzIiwicmVzb2x2ZTYiLCJpcHMiLCJkYSIsIkFycmF5IiwiaXNBcnJheSIsImRhYWFhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nats/lib/src/node_transport.js\n");

/***/ })

};
;